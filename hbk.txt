mergesort一个linked list

Time Complexity: O(nLogn)



coding第二题：prime factor。

将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。
程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成： 
(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。
(2)如果n<>k，但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数你n,
　重复执行第一步。
(3)如果n不能被k整除，则用k+1作为k的值,重复执行第一步。
复制代码
#include "stdio.h"
#include "conio.h"
main()
{
  int n,i;
  printf("\nplease input a number:\n");
  scanf("%d",&n);
  printf("%d=",n);
  for(i=2;i<=n;i++)
    while(n!=i)
    {
      if(n%i==0)
      {
        printf("%d*",i);
        n=n/i;
      }
      else
        break;
    }
  printf("%d",n);
  getch();
}

一个是leetcode的题，Intersection of Two Linked Lists。问了下时间复杂度，O(n)
const ListNode* intersection(const ListNode* head1, const ListNode* head2) {
  const uint32_t len1 = length_iter(head1);
  const uint32_t len2 = length_iter(head2);

  function<const ListNode*(const uint32_t,const ListNode*,const ListNode*)> solve =
    [](const uint32_t diff, const ListNode* longer_head, const ListNode* shorter_head) -> const ListNode* {
    auto curr1 = longer_head;
    auto curr2 = shorter_head;

    for (uint32_t i = 0; i < diff; ++i) {
      if (!curr1) {
        return nullptr;
      }
      curr1 = curr1->next;
    }

    while (curr1 && curr2) {
      if (curr1 == curr2)
        return curr1;
      curr1 = curr1->next;
      curr2 = curr2->next;
    }

    return nullptr;
  };

  return (len1 > len2) ?
    solve(len1-len2, head1, head2) : solve(len2-len1, head2, head1);
}

还有一个是爬楼梯，你可以走1,2,3步，问N级楼梯有多少种走法。开始用数组DP做，an=a(n-1)+a(n-2)+a(n-3),
问了下时间复杂度O(n)，空间复杂度O(n)， 然后让优化下，用三个变量存a(n-1) 到a(n-3)，这样空间变成O(1);

O(mn) by using dynamic programming.
// count number of ways to reach n-th stair when a person can climb 1, 2, ..m stairs at a time
uint32_t countWays(const uint32_t n, const uint32_t m)
{
    uint32_t res[n+1]; // one extra line for 0
    res[0] = 1; res[1] = 1;
    for (uint32_t i = 2; i <= n; ++i)
    {
        res[i] = 0;
        for (uint32_t j = 1; j <= m && j <= i; ++j)
            res[i] += res[i-j];
    }
    return res[n];
}

印象最深刻的bug啊怎么解决的啊，一般喜欢怎样debug啊之类的 
然后让打开电脑写代码。 
第一题是给你一个正整数n，问能组成多少个n位数其中每一位数都比前一位数大或者相等。 
uint32_t countNonDecreasing(const uint32_t n)
{
    // dp[i][j] contains total count of non decreasing
    // numbers ending with digit i and of length j
    uint32_t dp[10][n+1];
    memset(dp, 0, sizeof dp);
 
    // Fill table for non decreasing numbers of length 1
    // Base cases 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
    for (uint8_t i = 0; i < 10; i++)
        dp[i][1] = 1;
 
    // Fill the table in bottom-up manner
    for (uint8_t digit = 0; digit <= 9; digit++)
    {
        // Compute total numbers of non decreasing
        // numbers of length 'len'
        for (uint32_t len = 2; len <= n; len++)
        {
            // sum of all numbers of length of len-1
            // in which last digit x is <= 'digit'
            for (uint8_t x = 0; x <= digit; x++)
                dp[digit][len] += dp[x][len-1];
        }
    }
 
    uint32_t ret = 0;
 
    // There total nondecreasing numbers of length n
    // wiint be dp[0][n] +  dp[1][n] ..+ dp[9][n]
    for (uint8_t i = 0; i < 10; i++)
        ret += dp[i][n];
 
    return ret;
}
第二题是说给你一个tree，实现serialize 和 deserialize。 
void serializeBinaryTree(TreeNode *p, ostream &out) {
    if (!p) {
        out << "# ";
    } else {
        out << p->val << " ";
        serializeBinaryTree(p->left, out);
        serializeBinaryTree(p->right, out);
    }
}
void deserializeBinaryTree(TreeNode *&p, ifstream &fin) {
    int token;
    bool isNumber;
    if (!readNextToken(token, fin, isNumber))
        return;
    if (isNumber) {
        p = new TreeNode(token);
        deserializeBinaryTree(p->left, fin);
        deserializeBinaryTree(p->right, fin);
    }
}

implement a function that verifies whether a binary tree is a binary search tree or not.
bool validate(const BinTreeNode* root) {
  function<bool(const BinTreeNode*,const int32_t,const int32_t)> solve =
    [&](const BinTreeNode* curr_root, const int32_t left_max, const int32_t right_min) {
    if (!curr_root)
      return true;

    if (curr_root->value <= left_max || curr_root->value > right_min)
      return false;

    if (!solve(curr_root->left, left_max, curr_root->value) ||
        !solve(curr_root->right, curr_root->value, right_min)) {
      return false;
    } else {
      return true;
    }
  };

  return solve(root, MIN_LMT, MAX_LMT);
}

find duplicates in two linked lists and find the lowest common ancestor
const BinTreeNode* LCA(const BinTreeNode* root, const int32_t n1, const int32_t n2) {
  int32_t target = MIN_LMT;
  vector<const BinTreeNode*> to_ext;

  function<bool(const BinTreeNode*)> solve = // backtracking
    [&](const BinTreeNode* curr_root) {
    if (!curr_root)
      return false;

    to_ext.push_back(curr_root);

    if (curr_root->value == target)
      return true;
    if (solve(curr_root->left) || solve(curr_root->right))
      return true;

    to_ext.pop_back();

    return false;
  };

  vector<const BinTreeNode*> path1, path2;
  target = n1;
  bool found = solve(root);
  if (!found)
    return nullptr;
  else
    path1 = to_ext;

  to_ext.clear();
  target = n2;
  found = solve(root);
  if (!found)
    return nullptr;
  else
    path2 = to_ext;

  uint32_t i = 0;
  for (; i < path1.size() && path1[i] == path2[i]; ++i);

  return i > 0 ? path1[i-1] : nullptr;
}

find two elements in an array which sum equals to a target number
pair<int32_t,int32_t> twoSum(const int32_t a[], const uint32_t n, const int32_t target) {
  if (!n)
    return {-1,-1};

  map<int32_t,int32_t> mem;
  pair<int32_t,int32_t> ret;

  for (uint32_t i = 0; i < n; ++i) {
    int32_t v = a[i];
    const int32_t remain = target-v;
    if (mem.count(remain)) {
      ret.first = mem[remain]+1; // index1 and index2 are not zero-based.
      ret.second = i+1;
      return ret;
    }

    mem[v] = i;
  }

  return ret;
}

How you tell if a positive number is a total square (4,9,16...)? Notice that a square number is the summation of odd series (9=1+3+5, 16 = 1+3+5+7)
You can find the end of the number in hex by a fast bit operation, then rule out 12 out of every 16 numbers. Then do the square root and square procedure on the 4 out of 16 numbers that slip through the hexadecimal filter.  Here’s C++ code for the algorithm.

int PerfectSquare(int n)
{
    int h = n & 0xF; // last hexadecimal "digit"
    if (h > 9)
        return 0; // return immediately in 6 cases out of 16.

    // Take advantage of Boolean short-circuit evaluation
    if ( h != 2 && h != 3 && h != 5 && h != 6 && h != 7 && h != 8 )
    {
        // take square root if you must
        int t = (int) floor( sqrt((double) n) + 0.5 );
            return t*t == n;
    }
    return 0;
}

test the online coding system

sorting multiple arrays

how do you integrate a struct with a declarative pointer in C++

http://stackoverflow.com/questions/631952/forward-declare-pointers-to-structs-in-c

in convex sets, what is smalllest whole divider
