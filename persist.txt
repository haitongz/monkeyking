Attention:  ./examples/02-libraries/calculator/Calculator.H
#ifndef BINLOG_EXAMPLE_LIBS_CALCULATOR_CALCULATOR_H_
#define BINLOG_EXAMPLE_LIBS_CALCULATOR_CALCULATOR_H_

float sqrt(float arg);

#endif /* BINLOG_EXAMPLE_LIBS_CALCULATOR_CALCULATOR_H_ */
Attention:  ./examples/02-libraries/calculator/Log.H
#ifndef BINLOG_EXAMPLE_LIBS_CALCULATOR_LOG_H_
#define BINLOG_EXAMPLE_LIBS_CALCULATOR_LOG_H_

/*
* Let's make its category name unique by overriding
* the release.
*/
#define BINLOG_USER_RELEASE "calculator"

#include <binlog/Binlog.H>

/*
* This one is really optional.
* But don't forget to do BINLOG_INIT in Log.C!
*/
//BINLOG_DECLARE

#endif /* BINLOG_EXAMPLE_LIBS_CALCULATOR_LOG_H_ */
Attention:  ./examples/02-libraries/nofooter/Functional.H
#ifndef MSTK_BINLOGEXAMPLE_NOFOOTER_FUNCTIONAL_H_
#define MSTK_BINLOGEXAMPLE_NOFOOTER_FUNCTIONAL_H_

/*
* This is a pretty simple header only "library".
*
* See Log.H for the interesting parts.
*/

#include <stdexcept>

#include "Log.H"

template <typename T>
bool isPositive(const T& a)
{
  return a > 0;
}

template <typename T>
T sumPositive(const T& a, const T&b)
{
  BINLOG_DEBUG("Call: {0} + {1}", a, b);

  if (isPositive(a) && isPositive(b))
  {
    T answer = a + b;
    BINLOG_INFO("answer calculated: {0}", answer);

    return answer;
  }

  BINLOG_ERROR("Invalid arguments!");
  throw std::invalid_argument("requires positive args");
}

#endif /* MSTK_BINLOGEXAMPLE_NOFOOTER_FUNCTIONAL_H_ */
Attention:  ./examples/02-libraries/nofooter/Log.H
#ifndef MSTK_BINLOGEXAMPLE_NOFOOTER_LOG_H_
#define MSTK_BINLOGEXAMPLE_NOFOOTER_LOG_H_

/*
* Logging is not possible if Binlog.H is not included
* or if libbinlog is not linked. However, by its nature,
* a header only library is not able to link anything.
*
* Therefore, logging should happen only if
* the client is a Binlog user. The following
* construct does exactly this by checking BINLOG_VERSION.
*/

#if not defined BINLOG_VERSION
  #define BINLOG_NOP do {} while (0)
  // disable logging
  #define BINLOG_DEBUG(...)      BINLOG_NOP
  #define BINLOG_INFO(...)       BINLOG_NOP
  #define BINLOG_WARNING(...)    BINLOG_NOP
  #define BINLOG_ERROR(...)      BINLOG_NOP
  #define BINLOG_CRITICAL(...)   BINLOG_NOP

  #define BINLOG_BEGIN_FLOW(...) BINLOG_NOP
  #define BINLOG_END_FLOW(...)   BINLOG_NOP

  namespace binlog {

  struct EnterFunctionGuard
  {
    EnterFunctionGuard() {}

    template <typename... Args>
    EnterFunctionGuard(const Args&...) {}
  };

  struct LeaveFunctionGuard {};

  struct FunctionGuard
  {
    FunctionGuard() {}

    template <typename... Args>
    FunctionGuard(const Args&...) {}
  };

  } // namespace binlog
#else
  // use the BINLOG macros as usual
#endif

#endif /* MSTK_BINLOGEXAMPLE_NOFOOTER_LOG_H_ */
Attention:  ./examples/02-libraries/Log.H
#ifndef BINLOG_EXAMPLE_LIBS_LOG_H_
#define BINLOG_EXAMPLE_LIBS_LOG_H_

/*
* Define the category symbol.
*
* Each event source and event belongs to a category.
* To see the category, run e.g: ./logfile.log "%C %m"
*
* Each exe/DSO has a default category, by default named META/PROJECT/RELEASE,
* as specified by MSDEMETA, MSDEPROJ, MSDEREL #defines.
*
* To override these defines, specify BINLOG_USER_META, BINLOG_USER_PROJECT
* or BINLOG_USER_RELEASE string constants.
*
* This must precede #include <binlog/Binlog.H> to take effect.
*/
#define BINLOG_USER_RELEASE "example"

//[basics
#include <binlog/Binlog.H>

// Additional project specific convenience log macros might follow
//]

/*
* Do you want application specific convenience log macros?
* Because that's how you get them:
*/
#define LOG_TRACE(...) BINLOG_TRACE(__VA_ARGS__)
#define LOG_DEBUG(...) BINLOG_DEBUG(__VA_ARGS__)
#define LOG_INFO(...) BINLOG_INFO(__VA_ARGS__)
#define LOG_WARN(...) BINLOG_WARNING(__VA_ARGS__)
#define LOG_ERROR(...) BINLOG_ERROR(__VA_ARGS__)
#define LOG_CRIT(...) BINLOG_CRITICAL(__VA_ARGS__)

/*
* If you want additional custom categories, declare them here.
* Add as many as you'd like to, e.g: one for each component in your app.
* Don't forget to call BINLOG_DEFINE_SUBCATEGORY(CUSTOM_CATEGORY) in Log.C
*/
//[custom_category
#define CUSTOM_CATEGORY custom
BINLOG_DECLARE_SUBCATEGORY(CUSTOM_CATEGORY)
//]

/*
* Using a custom category is rather verbose:
*
* BINLOG_CATEGORIZED_INFO(CUSTOM_CATEGORY, "That's long...");
*
* Instead, you can define custom macros, as described above.
* Use the instant copy paste below:
*/
// echo "
#define CUSTOM_TRACE(...)    BINLOG_CATEGORIZED_TRACE   (CUSTOM_CATEGORY, __VA_ARGS__)
#define CUSTOM_DEBUG(...)    BINLOG_CATEGORIZED_DEBUG   (CUSTOM_CATEGORY, __VA_ARGS__)
#define CUSTOM_INFO(...)     BINLOG_CATEGORIZED_INFO    (CUSTOM_CATEGORY, __VA_ARGS__)
#define CUSTOM_WARNING(...)  BINLOG_CATEGORIZED_WARNING (CUSTOM_CATEGORY, __VA_ARGS__)
#define CUSTOM_ERROR(...)    BINLOG_CATEGORIZED_ERROR   (CUSTOM_CATEGORY, __VA_ARGS__)
#define CUSTOM_CRITICAL(...) BINLOG_CATEGORIZED_CRITICAL(CUSTOM_CATEGORY, __VA_ARGS__)
// " | sed s/CUSTOM_/OTHER_/g

#endif /* BINLOG_EXAMPLE_LIBS_LOG_H_ */
Attention:  ./examples/11-watchtower_sink/WatchtowerSink.H
#ifndef BINLOG_EXAMPLE_WATCHTOWERSINK_H_
#define BINLOG_EXAMPLE_WATCHTOWERSINK_H_

#include <string>

#include <binlog/sink/Sink.H>
#include <binlog/sink/PlaintextSink.H>

class WatchtowerSink : public binlog::sink::Sink
{
  typedef binlog::sink::PlaintextSink::Event Event;

public:
  WatchtowerSink(
    const std::string& appIdentity,
    const std::string& instanceName
  );

  // Callback of PlaintextSink

  void processEvent(Event& event);

  // Sink interface

  void operator()(const char* buffer, std::size_t size)
  {
    _sink(buffer, size);
  }

  void afterConsume() {}

private:
  binlog::sink::PlaintextSink _sink;
  const std::string _instanceName;
  std::string _resourceId;
};


#endif /* BINLOG_EXAMPLE_WATCHTOWERSINK_H_ */
Attention:  ./test/unit/Testfile.H
#ifndef BINLOG_TEST_UNIT_TESTFILE_H_
#define BINLOG_TEST_UNIT_TESTFILE_H_

#include <string>

namespace binlog {
namespace test {

class Testfile
{
public:
  Testfile(const std::string& content);
  ~Testfile();

  const std::string& getPath() const;

private:
  std::string _path;
};

} // namespace test
} // namespace binlog

#endif /* BINLOG_TEST_UNIT_TESTFILE_H_ */
Attention:  ./test/integration/modules/HeaderLog.H
#ifndef BINLOG_TEST_INTEGRATION_MODULES_HEADERLOG_H
#define BINLOG_TEST_INTEGRATION_MODULES_HEADERLOG_H

#ifndef BINLOG_VERSION
  #error "Binlog.H must be included prior to this file"
#endif

BINLOG_DECLARE_CATEGORY(header)

#define HEADER_INFO(...) BINLOG_CATEGORIZED_INFO(header, __VA_ARGS__)

#endif // BINLOG_TEST_INTEGRATION_MODULES_HEADERLOG_H
Attention:  ./test/integration/modules/Header.H
#if not defined BINLOG_VERSION
  #define BINLOG_NOP do {} while (0)
  // disable logging
  #define HEADER_INFO(...)       BINLOG_NOP
#else
  // use the BINLOG macros as usual
#endif

void header_hook()
{
  HEADER_INFO("Header hook called");
}
Attention:  ./lib/binlog/make_loggable/BoostPointers.H
#ifndef BINLOG_MAKE_LOGGABLE_BOOSTPOINTERS_H_
#define BINLOG_MAKE_LOGGABLE_BOOSTPOINTERS_H_

#include <boost/smart_ptr.hpp>

#include <binlog/make_loggable/StdPointers.H>

namespace binlog {
namespace detail {

//
// boost::shared_ptr
//

template <typename T>
struct LoggableDescriptor<boost::shared_ptr<T>>
  :public TrivialLoggableDescriptor<
     boost::shared_ptr<T>,
     type_variant
   >
{};

template <typename T>
struct CustomSerializer<boost::shared_ptr<T>>
  :public SmartPtrSerializer<boost::shared_ptr<T>, T>
{};

//
// boost::scoped_ptr
//

template <typename T>
struct LoggableDescriptor<boost::scoped_ptr<T>>
  :public TrivialLoggableDescriptor<
     boost::scoped_ptr<T>,
     type_variant
   >
{};

template <typename T>
struct CustomSerializer<boost::scoped_ptr<T>>
  :public SmartPtrSerializer<boost::scoped_ptr<T>, T>
{};

//
// boost::intrusive_ptr
//

template <typename T>
struct LoggableDescriptor<boost::intrusive_ptr<T>>
  :public TrivialLoggableDescriptor<
     boost::intrusive_ptr<T>,
     type_variant
   >
{};

template <typename T>
struct CustomSerializer<boost::intrusive_ptr<T>>
  :public SmartPtrSerializer<boost::intrusive_ptr<T>, T>
{};

//
// boost::weak_ptr
//

template <typename T>
struct LoggableDescriptor<boost::weak_ptr<T>>
  :public TrivialLoggableDescriptor<
   boost::weak_ptr<T>,
     type_variant
   >
{};

template <typename T>
struct CustomSerializer<boost::weak_ptr<T>>
{
  static std::size_t size(const boost::weak_ptr<T>& wPtr)
  {
    auto tPtr = wPtr.lock();
    return SelectSerializer<T*>::type::size(tPtr.get());
  }

  static void serialize(const boost::weak_ptr<T>& wPtr, Entry& entry)
  {
    auto tPtr = wPtr.lock();
    SelectSerializer<T*>::type::serialize(tPtr.get(), entry);
  }
};

} // namespace detail
} // namespace binlog

#endif /* BINLOG_MAKE_LOGGABLE_BOOSTPOINTERS_H_ */
Attention:  ./lib/binlog/make_loggable/BoostOptional.H
#ifndef BINLOG_MAKE_LOGGABLE_BOOSTOPTIONAL_H_
#define BINLOG_MAKE_LOGGABLE_BOOSTOPTIONAL_H_

#include <boost/optional/optional.hpp>

#include <binlog/make_loggable/StdPointers.H>

namespace binlog {
namespace detail {

//
// boost::optional
//

template <typename T>
struct LoggableDescriptor<boost::optional<T>>
  :public TrivialLoggableDescriptor<
     boost::optional<T>,
     type_variant
   >
{};

template <typename T>
struct CustomSerializer<boost::optional<T>>
{
  static std::size_t size(const boost::optional<T>& tPtr)
  {
    return SelectSerializer<T*>::type::size(tPtr.get_ptr());
  }

  static void serialize(const boost::optional<T>& tPtr, Entry& entry)
  {
    SelectSerializer<T*>::type::serialize(tPtr.get_ptr(), entry);
  }
};

} // namespace detail
} // namespace binlog

#endif /* BINLOG_MAKE_LOGGABLE_BOOSTOPTIONAL_H_ */
Attention:  ./lib/binlog/make_loggable/StdPointers.H
#ifndef BINLOG_MAKE_LOGGABLE_STDPOINTERS_H_
#define BINLOG_MAKE_LOGGABLE_STDPOINTERS_H_

#include <memory>

#include <binlog/detail/Serialize.H>

namespace binlog {
namespace detail {

//
// raw pointer
//

template <typename T>
struct LoggableDescriptor<T*>
  :public TrivialLoggableDescriptor<T*, type_variant>
{};

template <typename T>
struct CustomSerializer<T*>
{
  static std::size_t size(const T* const& pT)
  {
    return sizeof(char) /* type tag */ +
      ((pT)
        ? SelectSerializer<T>::type::size(*pT)
        : 0);
  }

  static void serialize(const T* const& pT, Entry& entry)
  {
    if (pT)
    {
      const char typeTag = LoggableDescriptor_t<T>::type_tag;
      entry.write(typeTag);
      SelectSerializer<T>::type::serialize(*pT, entry);
    }
    else
    {
      const char nullValue = type_null;
      entry.write(nullValue);
    }
  }
};

//
// SmartPtr helper
//

template <typename SmartPtr, typename T>
struct SmartPtrSerializer
{
  static std::size_t size(const SmartPtr& tPtr)
  {
    return SelectSerializer<T*>::type::size(tPtr.get());
  }

  static void serialize(const SmartPtr& tPtr, Entry& entry)
  {
    SelectSerializer<T*>::type::serialize(tPtr.get(), entry);
  }
};

//
// std::shared_ptr
//

template <typename T>
struct LoggableDescriptor<std::shared_ptr<T>>
  :public TrivialLoggableDescriptor<
     std::shared_ptr<T>,
     type_variant
   >
{};

template <typename T>
struct CustomSerializer<std::shared_ptr<T>>
  :public SmartPtrSerializer<std::shared_ptr<T>, T>
{};

//
// std::unique_ptr
//

template <typename T>
struct LoggableDescriptor<std::unique_ptr<T>>
  :public TrivialLoggableDescriptor<
     std::unique_ptr<T>,
     type_variant
   >
{};

template <typename T>
struct CustomSerializer<std::unique_ptr<T>>
  :public SmartPtrSerializer<std::unique_ptr<T>, T>
{};

//
// std::weak_ptr
//

template <typename T>
struct LoggableDescriptor<std::weak_ptr<T>>
  :public TrivialLoggableDescriptor<
     std::weak_ptr<T>,
     type_variant
   >
{};

template <typename T>
struct CustomSerializer<std::weak_ptr<T>>
{
  static std::size_t size(const std::weak_ptr<T>& wPtr)
  {
    auto tPtr = wPtr.lock();
    return SelectSerializer<T*>::type::size(tPtr.get());
  }

  static void serialize(const std::weak_ptr<T>& wPtr, Entry& entry)
  {
    auto tPtr = wPtr.lock();
    SelectSerializer<T*>::type::serialize(tPtr.get(), entry);
  }
};

} // namespace detail
} // namespace binlog

#endif /* BINLOG_MAKE_LOGGABLE_STDPOINTERS_H_ */
Attention:  ./lib/binlog/make_loggable/Enum.H
#ifndef BINLOG_MAKE_LOGGABLE_ENUM_H_
#define BINLOG_MAKE_LOGGABLE_ENUM_H_

#include <boost/preprocessor/stringize.hpp>

#include <binlog/detail/generated/ForeachMacro.H>

namespace binlog {
namespace detail {

#define BINLOG_ENUM_SIZE_TEMPLATE(enumValue, _)                 \
  case enumValue: return sizeof(BOOST_PP_STRINGIZE(enumValue)); \
  /**/

#define BINLOG_ENUM_SERIALIZE_TEMPLATE(enumValue, _) \
  case enumValue:                                    \
    entry.write(BOOST_PP_STRINGIZE(enumValue), sizeof(BOOST_PP_STRINGIZE(enumValue))); \
    break;                                           \
  /**/

/**
* Provide necessary specializations to make the
* given values of the `enumName` enum loggable.
*
* This macro must be used in the top level (root) namespace.
*
* @param enumName the name of the enumeration
* @param ... the possible enum values by name
*/
#define BINLOG_MAKE_ENUM_LOGGABLE(enumName, ...) \
  namespace binlog { namespace detail {          \
                                                 \
  template <>                                    \
  struct LoggableDescriptor<enumName>            \
    :public TrivialLoggableDescriptor<enumName, type_string> \
  {};                                            \
                                                 \
  template <>                                    \
  struct CustomSerializer<enumName>              \
  {                                              \
    static std::size_t size(const enumName& e)   \
    {                                            \
      switch (e)                                 \
      {                                          \
      FOREACH_NO_SEP(BINLOG_ENUM_SIZE_TEMPLATE, ## __VA_ARGS__) \
      default:                                   \
        return sizeof("N/A");                    \
      }                                          \
    }                                            \
                                                 \
    static void serialize(const enumName& e, Entry& entry) \
    {                                            \
      switch (e)                                 \
      {                                          \
      FOREACH_NO_SEP(BINLOG_ENUM_SERIALIZE_TEMPLATE, ## __VA_ARGS__) \
      default:                                   \
        entry.write("N/A", sizeof("N/A"));       \
        break;                                   \
      }                                          \
    }                                            \
  };                                             \
                                                 \
  }} /* namespace binlog::detail */              \
  /**/

} // namespace detail
} // namespace binlog


#endif /* BINLOG_MAKE_LOGGABLE_ENUM_H_ */
Attention:  ./lib/binlog/make_loggable/BoostFilesystem.H
#ifndef BINLOG_MAKE_LOGGABLE_BOOSTFILESYSTEM_H_
#define BINLOG_MAKE_LOGGABLE_BOOSTFILESYSTEM_H_

#include <boost/filesystem/path.hpp>

namespace binlog {
namespace detail {

//
// boost::filesystem
//

template <>
struct LoggableDescriptor<boost::filesystem::path>
  :public TrivialLoggableDescriptor<
     boost::filesystem::path,
     type_string
   >
{};

template <>
struct CustomSerializer<boost::filesystem::path>
{
  static std::size_t size(const boost::filesystem::path& path)
  {
    return SelectSerializer<std::string>::type::size(path.string());
  }

  static void serialize(const boost::filesystem::path& path, Entry& entry)
  {
    SelectSerializer<std::string>::type::serialize(path.string(), entry);
  }
};

} // namespace detail
} // namespace binlog


#endif /* BOOSTFILESYSTEM_H_ */
Attention:  ./lib/binlog/make_loggable/BoostVariant.H
#ifndef BINLOG_MAKE_LOGGABLE_BOOSTVARIANT_H_
#define BINLOG_MAKE_LOGGABLE_BOOSTVARIANT_H_

#include <boost/variant/variant.hpp>

#include <binlog/detail/Serialize.H>

namespace binlog {
namespace detail {

//
// boost::variant
//

template <typename T0, typename... Ts>
struct LoggableDescriptor<boost::variant<T0, Ts...>>
  :public TrivialLoggableDescriptor<
     boost::variant<T0, Ts...>,
     type_variant
   >
{};

template <typename T0, typename... Ts>
struct CustomSerializer<boost::variant<T0, Ts...>>
{
  static std::size_t size(const boost::variant<T0, Ts...>& var)
  {
    return sizeof(type_tag_t) + boost::apply_visitor(ArgumentSize(), var);
  }

  static void serialize(const boost::variant<T0, Ts...>& var, Entry& entry)
  {
    WriteArgument writer(entry);
    boost::apply_visitor(writer, var);
  }

private:
  struct ArgumentSize : public boost::static_visitor<std::size_t>
  {
    template <typename T>
    std::size_t operator()(const T& arg) const
    {
      return SelectSerializer<T>::type::size(arg);
    }
  };

  struct WriteArgument : public boost::static_visitor<void>
  {
    WriteArgument(Entry& entry) : _entry(entry) {}

    template <typename T>
    void operator()(const T& arg) const
    {
      const char typeTag = LoggableDescriptor_t<T>::type_tag;
      _entry.write(typeTag);
      SelectSerializer<T>::type::serialize(arg, _entry);
    }

  private:
    Entry& _entry;
  };
};

} // namespace detail
} // namespace binlog

#endif /* BINLOG_MAKE_LOGGABLE_BOOSTVARIANT_H_ */
Attention:  ./lib/binlog/Configuration.H
#ifndef BINLOG_CONFIGURATION_H_
#define BINLOG_CONFIGURATION_H_

#include <map>
#include <vector>
#include <utility>
#include <string>
#include <mutex>
#include <functional>

#include <binlog/CategoryConfig.H>
#include <binlog/detail/Pattern.H>
#include <binlog/detail/ConfigParser.H>

namespace binlog {

namespace detail {
  class ElfConfig;
} // namespace detail

namespace reader {
namespace entry  {
  class EventSource;
} // namespace entry
} // namespace reader

class Configuration;

/** Get a singleton instance of Configuration */
__attribute__((visibility("default")))
Configuration& getConfiguration();

/**
* Central container of category and ELF configuration
*
* This class consists of several parts:
*  - General: startup initialization (not thread safe)
*  - Category config: registering config and setting config by name (thread safe)
*  - Producer config: controls the behaviour of producer threads (thread safe)
*  - Elf config: registering elf config and tune message specific config (thread safe)
*
* These parts are mixed here to provide a single
* class as config interface to library users.
*
* Config methods are thread safe, because the following events can happen parallel:
*  - Loading a binlog user library, which registers its config
*  - Changing category configuration
*/
class
__attribute__((visibility("default")))
Configuration
{
public:
  // GENERAL

  Configuration() {}
  Configuration(const Configuration&) = delete;
  Configuration& operator=(const Configuration&) = delete;

  // GENERAL CONFIG

  /**
   * Set factory to create custom sinks
   * when `initFromConfig` encounters
   * an unknown sink name.
   *
   * @see ConfigParser::SinkFactory
   */
  void setSinkFactory(const detail::ConfigParser::SinkFactory&);

  /**
   * Set factory to create custom event source predicates
   * when `initFromConfig` encounters
   * an unknown predicate name.
   *
   * @see ConfigParser::PredicateFactory
   */
  void setPredicateFactory(const detail::ConfigParser::PredicateFactory&);

  /**
   * Reads category and sink configs from config file
   *
   * Calling this method implicitly assumes
   * MultiConsumer will be used in the application
   * if the config file contains sink config,
   * but it does not start the consumer.
   *
   * @param configFile path to the config
   * @throws std::runtime_error
   */
  void initFromConfig(const std::string& configFile);

  /**
   * Same as above, but instead of throwing, sets `ec`
   *
   * @returns true, if `ec` is empty.
   */
  bool initFromConfig(const std::string& configFile, std::error_code& ec);

private:
  detail::ConfigParser _configParser;

public:
  // CATEGORY CONFIG

  /**
   * Connects a CategoryConfig to a name.
   *
   * If a matching configuration is set for the name,
   * the given object will be overwritten,
   * otherwise the default configuration
   * will be used.
   *
   * It's possible to register different configs
   * with the same name.
   */
  void registerCategory(
    const std::string& name,
    CategoryConfig& config
  );

  /**
   * Disconnects the category
   *
   * The given category won't be affected by
   * further config changes.
   */
  void unregisterCategory(CategoryConfig& config);

  /**
   * Lists registered categories.
   *
   * @returns A vector of name-config* pairs.
   * Name is not necessarily unique, multiple
   * categories might use the same name.
   */
  std::vector<std::pair<std::string, CategoryConfig*>>
  getCategories() const;

  /**
   * Sets category configurations by name pattern.
   *
   * It's not an error to set the configuration
   * of an unregistered category. The setting
   * will be saved and used later upon
   * registration of any matching name.
   */
  void setCategoryConfig(
    const std::string& pattern,
    const CategoryConfig& config
  );

  /**
   * Sets multiple category configuration by name.
   *
   * Clears previous presets.
   *
   * @see Pattern for name matching
   */
  void setCategoryConfigs(
    std::vector<
      std::pair<std::string, CategoryConfig>
    > presets
  );

private:
  typedef std::vector<std::pair<detail::Pattern, CategoryConfig>> PresetContainer;
  typedef std::map<std::string, std::vector<CategoryConfig*>> ConfigContainer;

  mutable std::mutex _categoryMutex; /**< Protects `_presets` and `_configs` */

  PresetContainer _presets; /**< Config presets for name patterns */
  ConfigContainer _configs; /**< Actual configs used */

  PresetContainer::const_iterator
  getMatchingPreset(const std::string& name) const;

  void resetCategoryConfig();

public:
  // PRODUCER CONFIG

  /**
   * Sets the threshold above no severity threshold should
   * be increased by adaptive measures.
   *
   * Setting this to the lowest severity will effectively
   * disable the adaptive severity changes.
   *
   * @param maxSeverity Exclusive upper bound of severities
   * allowed to change by adaptive measures.
   *
   * @see incrementCategoryThresholds
   */
  void setAdaptiveSeverityCeiling(Severity ceiling);

  /**
   * Get the adaptive severity ceiling. If it equals to trace,
   * adaptive severity controlling is disabled.
   */
  Severity getAdaptiveSeverityCeiling();

  /**
   * Finds the most permissive severity thresholds in _configs
   * and increments them if they are below `_adaptiveSeverityCeiling`.
   *
   * This can be used as a safety measure when running low on memory.
   */
  void incrementCategoryThresholds();

  /**
   * Each log producing thread stores the created entries
   * in a thread local buffer, until the consumer picks them up.
   *
   * The queues get dynamically resized if needed. This setting
   * controls the minimum (and initial) size.
   *
   * @param size New min queue size in bytes
   */
  void setMinQueueSize(std::size_t size);

  /** Trivial getter, @see setMinQueueSize */
  std::size_t getMinQueueSize() const;

private:

  Severity _adaptiveSeverityCeiling = binlog::none; /**< @see incrementCategoryThresholds */

public:
  // ELF CONFIG
  typedef std::function<bool(const reader::entry::EventSource&)> EventSourcePredicate;

  void registerElfConfig(detail::ElfConfig* elfConfig);
  void unregisterElfConfig(detail::ElfConfig* elfConfig);

  /**
   * Enable/disable matching EventSources
   *
   * @param fileEnd Match sources in files which paths end with this string
   * @param line Match sources on `line`. If `line == 0`, it's ignored
   * @param enable Enable matching sources if true, disable them otherwise
   */
  bool toggleSource   (const std::string& fileEnd, unsigned line, bool enable);

  /**
   * Enable/disable matching EventSources
   *
   * @param predicate Evaluates given sources, returns true on match
   * @param enable Enable matching sources if true, disable them otherwise
   */
  bool toggleSource   (EventSourcePredicate predicate, bool enable);

private:
  bool changeSources(
    EventSourcePredicate& predicate,
    std::function<void(detail::ElfConfig*, std::size_t sourceIndex)> action
  );

  mutable std::mutex _elfMutex; /**< Protects `_elfConfigs` */
  std::vector<detail::ElfConfig*> _elfConfigs; /**< registered elf configurations */
};

} // namespace binlog

#endif /* BINLOG_CONFIGURATION_H_ */
Attention:  ./lib/binlog/CategoryConfig.H
#ifndef BINLOG_CATEGORYCONFIG_H_
#define BINLOG_CATEGORYCONFIG_H_

#include <binlog/Severity.H>

namespace binlog {

/**
* Configuration of a category
*
* Instances of this struct are usually
* global variables defined by the
* `BINLOG_DEFINE_CATEGORY` macro.
*/
struct
__attribute__((visibility("default")))
CategoryConfig
{
  CategoryConfig();
  CategoryConfig(const Severity& minSeverityArg);

  /**
   * Severity threshold
   *
   * Event sources of severity below
   * this threshold will not emit any events.
   */
  Severity minSeverity = debug;
};

namespace detail {

/**
* Registers the given category config
* in the configuration upon construction,
* unregisters it when destroyed.
*/
class
__attribute__((visibility("default")))
CategoryConfigGuard
{
public:
  CategoryConfigGuard(const std::string& name, CategoryConfig& config);
  ~CategoryConfigGuard();

private:
  CategoryConfig* _pConfig;
};

} // namespace detail

} // namespace binlog

#endif /* BINLOG_CATEGORYCONFIG_H_ */
Attention:  ./lib/binlog/Severity.H
#ifndef BINLOG_SEVERITY_H_
#define BINLOG_SEVERITY_H_

#include <string>

namespace binlog {

#define BINLOG_SEVERITY_UNKNOWN    1
#define BINLOG_SEVERITY_TRACE     (1 << 5)
#define BINLOG_SEVERITY_DEBUG     (1 << 6)
#define BINLOG_SEVERITY_INFO      (1 << 7)
#define BINLOG_SEVERITY_WARNING   (1 << 8)
#define BINLOG_SEVERITY_ERROR     (1 << 9)
#define BINLOG_SEVERITY_CRITICAL  (1 << 10)
#define BINLOG_SEVERITY_CONTROL   (1 << 11)
#define BINLOG_SEVERITY_NONE      (1 << 12)

enum Severity : uint16_t
{
  unknown  = BINLOG_SEVERITY_UNKNOWN,
  trace    = BINLOG_SEVERITY_TRACE,
  debug    = BINLOG_SEVERITY_DEBUG,
  info     = BINLOG_SEVERITY_INFO,
  warning  = BINLOG_SEVERITY_WARNING,
  error    = BINLOG_SEVERITY_ERROR,
  critical = BINLOG_SEVERITY_CRITICAL,
  control  = BINLOG_SEVERITY_CONTROL,
  none     = BINLOG_SEVERITY_NONE,
};

__attribute__((visibility("default")))
const char* severityToString(const Severity severity);

__attribute__((visibility("default")))
Severity stringToSeverity(const std::string& severity);

namespace detail {

Severity nextSeverity(const Severity severity);

} // namespace detail

} // namespace binlog

#endif /* BINLOG_SEVERITY_H_ */
Attention:  ./lib/binlog/Transform.H
#ifndef BINLOG_TRANSFORM_H_
#define BINLOG_TRANSFORM_H_

#include <functional>

#include <binlog/detail/Arguments.H>

namespace binlog {

namespace detail {

template <
  typename Source,
  typename Target,
  bool IsContainer = detail::is_container<Source>::value
> 
class Transformation
{
  template <typename T, bool SelectT>
  struct t_or_value_type;

  template <typename T>
  struct t_or_value_type<T, true>
  {
    typedef T type;
  };

  template <typename T>
  struct t_or_value_type<T, false>
  {
    typedef typename T::value_type type;
  };

  typedef typename t_or_value_type<Source, !IsContainer>::type TrafoInput;

public:
  typedef typename std::remove_reference<Target>::type value_type;
  typedef std::function<Target(const TrafoInput&)> Trafo;

  Transformation(const Source& source, Trafo trafo)
    :source(source),
     transform(std::move(trafo))
  {}

  const Source& source;
  Trafo transform;
};

template <typename Source, typename Target>
struct LoggableDescriptor<Transformation<Source, Target, false>> :
  public TrivialLoggableDescriptor<
    Transformation<Source, Target, false>,
    LoggableDescriptor<typename Transformation<Source, Target, false>::value_type>::type_tag
  >
{};

template <typename Source, typename Target>
struct LoggableDescriptor<Transformation<Source, Target, true>> :
  public TrivialLoggableDescriptor<
    Transformation<Source, Target, true>,
    type_array
  >
{};

template <typename>
class is_transformation : public std::false_type {};

template <typename Source, typename Target, bool IsContainer>
class is_transformation<Transformation<Source, Target, IsContainer>>
  : public std::true_type {};

} // namespace detail

// binlog::transform for non-containers

template <
  typename Source,
  typename Func,
  typename Target = decltype(
    std::declval<Func>()(std::declval<const Source&>())
  ),
  typename std::enable_if<
    ! detail::is_container<Source>::value
  ,int>::type = 0
> 
detail::Transformation<Source, Target>
transform(const Source& source, Func func)
{
  return detail::Transformation<Source, Target>(source, func);
}

// binlog::transform for containers

template <
  typename Source,
  typename Func,
  typename Target = decltype(
    std::declval<Func>()(std::declval<const typename Source::value_type&>())
  ),
  typename std::enable_if<
    detail::is_container<Source>::value
  ,int>::type = 0
> 
detail::Transformation<Source, Target>
transform(const Source& source, Func func)
{
  return detail::Transformation<Source, Target>(source, func);
}

} // namespace binlog

#endif /* BINLOG_TRANSFORM_H_ */
Attention:  ./lib/binlog/reader/TailEventStream.H
#ifndef BINLOG_READER_TAILEVENTSTREAM_H_
#define BINLOG_READER_TAILEVENTSTREAM_H_

#include <vector>

#include <binlog/reader/EventStream.H>

namespace binlog {
namespace reader {

class
__attribute__((visibility("default")))
TailEventStream : public EventStream
{
public:
  TailEventStream(detail::Consumable<Entry>& input, std::size_t maxTailSize);
  TailEventStream(TailEventStream&&) = default;

protected:
  void processThreadActivity(ThreadActivity& activity, SinkT& sink, std::error_code& ec);
  void endOfInput(SinkT& sink);

private:
  const std::size_t _maxTailSize;
  std::vector<ThreadActivity> _tail;
  std::size_t _nextTailIndex = 0;
  bool _buffering = true;
};

} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_TAILEVENTSTREAM_H_ */
Attention:  ./lib/binlog/reader/SortedEventStream.H
#ifndef BINLOG_READER_SORTEDEVENTSTREAM_H_
#define BINLOG_READER_SORTEDEVENTSTREAM_H_

#include <vector>

#include <binlog/reader/detail/Consumable.H>
#include <binlog/reader/entry/Event.H>

namespace binlog {
namespace reader {

using entry::Event;

class SortedEventStream : public detail::Consumable<Event>
{
  typedef typename detail::Consumable<Event>::Callback SinkT;

public:
  SortedEventStream(detail::Consumable<Event>& input);

  using detail::Consumable<Event>::consume;
  void consume(SinkT sink, ErrorHandler handleError);

private:
  detail::Consumable<Event>& _input;
  std::vector<Event> _buffer;
};

} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_SORTEDEVENTSTREAM_H_ */
Attention:  ./lib/binlog/reader/entry/HostProp.H
#ifndef BINLOG_READER_ENTRY_HOSTPROP_H_
#define BINLOG_READER_ENTRY_HOSTPROP_H_

#include <string>

#include <binlog/detail/Error.H>
#include <binlog/reader/detail/Buffer.H>

namespace binlog {
namespace reader {
namespace entry  {

class
__attribute__((visibility("default")))
HostProp
{
public:
  HostProp() {}
  HostProp(detail::ReadBuffer input, std::error_code& ec);

  template <typename Archive>
  void serialize(Archive& ar, std::error_code& ec)
  {
    using namespace binlog::detail::error;

    detail::serialize(ar, _hostname, ec, Error::no_hostname);
  }

  const std::string& hostName() const { return _hostname; }

private:
  std::string _hostname;
};

} // namespace entry
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_ENTRY_HOSTPROP_H_ */
Attention:  ./lib/binlog/reader/entry/FlowInstance.H
#ifndef BINLOG_READER_ENTRY_FLOWINSTANCE_H_
#define BINLOG_READER_ENTRY_FLOWINSTANCE_H_

#include <string>

#include <binlog/reader/entry/Event.H>

namespace binlog {
namespace reader {
namespace entry  {

class FlowInstance
{
public:
  FlowInstance(
    const std::string& id,
    Event firstEvent
  )
    :_id(id),
     _firstEvent(std::move(firstEvent))
  {}

  const std::string& id()   const { return _id; }
  const Event& firstEvent() const { return _firstEvent; }

private:
  std::string _id;
  Event _firstEvent;
};

} // namespace entry
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_ENTRY_FLOWINSTANCE_H_ */
Attention:  ./lib/binlog/reader/entry/ThreadProp.H
#ifndef BINLOG_READER_ENTRY_THREADPROP_H_
#define BINLOG_READER_ENTRY_THREADPROP_H_

#include <string>

#include <binlog/detail/ThreadContext.H>
#include <binlog/detail/Error.H>

namespace binlog {
namespace reader {

namespace detail {
  class ReadBuffer;
} // namespace detail

namespace entry  {

class
__attribute__((visibility("default")))
ThreadProp
{
public:
  typedef binlog::detail::ThreadContext::LWP LWP;

  ThreadProp();
  ThreadProp(detail::ReadBuffer input, std::error_code& ec);

  template <typename Archive>
  void serialize(Archive& ar, std::error_code& ec)
  {
    using namespace binlog::detail::error;

    detail::serialize(ar, _lwp, ec, Error::no_lwp);
    detail::serialize(ar, _threadName, ec, Error::no_thread_name);
  }

  LWP lwp() const { return _lwp; }
  const std::string& name() const { return _threadName; }

private:
  LWP _lwp;
  std::string _threadName;
};

} // namespace entry
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_ENTRY_THREADPROP_H_ */
Attention:  ./lib/binlog/reader/entry/Entry.H
#ifndef BINLOG_READER_ENTRY_ENTRY_H_
#define BINLOG_READER_ENTRY_ENTRY_H_

#include <memory>

#include <binlog/detail/EntryDefs.H> // entry_size_t, tag_t
#include <binlog/detail/Error.H>
#include <binlog/reader/detail/Buffer.H>

namespace binlog {
namespace reader {
namespace entry  {

class Entry
{
public:
  typedef binlog::detail::EntryDefs::entry_size_t entry_size_t;
  typedef binlog::detail::EntryDefs::tag_t tag_t;

  Entry() = default;
  Entry(const Entry&) = delete;
  Entry(Entry&&) = default;
  Entry& operator=(const Entry&) = delete;
  Entry& operator=(Entry&&) = default;

  template <typename Stream>
  Entry(Stream& input, std::error_code& ec)
  {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"

    using binlog::detail::checkTrue;
    using binlog::detail::Error;

    entry_size_t size;
    if (! checkTrue(input.read(size), ec, Error::end_of_stream)) { return; }

    const bool validSize = size > sizeof(size);
    if (! validSize)
    {
      using namespace binlog::detail::error;
      setError(ec, Error::invalid_entry_size) << size;
      return;
    }

    checkTrue(input.read(_tag), ec, Error::no_tag_found);

    std::size_t payloadSize = size - sizeof(size) - sizeof(_tag);
    checkTrue(input.read(_buffer, _reader, payloadSize), ec, Error::payload_too_short);

    #pragma GCC diagnostic pop
  }

  tag_t tag() const { return _tag; }

  /**
   * return by value is intended
   */
  detail::ReadBuffer payload() const
  {
    return _reader;
  }

  detail::ReadBuffer& payloadRef()
  {
    return _reader;
  }

protected:
  tag_t _tag;
  detail::Buffer _buffer;
  detail::ReadBuffer _reader;
};

} // namespace entry
} // namespace reader
} // namespace binlog


#endif /* BINLOG_READER_ENTRY_ENTRY_H_ */
Attention:  ./lib/binlog/reader/entry/StructDefinition.H
#ifndef BINLOG_READER_ENTRY_STRUCTDEFINITION_H_
#define BINLOG_READER_ENTRY_STRUCTDEFINITION_H_

#include <string>
#include <vector>

#include <binlog/detail/Error.H>
#include <binlog/reader/detail/Buffer.H>

namespace binlog {
namespace reader {

namespace detail {

class DeserializedStruct;
class ArgumentParseContext;

} // namespace detail

namespace entry  {

class
__attribute__((visibility("default")))
StructDefinition
{
public:
  StructDefinition(detail::ReadBuffer reader, std::error_code& ec);
  StructDefinition(uint64_t id, detail::ReadBuffer& reader, std::error_code& ec);

  uint64_t id() const { return _id; }
  const std::string& name() const { return _name; }

  detail::DeserializedStruct instantiate(
    const detail::ArgumentParseContext& apc,
    detail::ReadBuffer& reader
  ) const;

  template <typename Archive>
  void serialize(Archive& ar, std::error_code& ec)
  {
    using namespace binlog::detail::error;

    detail::serialize(ar, _id,     ec, Error::no_sdef_id);
    detail::serialize(ar, _name,   ec, Error::no_sdef_name);
    detail::serialize(ar, _fields, ec, Error::no_sdef_fields);
  }

private:
  struct Field
  {
    std::string _name;
    char _typeTag;

    template <typename Archive>
    void serialize(Archive& ar, std::error_code& ec)
    {
      using namespace binlog::detail::error;

      detail::serialize(ar, _name,    ec, Error::no_sdef_field_name);
      detail::serialize(ar, _typeTag, ec, Error::no_sdef_field_type);
    }
  };

  uint64_t _id;
  std::string _name;
  std::vector<Field> _fields;
};

} // namespace entry
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_ENTRY_STRUCTDEFINITION_H_ */
Attention:  ./lib/binlog/reader/entry/Event.H
#ifndef BINLOG_READER_ENTRY_EVENT_H_
#define BINLOG_READER_ENTRY_EVENT_H_

#include <string>
#include <vector>

#include <binlog/reader/entry/ThreadActivity.H>
#include <binlog/reader/detail/Argument.H>

namespace binlog {
namespace reader {

namespace detail {

class ArgumentParseContext;

} // namespace detail

namespace entry  {

class EventSource;

class
__attribute__((visibility("default")))
Event : private ThreadActivity
{
public:
  using ThreadActivity::tsc_t;
  using ThreadActivity::Clock;
  using ThreadActivity::DateTime;
  using ThreadActivity::ThreadId;

  Event() = default;

  Event(
    const EventSource& source,
    const detail::ArgumentParseContext& apc,
    ThreadActivity activity
  );

  // Entry getter

  using ThreadActivity::tag;

  // ThreadActivity getters

  using ThreadActivity::tsc;
  using ThreadActivity::dateTime;
  using ThreadActivity::threadId;
  using ThreadActivity::threadName;
  using ThreadActivity::hostName;

  // own getters

  const EventSource& source() const { return *_source; }
  const std::vector<detail::Argument>& arguments() const { return _arguments; }

  // derived field getters

  /** writeMessage(event, stream) below is a bit faster */
  std::string message() const;

  // serialization

  using ThreadActivity::serialize;

private:
  const EventSource* _source = nullptr; /**< Source of the event */
  std::vector<detail::Argument> _arguments; /**< Arguments of the event, matching the format string placeholders */
};

void writeMessage(const Event& event, std::ostream& out);

} // namespace entry
} // namespace reader
} // namespace binlog


#endif /* BINLOG_READER_ENTRY_EVENT_H_ */
Attention:  ./lib/binlog/reader/entry/ThreadActivity.H
#ifndef BINLOG_READER_ENTRY_THREADACTIVITY_H_
#define BINLOG_READER_ENTRY_THREADACTIVITY_H_

#include <chrono>
#include <system_error>

#include <binlog/detail/EntryDefs.H> // tsc_t

#include <binlog/reader/entry/Entry.H>
#include <binlog/reader/detail/Buffer.H>
#include <binlog/reader/entry/TscSynchronization.H>
#include <binlog/reader/entry/ThreadProp.H>
#include <binlog/reader/entry/HostProp.H>

namespace binlog {
namespace reader {
namespace entry  {

class
__attribute__((visibility("default")))
ThreadActivity : private Entry
{
public:
  typedef binlog::detail::EntryDefs::tsc_t tsc_t;
  typedef std::chrono::high_resolution_clock Clock;
  typedef Clock::time_point DateTime;
  typedef ThreadProp::LWP ThreadId;

  ThreadActivity() = default;

  ThreadActivity(
    Entry base,
    const TscSynchronization& tscSync,
    const ThreadProp& threadProp,
    const HostProp& hostProp,
    std::error_code& ec
  );

  // Entry getters

  using Entry::tag;
  using Entry::payload;
  using Entry::payloadRef;

  // own getters

  tsc_t tsc() const { return _tsc; }
  DateTime dateTime() const { return _dateTime; }
  ThreadId threadId() const { return _threadProp.lwp(); }
  const std::string& threadName() const { return _threadProp.name(); }
  const std::string& hostName() const { return _hostProp.hostName(); }

  // serialization

  void serialize(detail::WriteBuffer& writer);

protected:
  tsc_t _tsc;
  DateTime _dateTime;
  ThreadProp _threadProp;
  HostProp _hostProp;
};

} // namespace entry
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_ENTRY_THREADACTIVITY_H_ */
Attention:  ./lib/binlog/reader/entry/TscSynchronization.H
#ifndef BINLOG_READER_ENTRY_TSCSYNCHRONIZATION_H_
#define BINLOG_READER_ENTRY_TSCSYNCHRONIZATION_H_

#include <chrono>

#include <binlog/detail/Error.H>
#include <binlog/reader/detail/Buffer.H>

namespace binlog {
namespace reader {
namespace entry  {

/**
* Map TSC value to wall clock time time point
*
* Events do not have absolute timestamp but an
* actual TSC value instead. TSC depends on the
* time of the machine RESET and CPU frequency.
*
* To make offline TSC-to-time conversion possible,
* the online producer emits a tsc synchronization
* entry periodically, which provides a (surprise)
* synchronization point.
*/
class
__attribute__((visibility("default")))
TscSynchronization
{
  typedef std::chrono::high_resolution_clock clock;

public:
  typedef clock::time_point time_point;

  /** Noop constructor, no empty state is provided */
  TscSynchronization() = default;

  /**
   * Extracts an `TscSynchronization` from the
   * given `ReadBuffer` `input`.
   */
  TscSynchronization(detail::ReadBuffer input, std::error_code& ec);

  /**
   * Converts `tsc` to absolute wall clock time.
   *
   * Assumes `tsc` is from the same machine as `this`
   * and both are created after the same RESET.
   *
   * Assumes TSC runs at a steady rate (constant_tsc)
   */
  time_point tscToTime(const uint64_t tsc) const;

  /**
   * Converts `tsc` to a time zone specific wall clock time.
   *
   * Assumes what tscToTime assumes.
   */
  time_point tscToLocaltime(const uint64_t tsc) const;

  /** (De)serializes *this using the given archive */
  template <typename Archive>
  void serialize(Archive& ar, std::error_code& ec)
  {
    using namespace binlog::detail::error;

    detail::serialize(ar, _tsc,      ec, Error::no_tsc);
    detail::serialize(ar, _time,     ec, Error::no_time);
    detail::serialize(ar, _tzOffset, ec, Error::no_timezone);
    detail::serialize(ar, _cpufreq,  ec, Error::no_cpu_freq);
  }

private:
  uint64_t _tsc;    /**< TSC value of CPU at `_time` */
  time_point _time; /**< Wall clock time when TSC was roughly = `_tsc` */
  int64_t _tzOffset;/**< Time zone offset, seconds east of UTC */
  int _cpufreq;     /**< TSC frequency in kHz of CPU */
};

} // namespace entry
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_ENTRY_TSCSYNCHRONIZATION_H_ */
Attention:  ./lib/binlog/reader/entry/EventSource.H
#ifndef BINLOG_READER_ENTRY_EVENTSOURCE_H_
#define BINLOG_READER_ENTRY_EVENTSOURCE_H_

#include <string>
#include <vector>

#include <binlog/Severity.H>

#include <binlog/detail/Error.H>

#include <binlog/reader/entry/Entry.H> // tag_t
#include <binlog/reader/detail/FormatString.H>
#include <binlog/reader/detail/SourceLocation.H>
#include <binlog/reader/detail/Argument.H>

namespace binlog {
namespace reader {

namespace detail {
  class ReadBuffer;
} // namespace detail

namespace entry  {

/**
* Represents a BINLOG_* log call which emits log events.
*
* Each `Event` is connected to an `EventSource`
* to avoid data duplication.
*/
class
__attribute__((visibility("default")))
EventSource
{
public:
  typedef binlog::reader::entry::Entry::tag_t tag_t;

  /** Constructor */
  EventSource(
    tag_t sourceId,
    void* instructionPointer,
    const std::string& category,
    Severity severity,
    const std::string& formatString,
    const std::string& typeCodes,
    const detail::SourceLocation& location
  );

  /**
   * Extracts an `EventSource` from the
   * given `ReadBuffer` `buffer`.
   */
  EventSource(detail::ReadBuffer buffer, std::error_code& ec);

  void substituePlaceholders(
    const std::vector<detail::Argument>& arguments,
    std::ostream& out
  ) const;

  bool isFlowBegin() const;
  bool isFlowEnd() const;

  /**
   * Extracts whole statement starting at `_line`.
   *
   * Original source code must be accessible or
   * error message will be returned.
   *
   * This feature is used by Logchecker
   * which prints colored abuses of log macros
   * collected by this method.
   */
  const std::string& programCode();

  /**
   * Strips the template arguments and function
   * arguments from the string returned by `function()`
   *
   * writeShortFunction(source, stream) below is a bit faster
   */
  std::string shortFunction() const;

  tag_t sourceId() const
  {
    return _sourceId;
  }

  const std::string& category() const
  {
    return _category;
  }

  const std::string& file() const
  {
    return _file;
  }

  const std::string& formatString() const
  {
    return _formatString;
  }

  const std::string& function() const
  {
    return _function;
  }

  void* instructionPointer() const
  {
    return _instructionPointer;
  }

  unsigned line() const
  {
    return _line;
  }

  const detail::ParsedFormat& parsedFormatString() const
  {
    return _parsedFormatString;
  }

  binlog::Severity severity() const
  {
    return _severity;
  }

  const std::string& typeCodes() const
  {
    return _typeCodes;
  }

  /**
   * (De)serializes *this using the given archive
   */
  template <typename Archive>
  void serialize(Archive& ar, std::error_code& ec)
  {
    using namespace binlog::detail::error;

    detail::serialize(ar, _sourceId, ec, Error::no_source_id);
    detail::serialize(ar, _instructionPointer, ec, Error::no_instruction_pointer);
    detail::serialize(ar, _category, ec, Error::no_category);
    detail::serialize(ar, _severity, ec, Error::no_severity);
    detail::serialize(ar, _formatString, ec, Error::no_format_string);
    detail::serialize(ar, _typeCodes, ec, Error::no_type_codes);
    detail::serialize(ar, _function, ec, Error::no_function);
    detail::serialize(ar, _file, ec, Error::no_file);
    detail::serialize(ar, _line, ec, Error::no_line);
    detail::serialize(ar, _programCode, ec, Error::no_program_code);
  }

private:
  /**
   * ASCII art explanation of members:
   *
   * #define BINLOG_CATEGORY_NAME ... //< _category
   *
   * int32_t a = 23;
   *
   *               ,~~~~~~~, _severity
   * [IP] -> BINLOG_WARNING("FormatStr: {0}", arg);
   * '~~' _instructionPointer on calling
   *          _formatString '~~~~~~~~~~~~~'
   *
   * _sourceId: ELF dynamic load address + id assigned by BINLOG_MESSAGE_ID
   * _typeCodes: 'binlog::detail::type_32'
   * _parsedFormatString: "FormatStr: 23"
   *
   * _function (_file:_line): func(int, double) (/path/to/file:123)
   * _programCode: BINLOG_WARNING("FormatStr: {0}", arg);
   */

  tag_t _sourceId;
  void* _instructionPointer;
  std::string _category;

  std::string _formatString;
  std::string _typeCodes; /**< Array of type code chars */
  detail::ParsedFormat _parsedFormatString;

  std::string _function;
  std::string _file;
  std::string _programCode;
  unsigned _line;
  binlog::Severity _severity;
};

void writeShortFunction(const EventSource& es, std::ostream& out);

} // namespace entry
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_ENTRY_EVENTSOURCE_H_ */
Attention:  ./lib/binlog/reader/FlowEventStream.H
#ifndef BINLOG_READER_FLOWEVENTSTREAM_H_
#define BINLOG_READER_FLOWEVENTSTREAM_H_

#include <string>
#include <map>
#include <set>

#include <binlog/reader/EventStream.H>
#include <binlog/reader/entry/EventSource.H>

namespace binlog {
namespace reader {

class FlowEventStream : public EventStream
{
  typedef entry::EventSource::tag_t tag_t;

public:
  FlowEventStream(
    detail::Consumable<Entry>& input,
    const std::string& flowName,
    const std::string& flowId
  );

protected:
  void processEventSource(EventSource& eventSource, SinkT& sink);
  void processThreadActivity(ThreadActivity& activity, SinkT& sink, std::error_code& ec);

private:
  void sinkEvent(ThreadActivity& activity, SinkT& sink, std::error_code& ec);

  std::string _flowName;
  std::string _flowId;
  std::map<tag_t, std::size_t> _flowSources;
  std::set<ThreadActivity::ThreadId> _inFlow;
};

} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_FLOWEVENTSTREAM_H_ */
Attention:  ./lib/binlog/reader/EntryProcessor.H
#ifndef BINLOG_READER_ENTRYPROCESSOR_H_
#define BINLOG_READER_ENTRYPROCESSOR_H_

#include <map>
#include <set>
#include <vector>

#include <binlog/detail/EntryDefs.H> // ENTRY_TAG
#include <binlog/detail/Pattern.H>
#include <binlog/detail/Error.H>
#include <binlog/reader/detail/Consumable.H>
#include <binlog/reader/detail/ArgumentParseContext.H>

#include <binlog/reader/entry/TscSynchronization.H>
#include <binlog/reader/entry/EventSource.H>
#include <binlog/reader/entry/ThreadActivity.H>
#include <binlog/reader/entry/StructDefinition.H>
#include <binlog/reader/entry/ThreadProp.H>
#include <binlog/reader/entry/HostProp.H>

namespace binlog {
namespace reader {

namespace entry {
  class Entry;
} // namespace entry

using entry::Entry;
using entry::TscSynchronization;
using entry::EventSource;
using entry::ThreadActivity;
using entry::StructDefinition;
using entry::ThreadProp;
using entry::HostProp;
using binlog::detail::EntryTag::EntryTag;

template <typename Output>
class EntryProcessor : public detail::Consumable<Output>
{
protected:
  typedef typename detail::Consumable<Output>::Callback SinkT;
  typedef typename detail::Consumable<Output>::ErrorHandler ErrorHandler;

public:
  EntryProcessor(detail::Consumable<Entry>& input);
  EntryProcessor(EntryProcessor&&) = default;
  virtual ~EntryProcessor() {}

  using detail::Consumable<Output>::consume;
  void consume(SinkT sink, ErrorHandler handleError);

protected:
  virtual void processTSCSynchronization(TscSynchronization& tscSync, SinkT& sink);
  virtual void processEventSource(EventSource& eventSource, SinkT& sink);
  virtual void processStructDef(StructDefinition& structDef, SinkT& sink);
  virtual void processThreadProp(ThreadProp& threadProp, SinkT& sink);
  virtual void processHostProp(HostProp& hostProp, SinkT& sink);
  virtual void processThreadActivity(ThreadActivity& activity, SinkT& sink, std::error_code& ec) = 0;

  virtual bool validEntryTag(Entry::tag_t tag) const;
  virtual void endOfInput(SinkT& /*sink*/) {}

  std::map<EventSource::tag_t, EventSource> _sources;
  TscSynchronization _latestTscSync;
  ThreadProp _latestThreadProp;
  HostProp _latestHostProp;
  detail::ArgumentParseContext _argParseContext;

private:
  void processEntry(Entry& entry, SinkT& sink, ErrorHandler handleError);

  detail::Consumable<Entry>& _input;
};

template <typename Output>
EntryProcessor<Output>::EntryProcessor(detail::Consumable<Entry>& input)
  :_input(input)
{}

template <typename Output>
void EntryProcessor<Output>::consume(SinkT sink, ErrorHandler handleError)
{
  _input.consume(
    [&](Entry& entry) { processEntry(entry, sink, handleError); },
    handleError
  );

  endOfInput(sink);
}

template <typename Output>
void EntryProcessor<Output>::processEntry(Entry& entry, SinkT& sink, ErrorHandler handleError)
{
  std::error_code ec;
  auto tag = entry.tag();
  switch (tag)
  {
  case EntryTag::tscSync:
  {
    TscSynchronization tscSync(entry.payload(), ec);
    if (ec) { break; }
    processTSCSynchronization(tscSync, sink);
    break;
  }
  case EntryTag::eventSource:
  {
    EventSource eventSource(entry.payload(), ec);
    if (ec) { break; }
    processEventSource(eventSource, sink);
    break;
  }
  case EntryTag::structDef:
  {
    StructDefinition structDef(entry.payload(), ec);
    if (ec) { break; }
    processStructDef(structDef, sink);
    break;
  }
  case EntryTag::threadProp:
  {
    ThreadProp threadProp(entry.payload(), ec);
    if (ec) { break; }
    processThreadProp(threadProp, sink);
    break;
  }
  case EntryTag::hostProp:
  {
    HostProp hostProp(entry.payload(), ec);
    if (ec) { break; }
    processHostProp(hostProp, sink);
    break;
  }
  case EntryTag::deprecated_a: break;
  case EntryTag::deprecated_b: break;
  case EntryTag::deprecated_c: break;
  default:
  {
    if (validEntryTag(tag))
    {
      ThreadActivity activity(
        std::move(entry),
        _latestTscSync,
        _latestThreadProp,
        _latestHostProp,
        ec
      );
      if (ec) { break; }
      processThreadActivity(activity, sink, ec);
    }
    else
    {
      using namespace binlog::detail::error;
      setError(ec, Error::invalid_entry_tag) << tag;
    }
    break;
  }
  } // switch (tag)

  if (ec) { handleError(ec); }
}

template <typename Output>
void EntryProcessor<Output>::processTSCSynchronization(TscSynchronization& tscSync, SinkT&)
{
  _latestTscSync = tscSync;
}

template <typename Output>
void EntryProcessor<Output>::processEventSource(EventSource& source, SinkT&)
{
  _sources.emplace(source.sourceId(), std::move(source));
}

template <typename Output>
void EntryProcessor<Output>::processStructDef(StructDefinition& structDef, SinkT&)
{
  _argParseContext.addStructDefinition(std::move(structDef));
}

template <typename Output>
void EntryProcessor<Output>::processThreadProp(ThreadProp& threadProp, SinkT&)
{
  _latestThreadProp = std::move(threadProp);
}

template <typename Output>
void EntryProcessor<Output>::processHostProp(HostProp& hostProp, SinkT&)
{
  _latestHostProp = std::move(hostProp);
}

template <typename Output>
bool EntryProcessor<Output>::validEntryTag(Entry::tag_t tag) const
{
  return _sources.count(tag) != 0;
}

} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_ENTRYPROCESSOR_H_ */
Attention:  ./lib/binlog/reader/EntryStream.H
#ifndef BINLOG_READER_ENTRYSTREAM_H_
#define BINLOG_READER_ENTRYSTREAM_H_

#include <binlog/reader/entry/Entry.H>
#include <binlog/reader/detail/Consumable.H>
#include <binlog/reader/detail/InputStream.H>

namespace binlog {
namespace reader {

using entry::Entry;

class
__attribute__((visibility("default")))
EntryStream : public detail::Consumable<Entry>
{
public:
  EntryStream(detail::InputStream& input);

  using detail::Consumable<Entry>::consume;
  void consume(Callback consumer, ErrorHandler handleError);

  void replaceInput(detail::InputStream& input);

private:
  detail::InputStream* _input;
};

} // namespace reader
} // namespace binlog


#endif /* BINLOG_READER_ENTRYSTREAM_H_ */
Attention:  ./lib/binlog/reader/EventSourceStream.H
#ifndef BINLOG_READER_EVENTSOURCESTREAM_H_
#define BINLOG_READER_EVENTSOURCESTREAM_H_

#include <binlog/reader/detail/Consumable.H>
#include <binlog/reader/entry/EventSource.H>
#include <binlog/detail/Elf.H>

namespace binlog {
namespace reader {

class
__attribute__((visibility("default")))
EventSourceStream : public detail::Consumable<entry::EventSource>
{
  typedef detail::Consumable<entry::EventSource>::Callback SinkT;

public:
  EventSourceStream(const binlog::detail::Elf& elf);

  using detail::Consumable<entry::EventSource>::consume;
  void consume(SinkT sink, ErrorHandler handleError);

private:
  const binlog::detail::Elf& _elf;
};

} // namespace reader
} // namespace binlog


#endif /* BINLOG_READER_EVENTSOURCESTREAM_H_ */
Attention:  ./lib/binlog/reader/EventStream.H
#ifndef BINLOG_READER_EVENTSTREAM_H_
#define BINLOG_READER_EVENTSTREAM_H_

#include <map>
#include <system_error>

#include <binlog/reader/entry/Entry.H>
#include <binlog/reader/entry/Event.H>
#include <binlog/reader/EntryProcessor.H>
#include <binlog/reader/detail/Consumable.H>

namespace binlog {
namespace reader {

namespace entry {
  class ThreadActivity;
} // namespace entry

using entry::Entry;
using entry::Event;
using entry::ThreadActivity;

class
__attribute__((visibility("default")))
EventStream : public EntryProcessor<Event>
{
  typedef EntryProcessor<Event> EntryProcessorT;
  typedef entry::Entry::tag_t tag_t;

public:
  EventStream(detail::Consumable<Entry>& input);
  EventStream(EventStream&&) = default;

protected:
  void processThreadActivity(ThreadActivity& activity, SinkT& sink, std::error_code& ec);

  Event eventFromActivity(ThreadActivity& activity, std::error_code& ec);
};

} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_EVENTSTREAM_H_ */
Attention:  ./lib/binlog/reader/PrettyPrinter.H
#ifndef BINLOG_READER_PRETTYPRINTER_H_
#define BINLOG_READER_PRETTYPRINTER_H_

#include <iosfwd>
#include <string>

namespace binlog {
namespace reader {

namespace entry {

class Entry;
class Event;
class EventSource;

} // namespace entry

using entry::Entry;
using entry::Event;
using entry::EventSource;

class
__attribute__((visibility("default")))
PrettyPrinter
{
public:
  PrettyPrinter();

  void setEntryFormat(const std::string& format) { _entryFormat = format; }
  void setEventFormat(const std::string& format) { _eventFormat = format; }
  void setEventSourceFormat(const std::string& format) { _eventSourceFormat = format; }
  void setDateFormat(const std::string& format) { _dateFormat = format; }

  std::ostream& print(const Entry& entry, std::ostream& out) const;
  std::ostream& print(const Event& event, std::ostream& out) const;
  std::ostream& print(const EventSource& eventSource, std::ostream& out) const;

private:
  template <typename Entity>
  void printEntity(const Entity& entity, const std::string& format, std::ostream& out) const;

  void printField(const Entry& entry, const char spec, std::ostream& out) const;
  void printField(const Event& event, const char spec, std::ostream& out) const;
  void printField(const EventSource& eventSource, const char spec, std::ostream& out) const;

  class PrintableDate;
  void printField(const PrintableDate& date, const char spec, std::ostream& out) const;

  std::string _entryFormat;
  std::string _eventFormat;
  std::string _eventSourceFormat;
  std::string _dateFormat;
};

} // namespace reader
} // namespace binlog


#endif /* BINLOG_READER_PRETTYPRINTER_H_ */
Attention:  ./lib/binlog/reader/FlowNameStream.H
#ifndef BINLOG_READER_FLOWNAMESTREAM_H_
#define BINLOG_READER_FLOWNAMESTREAM_H_

#include <string>
#include <vector>

#include <binlog/reader/EntryProcessor.H>

namespace binlog {
namespace reader {

class FlowNameStream : public EntryProcessor<std::string>
{
  typedef EntryProcessor<std::string> EntryProcessorT;

public:
  FlowNameStream(detail::Consumable<Entry>& input);

protected:
  void processTSCSynchronization(TscSynchronization&, SinkT&) {}
  void processEventSource(EventSource& eventSource, SinkT& sink);
  void processThreadActivity(ThreadActivity&, SinkT&, std::error_code&) {}

  bool validEntryTag(Entry::tag_t) const { return true; }

private:
  std::vector<std::string> _flowNames;
};

} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_FLOWNAMESTREAM_H_ */
Attention:  ./lib/binlog/reader/detail/FormatString.H
#ifndef BINLOG_READER_DETAIL_FORMATSTRING_H_
#define BINLOG_READER_DETAIL_FORMATSTRING_H_

#include <vector>
#include <string>
#include <memory>
#include <map>
#include <iosfwd>

#include <binlog/reader/detail/Buffer.H>
#include <binlog/reader/detail/Argument.H>

namespace binlog {
namespace reader {
namespace detail {

/*
* Near the end of a creation of an `Event`, we have a format string
* and a `ReadBuffer` containing some arguments
* (and argument type descriptors). E.g:
*
* "Office temperature is: {0}" and buffer containing {36};
*
* At the end, we would like to get the final message
* with placeholders substituted and an array of string representations
* of arguments to ease future data mining. (Outside of the scope of libreader)
*
* Nonfunctional goal is to have a template (`ParsedFormat`)
* which is instantiated only once (i.e: parse the format string once)
* but can be evaluated several times using different arguments.
*
* The following code achieves exactly this.
*/

/**
* `FormatItem` is the basic building block
* of `ParsedFormat`. It represents a template
* which is transformable to string if combined
* with a arguments.
*/
class FormatItem
{
public:
  FormatItem(std::size_t pos);

  /** trivial getter */
  std::size_t getPos() const
  {
    return _pos;
  }

  /** write string representation to `out` */
  virtual void toString(const std::vector<Argument>& args, std::ostream& out) const = 0;

  /** get argument index if item is arg dependent, -1 otherwise */
  virtual std::size_t argIndex() const
  {
    return -1lu;
  };

  virtual std::string name() const
  {
    return std::string();
  }

  /** nop */
  virtual inline ~FormatItem() {}

protected:
  std::size_t _pos; /**< Position of item in the format string */
};

/**
* A `FormatItem` which holds static data (string)
*/
class StaticFormatItem : public FormatItem
{
public:
  StaticFormatItem(const std::string& staticData, std::size_t pos);

  /** write `_staticData` to `out` */
  void toString(const std::vector<Argument>&, std::ostream& out) const;

private:
  std::string _staticData; /**< Encapsulated static data */
};

/**
* A `FormatItem` which value depends on event specific arguments.
*/
class ArgumentFormatItem : public FormatItem
{
public:
  ArgumentFormatItem(std::size_t argIndex, std::size_t pos);

  /** write args[_argIndex] to `out` or "N/A" if index is invalid */
  void toString(const std::vector<Argument>& args, std::ostream& out) const;

  /** trivial getter */
  std::size_t argIndex() const
  {
    return _argIndex;
  }

private:
  std::size_t _argIndex; /**< Argument index: "Foobar {3}" -> 3 */
};

/**
* An `ArgumentFormatItem` which is created from a named placeholder.
*/
class NamedArgumentFormatItem : public ArgumentFormatItem
{
public:
  NamedArgumentFormatItem(
    std::size_t argIndex, std::size_t pos, const std::string& name
  );

  /** trivial getter */
  std::string name() const
  {
    return _name;
  }

private:
  std::string _name; /**< Placeholder name: "Foobar {3:trId} -> trId" */
};

/**
* `ParsedFormat` is a digested format string
* which can be transformed easily to string
* by replacing placeholders with arguments
* in an argument bag.
*
* A `ParsedFormat` consists of `FormatItem`s.
* A `FormatItem` can be static or dynamic.
*
* Example:
* "CO2 level is: {0}, which is {1}" results in:
*
*  1. StaticFormatItem{"CO2 level is:"}
*  2. ArgumentFormatItem{0}
*  3. StaticFormatItem{", which is"}
*  4. ArgumentFormatItem{1}
*/
class ParsedFormat
{
public:
  /** nop */
  ParsedFormat() {}

  /** Parses `format` */
  ParsedFormat(const std::string& format);

  /**
   * Substitutes format strings placeholders
   * with arguments taken from `args`.
   */
  void substituePlaceholders(const std::vector<Argument>& args, std::ostream& out) const;

  std::map<std::size_t, std::string> getNamedPlaceholders() const;

  /**
   * The `FormatItem` template components of the
   * represented format.
   */
  std::vector<std::unique_ptr<FormatItem>> _items;
};

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_FORMATSTRING_H_ */
Attention:  ./lib/binlog/reader/detail/SourceLocation.H
#ifndef BINLOG_READER_DETAIL_SOURCE_LOCATION_H_
#define BINLOG_READER_DETAIL_SOURCE_LOCATION_H_

#include <string>
#include <vector>

namespace binlog {
namespace reader {
namespace detail {

struct SourceLocation
{
  std::string function;
  std::string file;
  unsigned line;
};

/**
* Resolves instructions pointed by elems of `addrs`
* to SourceLocation objects.
*
* @post result.size() == addrs.size()
*/
std::vector<SourceLocation> getSourceLocationsByAddrs(
  const std::string& objectFilePath,
  const std::vector<void*>& addrs
);

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_SOURCE_LOCATION_H_ */
Attention:  ./lib/binlog/reader/detail/DeserializedArray.H
#ifndef BINLOG_READER_DETAIL_DESERIALIZEDARRAY_H_
#define BINLOG_READER_DETAIL_DESERIALIZEDARRAY_H_

#include <vector>
#include <ostream>
#include <system_error>

#include <binlog/reader/detail/Argument.H>

namespace binlog {
namespace reader {
namespace detail {

class ArgumentParseContext;
class ReadBuffer;

class DeserializedArray
{
public:
  DeserializedArray(
    const ArgumentParseContext& apc, ReadBuffer& reader, std::error_code& ec
  );

  __attribute__((visibility("default")))
  const std::vector<Argument>& getData() const { return _data; }

private:
  friend std::ostream&
  operator<<(std::ostream& out, const DeserializedArray& da);

  std::vector<Argument> _data;
};

std::ostream& operator<<(std::ostream& out, const DeserializedArray& da);

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_DESERIALIZEDARRAY_H_ */
Attention:  ./lib/binlog/reader/detail/StructDefinitionStream.H
#ifndef BINLOG_READER_DETAIL_STRUCTDEFINITIONSTREAM_H_
#define BINLOG_READER_DETAIL_STRUCTDEFINITIONSTREAM_H_

#include <binlog/reader/detail/Consumable.H>
#include <binlog/reader/entry/StructDefinition.H>
#include <binlog/detail/Elf.H>

namespace binlog {
namespace reader {
namespace detail {

class StructDefinitionStream : public detail::Consumable<entry::StructDefinition>
{
  typedef detail::Consumable<entry::StructDefinition>::Callback SinkT;

public:
  StructDefinitionStream(const binlog::detail::Elf& elf);

  using detail::Consumable<entry::StructDefinition>::consume;
  void consume(SinkT sink, ErrorHandler handleError);

private:
  const binlog::detail::Elf& _elf;
};

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_STRUCTDEFINITIONSTREAM_H_ */
Attention:  ./lib/binlog/reader/detail/MmapInputStream.H
#ifndef BINLOG_READER_DETAIL_MMAPINPUTSTREAM_H_
#define BINLOG_READER_DETAIL_MMAPINPUTSTREAM_H_

#include <string>

#include <binlog/reader/detail/InputStream.H>
#include <binlog/detail/Fd.H>

namespace binlog {
namespace reader {
namespace detail {

class MmapInputStream : public InputStream
{
public:
  MmapInputStream(const MmapInputStream&) = delete;
  void operator=(const MmapInputStream&) = delete;
  void operator=(MmapInputStream&&) = delete;

  /**
   * @throws std::runtime_error if failed to open or mmap file
   */
  MmapInputStream(const std::string& path);

  /** Copies state and leaves `rhs` in an empty state */
  MmapInputStream(MmapInputStream&& rhs);

  /** Unmap file */
  ~MmapInputStream();

  explicit operator bool() const;
  off_t tellg() const;
  bool seekg(off_t index);

  // Reads

  std::size_t read(char* dst, std::size_t size);

  bool read(Buffer& buffer, ReadBuffer& reader, std::size_t size);

private:
  binlog::detail::Fd _file;
  const char* _buffer = nullptr;
  const char* _current = nullptr;
  std::size_t _bufferSize = 0;
};

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_MMAPINPUTSTREAM_H_ */
Attention:  ./lib/binlog/reader/detail/DeserializedStruct.H
#ifndef BINLOG_READER_DETAIL_DESERIALIZEDSTRUCT_H_
#define BINLOG_READER_DETAIL_DESERIALIZEDSTRUCT_H_

#include <string>
#include <ostream>

#include <binlog/reader/detail/Argument.H>

namespace binlog {
namespace reader {
namespace detail {

class DeserializedStruct
{
public:
  typedef std::vector<std::pair<
    std::string, /* field name */
    Argument     /* field content */
  >> FieldContainer;

  DeserializedStruct() = default;

  DeserializedStruct(const std::string& name, std::size_t fieldCount = 0);
  void setField(const std::string& name, const Argument& value);

  // getters

  __attribute__((visibility("default")))
  const std::string& getName() const { return _name; }

  __attribute__((visibility("default")))
  const FieldContainer& getFields() const { return _fields; }

private:
  friend std::ostream&
  operator<<(std::ostream& out, const DeserializedStruct& ds);

  std::string _name;
  FieldContainer _fields;
};

std::ostream& operator<<(std::ostream& out, const DeserializedStruct& ds);

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_DESERIALIZEDSTRUCT_H_ */
Attention:  ./lib/binlog/reader/detail/AggregateInputStream.H
#ifndef BINLOG_READER_DETAIL_AGGREGATEINPUTSTREAM_H_
#define BINLOG_READER_DETAIL_AGGREGATEINPUTSTREAM_H_

#include <vector>
#include <string>
#include <memory>

#include <binlog/reader/detail/InputStream.H>

namespace binlog {
namespace reader {
namespace detail {

class AggregateInputStream : public InputStream
{
public:
  AggregateInputStream(const std::vector<std::string>& paths, bool continuous);

  explicit operator bool() const;
  bool seekg(off_t index);
  off_t tellg() const;
  std::size_t read(char* dst, std::size_t size);
  std::string readShebang();

private:
  std::vector<std::unique_ptr<InputStream>> _streams;
  std::vector<std::unique_ptr<InputStream>>::iterator _currentStreamIt;
};

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_AGGREGATEINPUTSTREAM_H_ */
Attention:  ./lib/binlog/reader/detail/Argument.H
#ifndef BINLOG_READER_DETAIL_ARGUMENT_H_
#define BINLOG_READER_DETAIL_ARGUMENT_H_

#include <string>
#include <iosfwd>
#include <cstdint>

#include <boost/variant.hpp>
#include <boost/lexical_cast.hpp>

// Additinal includes at the end

namespace binlog {
namespace reader {
namespace detail {

class DeserializedStruct;
class DeserializedArray;
class DeserializedTuple;
class ArgumentParseContext;
class ReadBuffer;

struct ReadError {};
struct NullArgument {};

typedef boost::variant<
  bool,

  int8_t,
  int16_t,
  int32_t,
  int64_t,

  uint8_t,
  uint16_t,
  uint32_t,
  uint64_t,

  float,
  double,

  std::string,

  boost::recursive_wrapper<DeserializedStruct>,
  boost::recursive_wrapper<DeserializedArray>,
  boost::recursive_wrapper<DeserializedTuple>,

  NullArgument, // empty optional

  ReadError
> Argument;

Argument readArgument(
  const ArgumentParseContext& apc, ReadBuffer& in, const char typeSpec
);

__attribute__((visibility("default")))
std::ostream& operator<<(std::ostream& out, const Argument& arg);

template <typename T>
class ArgumentComparator : public boost::static_visitor<bool>
{
public:
  ArgumentComparator(const T& value)
    :_value(value)
  {}

  template <typename U>
  bool operator()(const U& arg) const
  {
    return _value == boost::lexical_cast<T>(arg);
  }

  bool operator()(const T& arg) const
  {
    return _value == arg;
  }

private:
  const T& _value;
};

template <typename T>
bool operator==(const T& value, const Argument& arg)
{
  ArgumentComparator<T> comparator(value);
  return boost::apply_visitor(comparator, arg);
}

template <typename T>
bool operator==(const Argument& arg, const T& value)
{
  return value == arg;
}

struct IsPrintableArgument : public boost::static_visitor<bool>
{
  template <typename T>
  bool operator()(const T&) const { return false; }

  bool operator()(const unsigned char& c) const
  {
    return std::isprint(c) || std::isspace(c);
  }

  bool operator()(const signed char& c) const
  {
    return std::isprint(c) || std::isspace(c);
  }
};

} // namespace detail
} // namespace reader
} // namespace binlog

// The following needs the definition of Argument,
// but clients which need complete Argument
// have to include these in turn.
// Avoid long incomprehensible compile errors
// by including these here.

#include <binlog/reader/detail/DeserializedStruct.H>
#include <binlog/reader/detail/DeserializedArray.H>
#include <binlog/reader/detail/DeserializedTuple.H>

#endif /* BINLOG_READER_DETAIL_ARGUMENT_H_ */
Attention:  ./lib/binlog/reader/detail/InputStream.H
#ifndef BINLOG_READER_DETAIL_INPUTSTREAM_H_
#define BINLOG_READER_DETAIL_INPUTSTREAM_H_

#include <binlog/reader/detail/Buffer.H>

namespace binlog {
namespace reader {
namespace detail {

class
__attribute__((visibility("default")))
InputStream
{
public:
  virtual ~InputStream() {}

  virtual explicit operator bool() const = 0;
  virtual off_t tellg() const = 0;
  virtual bool seekg(off_t index) = 0;

  // Reads

  /** @returns 0 on error, read byte count otherwise */
  virtual std::size_t read(char* dst, std::size_t size) = 0;

  /**
   * Reads maximum `size` bytes and points `reader` to the results.
   * The results are either stored in `buffer` or owned by the stream.
   * In the latter case, `buffer` is ignored.
   */
  virtual bool read(Buffer& buffer, ReadBuffer& reader, std::size_t size);

  /**
   * @returns #! line with newline
   * or empty string if #! is not found or tellg() != 0
   */
  virtual std::string readShebang();

  template <typename T>
  bool read(T& dst)
  {
    return read(reinterpret_cast<char*>(&dst), sizeof(T)) == sizeof(T);
  }
};

// Hot path inlined

inline bool InputStream::read(Buffer& buffer, ReadBuffer& reader, std::size_t size)
{
  buffer.reset(size);
  if (read(buffer.get(), size) == size)
  {
    reader = ReadBuffer(buffer);
    return true;
  }

  return false;
}

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_INPUTSTREAM_H_ */
Attention:  ./lib/binlog/reader/detail/DeserializedTuple.H
#ifndef BINLOG_READER_DETAIL_DESERIALIZEDTUPLE_H_
#define BINLOG_READER_DETAIL_DESERIALIZEDTUPLE_H_

#include <vector>
#include <ostream>
#include <system_error>

#include <binlog/reader/detail/Argument.H>

namespace binlog {
namespace reader {
namespace detail {

class ArgumentParseContext;
class ReadBuffer;

class DeserializedTuple
{
public:
  DeserializedTuple(
    const ArgumentParseContext& apc, ReadBuffer& reader, std::error_code& ec
  );

  __attribute__((visibility("default")))
  const std::vector<Argument>& getData() const { return _data; }

private:
  friend std::ostream&
  operator<<(std::ostream& out, const DeserializedTuple& dt);

  std::vector<Argument> _data;
};

std::ostream& operator<<(std::ostream& out, const DeserializedTuple& dt);

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_DESERIALIZEDTUPLE_H_ */
Attention:  ./lib/binlog/reader/detail/ArgumentParseContext.H
#ifndef BINLOG_READER_DETAIL_ARGUMENTPARSECONTEXT_H_
#define BINLOG_READER_DETAIL_ARGUMENTPARSECONTEXT_H_

#include <map>
#include <system_error>
#include <vector>

#include <binlog/reader/entry/StructDefinition.H>
#include <binlog/reader/detail/Buffer.H>
#include <binlog/reader/detail/Argument.H>
#include <binlog/detail/Arguments.H> // typeid_t

namespace binlog {
namespace reader {
namespace detail {

class
__attribute__((visibility("default")))
ArgumentParseContext
{
public:
  void addStructDefinition(entry::StructDefinition structDef);

  DeserializedStruct readStructure(ReadBuffer& reader, std::error_code& ec) const;
  std::vector<Argument> readArguments(ReadBuffer& reader, const std::string& typeCodes) const;

private:
  using typeid_t = binlog::detail::typeid_t;
  std::map<typeid_t, entry::StructDefinition> _structures;
};

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_ARGUMENTPARSECONTEXT_H_ */
Attention:  ./lib/binlog/reader/detail/Buffer.H
#ifndef BINLOG_READER_DETAIL_BUFFER_H_
#define BINLOG_READER_DETAIL_BUFFER_H_

#include <memory>
#include <string>
#include <cassert>
#include <cstring>
#include <vector>
#include <system_error>
#include <type_traits>

namespace binlog {
namespace reader {
namespace detail {

class Buffer
{
public:
  typedef char CharT;

  Buffer() : _size(0) {}

  Buffer(std::size_t size)
    :_size(size),
     _data(new CharT[size])
  {}

  void reset(std::size_t size)
  {
    _size = size;
    _data.reset(new CharT[size]);
  }

  CharT* get()
  {
    return _data.get();
  }

  const CharT* get() const
  {
    return _data.get();
  }

  std::size_t size() const
  {
    return _size;
  }

private:
  std::size_t _size;
  std::unique_ptr<CharT[]> _data;
};

class ReadBuffer
{
public:
  ReadBuffer(const Buffer& buffer)
    :_current(buffer.get()),
     _end(_current + buffer.size())
  {}

  ReadBuffer(const Buffer::CharT* buffer)
    :_current(buffer),
     _end(_current + strlen(buffer))
  {}

  ReadBuffer(const Buffer::CharT* buffer, std::size_t size)
    :_current(buffer),
     _end(_current + size)
  {}

  ReadBuffer()
    :_current(nullptr),
     _end(nullptr)
  {}

  void assign(const Buffer& buffer)
  {
    _current = buffer.get();
    _end = _current + buffer.size();
  }

  template <typename T, typename std::enable_if<__has_trivial_copy(T), int>::type = 0>
  bool read(T& target)
  {
    return read(reinterpret_cast<char*>(&target), sizeof(T)) == sizeof(T);
  }

  std::size_t read(char* dst, const std::size_t size)
  {
    if (_current + size > _end)
    {
      return 0;
    }

    memcpy(dst, _current, size);
    _current += size;

    return size;
  }

  bool readline(std::string& out, const char delim)
  {
    const char* end = reinterpret_cast<const char*>(
      memchr(_current, delim, size())
    );

    if (end == nullptr) { return false; }

    out.assign(_current, end);
    _current = end + 1; // +1: consume delim

    return true;
  }

  void discard(std::size_t bytes)
  {
    _current += bytes;
  }

  const Buffer::CharT* get() const
  {
    return _current;
  }

  std::size_t size() const
  {
    return std::size_t(_end - _current);
  }

private:
  const Buffer::CharT* _current;
  const Buffer::CharT* _end;
};

template <typename T, typename Error, typename std::enable_if<! __has_trivial_copy(T), int>::type = 0>
void serialize(ReadBuffer& reader, T& target, std::error_code& ec, const Error&)
{
  target.serialize(reader, ec);
}

template <typename T, typename Error, typename std::enable_if<__has_trivial_copy(T), int>::type = 0>
void serialize(ReadBuffer& reader, T& target, std::error_code& ec, const Error& error)
{
  if (! reader.read(target)) { ec = make_error_code(error); }
}

template <typename Error>
void serialize(ReadBuffer& reader, std::string& target, std::error_code& ec, const Error& error)
{
  if (! reader.readline(target, '\0')) { ec = make_error_code(error); }
}

template <typename T, typename Error>
void serialize(ReadBuffer& reader, std::vector<T>& target, std::error_code& ec, const Error& error)
{
  uint64_t size = 0;
  serialize(reader, size, ec, error);
  if (ec) { return; }
  target.resize(size);

  for (auto&& targetElem : target)
  {
    serialize(reader, targetElem, ec, error);
  }
}

class WriteBuffer
{
public:
  WriteBuffer() {}
  WriteBuffer(const std::size_t& reserveSize)
  {
    _buffer.reserve(reserveSize);
  }

  template <typename T, typename std::enable_if<__has_trivial_copy(T), int>::type = 0>
  void write(const T& source)
  {
    write(reinterpret_cast<const char*>(&source), sizeof(T));
  }

  void write(const char* src, std::size_t len)
  {
    _buffer.insert(_buffer.end(), src, src+len);
  }

  template <typename T, typename std::enable_if<__has_trivial_copy(T), int>::type = 0>
  void overwrite(std::size_t pos, const T& source)
  {
    overwrite(pos, reinterpret_cast<const char*>(&source), sizeof(T));
  }

  void overwrite(std::size_t pos, const char* src, std::size_t len)
  {
    memcpy(_buffer.data() + pos, src, len);
  }

  const char* get() const
  {
    return _buffer.data();
  }

  std::size_t size() const
  {
    return _buffer.size();
  }

private:
  std::vector<char> _buffer;
};

template <typename T, typename Error, typename std::enable_if<! __has_trivial_copy(T), int>::type = 0>
void serialize(WriteBuffer& writer, T& source, std::error_code& ec, const Error&)
{
  source.serialize(writer, ec);
}

template <typename T, typename Error, typename std::enable_if<__has_trivial_copy(T), int>::type = 0>
void serialize(WriteBuffer& writer, T& source, std::error_code&, const Error&)
{
  writer.write(source);
}

template <typename Error>
void serialize(WriteBuffer& writer, std::string& source, std::error_code&, const Error&)
{
  writer.write(source.c_str(), source.size() + 1); // +1: \0
}

template <typename T, typename Error>
void serialize(WriteBuffer& writer, std::vector<T>& source, std::error_code& ec, const Error& error)
{
  uint64_t size = source.size();
  serialize(writer, size, ec, error);
  for (auto& item : source)
  {
    serialize(writer, item, ec, error);
  }
}

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_BUFFER_H_ */
Attention:  ./lib/binlog/reader/detail/CompressedFileInputStream.H
#ifndef BINLOG_READER_DETAIL_COMPRESSEDFILEINPUTSTREAM_H_
#define BINLOG_READER_DETAIL_COMPRESSEDFILEINPUTSTREAM_H_

#include <zlib.h>

#include <binlog/reader/detail/InputStream.H>
#include <binlog/detail/Fd.H>

namespace binlog {
namespace reader {
namespace detail {

class CompressedFileInputStream : public InputStream
{
public:
  CompressedFileInputStream(const CompressedFileInputStream&) = delete;
  void operator=(const CompressedFileInputStream&) = delete;
  void operator=(CompressedFileInputStream&&) = delete;

  /** @throws std::runtime_error if failed to open file */
  CompressedFileInputStream(const std::string& path);

  /** Copies state and leaves `rhs` in an empty state */
  CompressedFileInputStream(CompressedFileInputStream&& rhs) = default;

  /** File descriptor and zlib cleanup */
  ~CompressedFileInputStream();

  /** @returns true, if has has associated file handle */
  explicit operator bool() const { return !!_file; }

  off_t tellg() const;
  bool seekg(off_t index);

  std::size_t read(char* dst, std::size_t size);

private:
  binlog::detail::Fd _file; /**< fd returned by open */
  gzFile _gzFile;           /**< zlib handle of `_file` */
};

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_COMPRESSEDFILEINPUTSTREAM_H_ */
Attention:  ./lib/binlog/reader/detail/Consumable.H
#ifndef BINLOG_READER_DETAIL_CONSUMABLE_H_
#define BINLOG_READER_DETAIL_CONSUMABLE_H_

#include <cstdio>
#include <functional>
#include <system_error>

namespace binlog {
namespace reader {
namespace detail {

template <typename... T>
class Consumable
{
protected:
  typedef std::function<void(T&...)> Callback;
  typedef std::function<void(std::error_code&)> ErrorHandler;

public:
  virtual ~Consumable() {}

  void consume(Callback consumer)
  {
    consume(consumer, [](std::error_code& ec)
    {
      fprintf(stderr, "[binlog] Error: %s\n", ec.message().c_str());
    });
  }

  void consume(Callback consumer, std::error_code& ec)
  {
    consume(consumer, [&](std::error_code& ec2)
    {
      ec.assign(ec2.value(), ec2.category());
    });
  }

  virtual void consume(Callback consumer, ErrorHandler handleError) = 0;
};

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_CONSUMABLE_H_ */
Attention:  ./lib/binlog/reader/detail/MemoryInputStream.H
#ifndef BINLOG_READER_DETAIL_MEMORYINPUTSTREAM_H_
#define BINLOG_READER_DETAIL_MEMORYINPUTSTREAM_H_

#include <binlog/reader/detail/InputStream.H>
#include <binlog/reader/detail/Buffer.H>

namespace binlog {
namespace reader {
namespace detail {

class MemoryInputStream : public InputStream
{
public:
  MemoryInputStream()
    :_begin(nullptr),
     _buffer(nullptr, 0)
  {}

  MemoryInputStream(const MemoryInputStream&) = delete;
  void operator=(const MemoryInputStream&) = delete;
  MemoryInputStream(MemoryInputStream&&) = default;
  MemoryInputStream& operator=(MemoryInputStream&&) = default;

  void reset(const char* buffer, std::size_t size)
  {
    _begin = buffer;
    _buffer = detail::ReadBuffer(buffer, size);
  }

  explicit operator bool() const { return _buffer.size(); }

  off_t tellg() const { return _buffer.get() - _begin; }

  bool seekg(off_t index)
  {
    _buffer = detail::ReadBuffer(
      _begin + index,
      std::size_t(tellg() + off_t(_buffer.size()) - index)
    );
    return true;
  }

  std::size_t read(char* dst, std::size_t size)
  {
    return _buffer.read(dst, size);
  }

  bool read(Buffer&, ReadBuffer& reader, std::size_t size)
  {
    if (size <= _buffer.size())
    {
      reader = ReadBuffer(_buffer.get(), size);
      _buffer.discard(size);
      return true;
    }

    return false;
  }

private:
  const char* _begin;
  detail::ReadBuffer _buffer;
};

} // namespace detail
} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_DETAIL_MEMORYINPUTSTREAM_H_ */
Attention:  ./lib/binlog/reader/FileInputStream.H
#ifndef BINLOG_READER_DETAIL_FILEINPUTSTREAM_H_
#define BINLOG_READER_DETAIL_FILEINPUTSTREAM_H_

#include <string>
#include <system_error>

#include <binlog/reader/detail/InputStream.H>
#include <binlog/detail/Fd.H>

namespace binlog {
namespace reader {

/**
* Try to open read only file with and without O_NOATIME.
*/
void openFile(const std::string& path, binlog::detail::Fd& result, std::error_code& ec);

/*
* While the reader parses binary logfiles,
* it's necessary to process each entry in
* an isolated way.
*
* I found no way to extract read only part of an
* std::istream without copying data.
*
* mmap would provide a way to
*  - Encapsulate char array in a stream like wrapper
*  - Get a fixed view of this stream without copy
*
* However, mmap does not play with inotify.
*/

/**
* Wraps a file in a read-only stream interface
*
* Optionally uses inotify to watch file changes
*/
class FileInputStream : public detail::InputStream
{
public:
  FileInputStream(const FileInputStream&) = delete;
  void operator=(const FileInputStream&) = delete;
  void operator=(FileInputStream&&) = delete;

  /**
   * @throws std::runtime_error if failed to open file
   */
  FileInputStream(const std::string& path, bool continuous);

  FileInputStream(FileInputStream&& rhs) = default;

  /**
   * Copies maximum `size` bytes to `dst`
   *
   * If not enough bytes are available in the stream,
   * only bytes available will be copied over.
   *
   * @returns bytes copied
   */
  std::size_t read(char* dst, std::size_t size);

  /**
   * @returns true, if a possibly blocking operation can extract
   * more bytes from the stream.
   */
  explicit operator bool() const;

  /**
   * @returns true, if bytes are available to read without blocking
   */
  bool readAvailable() const;

  /**
   * @returns actual read position in the stream
   */
  off_t tellg() const;

  /**
   * Moves reader position to `index`
   */
  bool seekg(off_t index);

private:
  bool waitForFile();
  bool initInotify();
  bool addDirWatch();
  bool removeWatch(int& fd);

  typedef binlog::detail::Fd Fd;

  std::string _path;/**< Path to the underlying file */
  Fd _file;         /**< Handle to opened file */
  bool _continuous; /**< true, if waits for data on EOF */
  Fd _inotify;      /**< Handle returned by inotify_init */
  int _watch;       /**< fd returned by inotify_add_watch */
  int _dirWatch;    /**< Similar watch but on the directory */
};

} // namespace reader
} // namespace binlog


#endif /* BINLOG_READER_DETAIL_FILEINPUTSTREAM_H_ */
Attention:  ./lib/binlog/reader/FlowInstanceStream.H
#ifndef BINLOG_READER_FLOWINSTANCESTREAM_H_
#define BINLOG_READER_FLOWINSTANCESTREAM_H_

#include <string>
#include <map>
#include <set>

#include <binlog/reader/EntryProcessor.H>
#include <binlog/reader/entry/FlowInstance.H>
#include <binlog/reader/entry/EventSource.H>

namespace binlog {
namespace reader {

class FlowInstanceStream : public EntryProcessor<entry::FlowInstance>
{
  typedef EntryProcessor<entry::FlowInstance> EntryProcessorT;
  typedef entry::EventSource::tag_t tag_t;

public:
  FlowInstanceStream(detail::Consumable<Entry>& input, const std::string& flowName);

protected:
  void processEventSource(EventSource& eventSource, SinkT& sink);
  void processThreadActivity(ThreadActivity& activity, SinkT& sink, std::error_code&);

  bool validEntryTag(Entry::tag_t) const { return true; }

private:
  std::string _flowName;
  std::map<tag_t, std::size_t> _flowSources;
  std::set<std::string> _instancesFound;
};

} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_FLOWINSTANCESTREAM_H_ */
Attention:  ./lib/binlog/reader/FlowGroupedEventStream.H
#ifndef BINLOG_READER_FLOWGROUPEDEVENTSTREAM_H_
#define BINLOG_READER_FLOWGROUPEDEVENTSTREAM_H_

#include <string>
#include <vector>
#include <map>

#include <binlog/reader/EventStream.H>
#include <binlog/reader/entry/EventSource.H>
#include <binlog/reader/entry/Event.H>

namespace binlog {
namespace reader {

class FlowGroupedEventStream : public EventStream
{
  typedef entry::EventSource::tag_t tag_t;

public:
  FlowGroupedEventStream(
    detail::Consumable<Entry>& input,
    const std::string& flowName
  );

protected:
  void processEventSource(EventSource& eventSource, SinkT& sink);
  void processThreadActivity(ThreadActivity& activity, SinkT& sink, std::error_code& ec);

  void endOfInput(SinkT& sink);

private:
  struct FlowInstanceState
  {
    std::vector<entry::Event> events;
    std::size_t age = 0;
    entry::Event::tsc_t latestTsc = 0;

    void addEvent(entry::Event event, std::size_t threadAge);
  };

  struct ThreadState
  {
    std::string flowId;
    FlowInstanceState* pFlowInstance = nullptr;
    std::size_t age = 0;

    void reset();
  };

  typedef std::map<std::string, FlowInstanceState> FlowMap;
  typedef std::map<ThreadActivity::ThreadId, ThreadState> ThreadMap;

  void switchBatch(const ThreadActivity::ThreadId& to, SinkT& sink);
  void flushOldUnusedFlows(std::size_t minAge, SinkT& sink);
  void flushFlows(std::vector<FlowMap::iterator>& instances, SinkT& sink);

  std::string _flowName;
  std::size_t _currentAge;

  std::map<tag_t, std::size_t> _flowSources;

  FlowMap _activeFlows;
  ThreadMap _activeThreads;

  ThreadActivity::ThreadId _lastThreadIdSeen;
  ThreadState* _threadState;

  entry::Event::tsc_t _latestEmittedTsc;
  std::vector<entry::Event> _noflowEvents;
};

} // namespace reader
} // namespace binlog

#endif /* BINLOG_READER_FLOWGROUPEDEVENTSTREAM_H_ */
Attention:  ./lib/binlog/Binlog.H
#ifndef BINLOG_BINLOG_BINLOG_H_
#define BINLOG_BINLOG_BINLOG_H_

#include <map>
#include <string>
#include <vector>

#include <boost/preprocessor/cat.hpp>

#include <binlog/Severity.H>
#include <binlog/CategoryConfig.H>
//#include <binlog/FunctionGuard.H> included at the end
#include <binlog/Transform.H>
#include <binlog/detail/asm.H>
#include <binlog/detail/ElfConfig.H>
#include <binlog/detail/Entry.H>
#include <binlog/make_loggable/StdPointers.H>
#include <binlog/make_loggable/Enum.H>

//
// Configuration
//

#if defined BINLOG_USER_META
  #define BINLOG_CATEGORY_NAME_A BINLOG_USER_META "/"
#elif defined MSDEMETA
  #define BINLOG_CATEGORY_NAME_A MSDEMETA "/"
#else
  #define BINLOG_CATEGORY_NAME_A /* empty */
#endif

#if defined BINLOG_USER_PROJECT
  #define BINLOG_CATEGORY_NAME_B BINLOG_USER_PROJECT "/"
#elif defined MSDEPROJ
  #define BINLOG_CATEGORY_NAME_B MSDEPROJ "/"
#else
  #define BINLOG_CATEGORY_NAME_B /* empty */
#endif

#if defined BINLOG_USER_RELEASE
  #define BINLOG_CATEGORY_NAME_C BINLOG_USER_RELEASE
#elif defined MSDEREL
  #define BINLOG_CATEGORY_NAME_C MSDEREL
#else
  #define BINLOG_CATEGORY_NAME_C "trunk"
#endif

#define BINLOG_CATEGORY_NAME \
  BINLOG_CATEGORY_NAME_A BINLOG_CATEGORY_NAME_B BINLOG_CATEGORY_NAME_C

/**
* Binlog version
*
* Could be used for feature testing
*/
#define BINLOG_VERSION 1

/**
* Version of the layout of the produced binary entries
*
* This value should be incremented on each breaking layout change
* released to production.
*/
#define BINLOG_BINARY_LAYOUT_VERSION 1

/**
* Compile time log macro disabling.
*/
#if   defined BINLOG_MIN_SEVERITY_TRACE
  #define BINLOG_MIN_SEVERITY BINLOG_SEVERITY_TRACE
#elif defined BINLOG_MIN_SEVERITY_DEBUG
  #define BINLOG_MIN_SEVERITY BINLOG_SEVERITY_DEBUG
#elif defined BINLOG_MIN_SEVERITY_INFO
  #define BINLOG_MIN_SEVERITY BINLOG_SEVERITY_INFO
#elif defined BINLOG_MIN_SEVERITY_WARNING
  #define BINLOG_MIN_SEVERITY BINLOG_SEVERITY_WARNING
#elif defined BINLOG_MIN_SEVERITY_ERROR
  #define BINLOG_MIN_SEVERITY BINLOG_SEVERITY_ERROR
#elif defined BINLOG_MIN_SEVERITY_CRITICAL
  #define BINLOG_MIN_SEVERITY BINLOG_SEVERITY_CRITICAL
#elif defined BINLOG_MIN_SEVERITY_CONTROL
  #define BINLOG_MIN_SEVERITY BINLOG_SEVERITY_CONTROL
#elif defined BINLOG_MIN_SEVERITY_NONE
  #define BINLOG_MIN_SEVERITY BINLOG_SEVERITY_NONE
#else
  #define BINLOG_MIN_SEVERITY BINLOG_SEVERITY_TRACE
#endif

//
// Macro helpers
//

/**
* Do nothing block, inserted in place of disabled macros
*
* @see http://en.wikibooks.org/wiki/More_C++_Idioms/Multi-statement_Macro
*/
#define BINLOG_NOP do {} while (0)

/**
* declare and define DSO specific globals
*
* g_binlog_<category>_config: binlog::CategoryConfig
* g_binlog_<category>_elfConfig: binlog::ElfConfig
*
* Declaration uses extern, definition also creates a constructor
* which inits structures above. init_priority is required
* because GCC does not honor declaration order across variables
* and functions.
*
* If category comes from a macro, cat and paste trick required
*/

#define BINLOG_CATEGORY main

#define BINLOG_CAT_CONF_P(category) g_binlog_##category##_config
#define BINLOG_CAT_CONF(category) BINLOG_CAT_CONF_P(category)

#define BINLOG_CAT_ELFCONF_P(category) g_binlog_##category##_elfConfig
#define BINLOG_CAT_ELFCONF(category) BINLOG_CAT_ELFCONF_P(category)

#define BINLOG_DECLARE_CATEGORY(category)                  \
  extern binlog::CategoryConfig BINLOG_CAT_CONF(category); \
  /**/

#define BINLOG_DEFINE_CATEGORY(category, name)             \
  binlog::CategoryConfig BINLOG_CAT_CONF(category)         \
    __attribute__ ((visibility("hidden")));                \
                                                           \
  binlog::detail::CategoryConfigGuard BOOST_PP_CAT(BINLOG_CAT_CONF(category), _guard) \
    __attribute__ ((visibility("hidden")))                 \
    (name, BINLOG_CAT_CONF(category));                     \
                                                           \
  BINLOG_CATEGORY_ID(category,name)                        \
  /**/

#define BINLOG_DECLARE_ELF(category)                       \
  extern binlog::detail::ElfConfig BINLOG_CAT_ELFCONF(category);\
  /**/

#define BINLOG_DEFINE_ELF(category)                        \
  binlog::detail::ElfConfig BINLOG_CAT_ELFCONF(category)   \
    __attribute__ ((visibility("hidden"), section(".data")));   \
  /**/

//
// Interface
//

#define BINLOG_DECLARE                      \
  BINLOG_DECLARE_CATEGORY(BINLOG_CATEGORY)  \
  BINLOG_DECLARE_ELF(BINLOG_CATEGORY)       \
  /**/

#define BINLOG_INIT                         \
  BINLOG_DEFINE_CATEGORY(BINLOG_CATEGORY, BINLOG_CATEGORY_NAME)   \
  BINLOG_DEFINE_ELF(BINLOG_CATEGORY)        \
  /**/

#define BINLOG_DECLARE_SUBCATEGORY(subcategory)  \
  BINLOG_DECLARE_CATEGORY(subcategory)           \
  /**/

#define BINLOG_DEFINE_SUBCATEGORY(subcategory)  \
  BINLOG_DEFINE_CATEGORY(                       \
    subcategory,                                \
    BINLOG_CATEGORY_NAME "/" BOOST_PP_STRINGIZE(subcategory) \
  )                                             \
  /**/

//
// Implementation
//

// Declare category automatically
BINLOG_DECLARE

#ifndef BINLOG_ALWAYS_LOG

/**
* Logs event if it's enabled
*
* Checks category specific severity threshold,
* and per-source config.
*
* It would be great to implement this as a function instead of a macro,
* but that would evaluate the event arguments even if the event source
* is disabled.
*
* `idExpr` is the macro call itself, paste it only once.
*
* To avoid shadowing user variables passed in `...`, every local variable
* defined here must use the `_binlog_` prefix.
*/
#define BINLOG_WRITE_LOG_ENTRY(elfConfig, categoryConfig, severity, idExpr, ...)   \
  if (categoryConfig.minSeverity <= severity)                                      \
  {                                                                                \
   using binlog::detail::Entry;                                                   \
    std::size_t _binlog_sourceId = idExpr; /* avoid calling it multiple times */   \
    std::size_t _binlog_sourceIndex = elfConfig.getSourceIndex(_binlog_sourceId);  \
                                                                                   \
    if (elfConfig.isSourceEnabled(_binlog_sourceIndex))                            \
    {                                                                              \
      Entry::createLog(_binlog_sourceId, ##__VA_ARGS__);                           \
    }                                                                              \
  }                                                                                \
  /**/

#else // if BINLOG_ALWAYS_LOG is defined:

/**
* Logs event no matter what runtime thresholds are set.
*/
#define BINLOG_WRITE_LOG_ENTRY(elfConfig, categoryConfig, severity, idExpr, ...)   \
  binlog::detail::Entry::createLog(idExpr, ##__VA_ARGS__);                         \
  /**/

#endif // ifndef BINLOG_ALWAYS_LOG

#define BINLOG_DO_LOG(category, severity, format, ...) \
do {                                                   \
  BINLOG_WRITE_LOG_ENTRY(                              \
    BINLOG_CAT_ELFCONF(BINLOG_CATEGORY),               \
    BINLOG_CAT_CONF(category),                         \
    severity,                                          \
    BINLOG_MESSAGE_ID(category, severity, format, ##__VA_ARGS__),    \
    ##__VA_ARGS__                                      \
  );                                                   \
} while (0)                                            \
  /**/

//
// BINLOG_CATEGORIZED_<Severity> macros
//

#if BINLOG_SEVERITY_TRACE >= BINLOG_MIN_SEVERITY
#define BINLOG_CATEGORIZED_TRACE(category, format, ...) \
  BINLOG_DO_LOG(category, binlog::trace, format, ##__VA_ARGS__)
#else
  #define BINLOG_CATEGORIZED_TRACE(...) BINLOG_NOP
#endif

#if BINLOG_SEVERITY_DEBUG >= BINLOG_MIN_SEVERITY
#define BINLOG_CATEGORIZED_DEBUG(category, format, ...) \
  BINLOG_DO_LOG(category, binlog::debug, format, ##__VA_ARGS__)
#else
  #define BINLOG_CATEGORIZED_DEBUG(...) BINLOG_NOP
#endif


#if BINLOG_SEVERITY_INFO >= BINLOG_MIN_SEVERITY
#define BINLOG_CATEGORIZED_INFO(category, format, ...) \
  BINLOG_DO_LOG(category, binlog::info, format, ##__VA_ARGS__)
#else
  #define BINLOG_CATEGORIZED_INFO(...) BINLOG_NOP
#endif


#if BINLOG_SEVERITY_WARNING >= BINLOG_MIN_SEVERITY
#define BINLOG_CATEGORIZED_WARNING(category, format, ...) \
  BINLOG_DO_LOG(category, binlog::warning, format, ##__VA_ARGS__)
#else
  #define BINLOG_CATEGORIZED_WARNING(...) BINLOG_NOP
#endif


#if BINLOG_SEVERITY_ERROR >= BINLOG_MIN_SEVERITY
#define BINLOG_CATEGORIZED_ERROR(category, format, ...) \
  BINLOG_DO_LOG(category, binlog::error, format, ##__VA_ARGS__)
#else
  #define BINLOG_CATEGORIZED_ERROR(...) BINLOG_NOP
#endif


#if BINLOG_SEVERITY_CRITICAL >= BINLOG_MIN_SEVERITY
#define BINLOG_CATEGORIZED_CRITICAL(category, format, ...) \
  BINLOG_DO_LOG(category, binlog::critical, format, ##__VA_ARGS__)
#else
  #define BINLOG_CATEGORIZED_CRITICAL(...) BINLOG_NOP
#endif

// Macros using the default category of the module:
#define BINLOG_TRACE(format, ...)    BINLOG_CATEGORIZED_TRACE   (BINLOG_CATEGORY, format, ##__VA_ARGS__)
#define BINLOG_DEBUG(format, ...)    BINLOG_CATEGORIZED_DEBUG   (BINLOG_CATEGORY, format, ##__VA_ARGS__)
#define BINLOG_INFO(format, ...)     BINLOG_CATEGORIZED_INFO    (BINLOG_CATEGORY, format, ##__VA_ARGS__)
#define BINLOG_WARNING(format, ...)  BINLOG_CATEGORIZED_WARNING (BINLOG_CATEGORY, format, ##__VA_ARGS__)
#define BINLOG_ERROR(format, ...)    BINLOG_CATEGORIZED_ERROR   (BINLOG_CATEGORY, format, ##__VA_ARGS__)
#define BINLOG_CRITICAL(format, ...) BINLOG_CATEGORIZED_CRITICAL(BINLOG_CATEGORY, format, ##__VA_ARGS__)

//
// Flow control
//

#if BINLOG_SEVERITY_CONTROL >= BINLOG_MIN_SEVERITY
  #define BINLOG_BEGIN_FLOW(format, ...)  \
    BINLOG_DO_LOG(BINLOG_CATEGORY, binlog::control, "Begin flow: " format, ##__VA_ARGS__)
#else
  #define BINLOG_BEGIN_FLOW(...) BINLOG_NOP
#endif

#if BINLOG_SEVERITY_CONTROL >= BINLOG_MIN_SEVERITY
  #define BINLOG_END_FLOW(format, ...)  \
    BINLOG_DO_LOG(BINLOG_CATEGORY, binlog::control, "End flow: " format, ##__VA_ARGS__)
#else
  #define BINLOG_END_FLOW(...) BINLOG_NOP
#endif

namespace binlog {

//
// Category setup
//

__attribute__((visibility("default")))
void setCategoryConfigs(
  const std::vector<
    std::pair<std::string, CategoryConfig>
  >& configs
);

//
// Control & Status
//

/**
* Opens logfile to write, starts background thread
* to consume the produced entries.
*
* File gets chmod +x
*
* @throw std::runtime_error if failed to open logfile
* @throw std::runtime_error if a consumer is already running
*
*/
__attribute__((visibility("default")))
void openLogFile(const std::string& logFile);

/**
* Sets name of the caller thread.
*
* @param name Name of the thread,
* only the first 31 character is used.
*
* pthread_setname_np is not used.
*/
__attribute__((visibility("default")))
void setThreadName(const std::string& name);

} // namespace binlog

//
// Cleanup
//

#undef BINLOG_SEVERITY_DEBUG
#undef BINLOG_SEVERITY_INFO
#undef BINLOG_SEVERITY_WARNING
#undef BINLOG_SEVERITY_ERROR
#undef BINLOG_SEVERITY_CRITICAL
#undef BINLOG_MIN_SEVERITY

// FunctionGuard uses BINLOG_DEBUG #defined above
#include <binlog/FunctionGuard.H>

#endif /*BINLOG_BINLOG_ BINLOG_H_ */
Attention:  ./lib/binlog/detail/ConfigParser.H
#ifndef BINLOG_DETAIL_CONFIGPARSER_H_
#define BINLOG_DETAIL_CONFIGPARSER_H_

#include <memory>
#include <functional>
#include <system_error>

#include <boost/property_tree/ptree_fwd.hpp>
#include <boost/optional.hpp>

#include <binlog/sink/MultiSink.H>
#include <binlog/CategoryConfig.H>

namespace binlog {
namespace detail {

/**
* Parse configuration specifying category thresholds
* and sink setup.
*
* The input is a config file, the settings are applied
* to a Configuration and a Consumer instance. The
* exact behavior can be extended through factories.
*
* The parser recognizes variables in the config values
* in the following form: ${VARIABLE_NAME}, and replaces
* them by the value provided by a VariableFactory.
*
* NOTE: This class is responsible for parsing the
* configuration of the Binlog library; it has
* nothing to do with the Reader config.
*/
class
__attribute__((visibility("default")))
ConfigParser
{
public:
  typedef boost::property_tree::ptree Config;

  typedef sink::MultiSink::EventSourcePredicate EventSourcePredicate;

  /** Initialize pImpl body */
  ConfigParser();

  /** pImpl requires out of line dtor */
  ~ConfigParser();

  /**
   * Create a custom Sink type
   *
   * @param name Unique symbolic name of the sink
   * @param config Additional configuration
   *
   * Should return an empty unique_ptr if `name` is
   * unknown or the instantiation fails.
   *
   * Reserved names are: File, Stream, Syslog
   */
  typedef std::function<
    std::unique_ptr<sink::Sink>(const std::string& name, const Config& config)
  > SinkFactory;

  /**
   * Create a custom EventSourcePredicate
   *
   * @param name Unique symbolic name of the predicate
   *
   * For explanation on the nature of this predicate, @see MultiSink
   *
   * Should return an empty (default constructed) predicate
   * if `name` is unknown.
   *
   * Reserved names are:
   *   any,
   *   trace, debug, info, warning, error, critical, control, none,
   *   TRAC, DEBG, INFO, WARN, ERRO, CRIT, CTRL, NONE
   */
  typedef std::function<
    EventSourcePredicate(const std::string& name)
  > PredicateFactory;

  /**
   * Replace variables in config values
   *
   * It must be set before reading the config file
   * to take effect.
   *
   * @param name The name of the variable
   * @return The value of the variable
   */
  typedef std::function<
    std::string(const std::string& name)
  > VariableFactory;

  /**
   * Process config file
   *
   * @param configFile path to the config file
   *
   * Currently only the json format is supported,
   * with the additional extras provided by boost::property_tree.
   *
   * The exact layout of the config file is described in the
   * Integrators handbook. This method discards previously
   * read configs if any.
   */
  void readConfigFile(const std::string& configFile, std::error_code& ec);

  void setSinkFactory(const SinkFactory& sinkFactory);
  void setPredicateFactory(const PredicateFactory& predicateFactory);
  void setVariableFactory(const VariableFactory& variableFactory);

  std::vector<std::pair<std::string, CategoryConfig>>
  getCategoryConfig(std::error_code& ec);

  struct ConfiguredSink
  {
    std::unique_ptr<sink::Sink> sinkPtr;
    EventSourcePredicate predicate;
    sink::MultiSink::SinkDescription description;
  };

  std::vector<ConfiguredSink>
  getConfiguredSinks(std::error_code& ec);

  struct ProducerConfig
  {
    boost::optional<Severity> adaptiveSeverityCeiling;
    boost::optional<std::size_t> minQueueSize;
  };

  ProducerConfig getProducerConfig(std::error_code& ec);

private:
  void replaceVariables(Config& config);

  EventSourcePredicate extractEventSourcePredicate(
    const Config& sinkConfig,
    std::error_code& ec
  ) const;

  std::unique_ptr<sink::Sink> createSink(
    const std::string& type,
    const Config& sinkConfig,
    std::error_code& ec
  ) const;

  SinkFactory _sinkFactory;
  PredicateFactory _predicateFactory;
  VariableFactory _variableFactory;

  // Both property_tree and xpressive
  // use RTTI (typeid) for no good reason,
  // and have a large header.
  // To avoid putting such a burden on the user
  // we hide them with the pImpl idiom.
  struct Implementation;
  std::unique_ptr<Implementation> _impl;
};

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_CONFIGPARSER_H_ */
Attention:  ./lib/binlog/detail/Arguments.H
#ifndef BINLOG_DETAIL_ARGUMENTS_H_
#define BINLOG_DETAIL_ARGUMENTS_H_

#include <cstdint>
#include <type_traits>

#include <binlog/detail/ArrayWrapper.H>

namespace binlog {
namespace detail {

/**
* The following constructs provide
* a C++03 compatible mapping between
* a selection of types and enum values.
*
* Only types registered here are loggable.
*
* BINLOG_MESSAGE_ID uses LoggableDescriptor<T>::type_tag
* to persist event source argument
* type information.
*
* The reader program uses
* InverseLoggableDescriptor<ENUM>::type to
* to read the typed argument from the
* binary arg stream.
*
* If type T is connected, there is
* no need to add const T, volatile T or
* const volatile T. cv qualifiers are
* stripped when using LoggableDescriptor.
* (There are some exceptions,
* like const volatile char*)
*
* To add a loggable type:
*  1) Add custom enum to type_tag_t if needed.
*    1.a) If new enum was added, modify
*         BINLOG_TYPE_SWITCH below
*    1.b) Change the binlog::reader::detail::Argument variant
*         It'll need a new variant type and appropriate
*         deserialization template specialization.
*  2) Add BINLOG_CONNECT_TYPE_ENUM(type, enum) here.
*/

// TODO change type_tag_t to char enum class and remove static_assert

enum type_tag_t {
  type_none = 0,

  // fundamentals
  type_bool,

  type_8,
  type_16,
  type_32,
  type_64,

  type_u8,
  type_u16,
  type_u32,
  type_u64,

  type_float,
  type_double,

  type_string,

  // compound
  type_struct,
  type_array,
  type_tuple,

  // for optionals (various pointers, optional) and variant
  type_variant,
  type_null,

  // make sure you edit BINLOG_TYPE_SWITCH below
  // after adding an entry here.

  // last one
  type_tag_t_last
};

static_assert(
  type_tag_t_last < 255,
  "type_tag_t contains too many options, it must fit in a byte"
);

typedef uint64_t typeid_t; /**< Used in type introspection */

// TMP Util

template <typename T>
struct remove_pointer_const
{
  typedef T type;
};

template <typename U>
struct remove_pointer_const<const U*>
{
  typedef U* type;
};

template <typename U>
struct remove_pointer_const<const U* const>
{
  typedef U* type;
};

template <typename U, std::size_t N>
struct remove_pointer_const<const U[N]>
{
  typedef U type[N];
};

template <typename T>
struct remove_pointer_cv
{
  typedef T type;
};

template <typename U>
struct remove_pointer_cv<const U*>
{
  typedef U* type;
};

template <typename U>
struct remove_pointer_cv<volatile U*>
{
  typedef U* type;
};

template <typename U>
struct remove_pointer_cv<const volatile U*>
{
  typedef U* type;
};

template <typename T>
struct no_cv
{
  typedef typename remove_pointer_cv<
    typename std::remove_cv<T>::type
  >::type type;
};

// Descriptors

template <typename Field, std::size_t Offset>
struct FieldDescriptor
{
  typedef Field type;
  static const std::size_t offset = Offset;
};

template <typename MaybeLoggable>
struct LoggableDescriptor;
// see below the actual implementation of this default case

// Helper for LoggableDescriptor
template <typename KindOfLoggable>
using LoggableDescriptor_t = LoggableDescriptor<
  typename no_cv<
    typename std::remove_reference<KindOfLoggable>::type
  >::type
>;

template <typename T, type_tag_t tag>
struct TrivialLoggableDescriptor
{
  typedef T type;
  typedef FieldDescriptor<type, 0> descriptor;
  static const type_tag_t type_tag = tag;
};

struct invalid_type_tag {};

template <type_tag_t Tag>
struct InverseLoggableDescriptor
{
  typedef invalid_type_tag type;
};

#define BINLOG_TYPE_TO_ENUM(TYPE, TAG)  \
  template <>                           \
  struct LoggableDescriptor<TYPE>       \
    :public TrivialLoggableDescriptor<TYPE, TAG> \
  {};                                   \
  /**/

#define BINLOG_ENUM_TO_TYPE(TYPE, TAG)  \
  template <>                           \
  struct InverseLoggableDescriptor<TAG> \
  {                                     \
    typedef TYPE type;                  \
  };                                    \
  /**/

#define BINLOG_CONNECT_TYPE_ENUM(T, E) \
  BINLOG_TYPE_TO_ENUM(T, E)            \
  BINLOG_ENUM_TO_TYPE(T, E)            \
  /**/

BINLOG_CONNECT_TYPE_ENUM(bool, type_bool)

BINLOG_ENUM_TO_TYPE(int8_t, type_8)
BINLOG_ENUM_TO_TYPE(int16_t, type_16)
BINLOG_ENUM_TO_TYPE(int32_t, type_32)
BINLOG_ENUM_TO_TYPE(int64_t, type_64)

BINLOG_ENUM_TO_TYPE(uint8_t, type_u8)
BINLOG_ENUM_TO_TYPE(uint16_t, type_u16)
BINLOG_ENUM_TO_TYPE(uint32_t, type_u32)
BINLOG_ENUM_TO_TYPE(uint64_t, type_u64)

BINLOG_CONNECT_TYPE_ENUM(float, type_float)
BINLOG_CONNECT_TYPE_ENUM(double, type_double)

BINLOG_CONNECT_TYPE_ENUM(std::string, type_string)
BINLOG_TYPE_TO_ENUM(char*, type_string)
BINLOG_TYPE_TO_ENUM(char const*, type_string)
BINLOG_TYPE_TO_ENUM(const volatile char*, type_string)

// Connect string literals
template <size_t N>
struct LoggableDescriptor<char (&)[N]>
{
  typedef char type[N];
  typedef FieldDescriptor<type, 0> descriptor;
  static const type_tag_t type_tag = binlog::detail::type_string;
};

template <size_t N>
struct LoggableDescriptor<char [N]>
{
  typedef char type[N];
  typedef FieldDescriptor<type, 0> descriptor;
  static const type_tag_t type_tag = binlog::detail::type_string;
};

// All structures share the same type tag
struct structure_type_tag {};
BINLOG_ENUM_TO_TYPE(structure_type_tag, type_struct)

// LoggableDescriptor specializations are created by
// BINLOG_MAKE_LOGGABLE

// Connect binlog::detail::ArrayWrapper
// All arrays share the same type tag
struct array_type_tag {};
BINLOG_ENUM_TO_TYPE(array_type_tag, type_array)

template <typename T>
struct LoggableDescriptor<ArrayWrapper<T>>
:public TrivialLoggableDescriptor<ArrayWrapper<T>, type_array>
{};

// Connect std::tuple and std::pair
// All product types share the same type tag
struct tuple_type_tag {};
BINLOG_ENUM_TO_TYPE(tuple_type_tag, type_tuple)

template <typename... Ts>
struct LoggableDescriptor<std::tuple<Ts...>>
  :public TrivialLoggableDescriptor<std::tuple<Ts...>, type_tuple>
{};

template <typename T1, typename T2>
struct LoggableDescriptor<std::pair<T1, T2>>
  :public TrivialLoggableDescriptor<std::pair<T1, T2>, type_tuple>
{};

// All optionals/variants share the same type tag
struct variant_type_tag {};
BINLOG_ENUM_TO_TYPE(variant_type_tag, type_variant)

struct null_type_tag {};
BINLOG_ENUM_TO_TYPE(null_type_tag, type_null)

// Cleanup
#undef BINLOG_CONNECT_TYPE_ENUM
#undef BINLOG_ENUM_TO_TYPE
#undef BINLOG_TYPE_TO_ENUM

// Courtesy of https://github.com/erenon/pipeline
template <typename Container>
class is_container
{
  struct no  {};

  template <typename Container2>
  static decltype(std::declval<Container2>().begin()) hasBegin(int);

  template <typename>
  static no hasBegin(...);

  template <typename Container2>
  static decltype(std::declval<Container2>().end()) hasEnd(int);

  template <typename>
  static no hasEnd(...);

public:
  enum
  {
    value =
       ! std::is_same<no, decltype(hasBegin<Container>(0))>::value
    && ! std::is_same<no, decltype(hasEnd  <Container>(0))>::value
  };
};

template <typename Container>
class is_loggable_container
{
  struct no  {};

  template <typename C2>
  static typename LoggableDescriptor_t<typename C2::value_type>::type
    loggableValue(int);

  template <typename>
  static no loggableValue(...);

public:
  enum
  {
    value =
         is_container<Container>::value
    && ! std::is_same<no, decltype(loggableValue<Container>(0))>::value
  };
};

template <typename T>
struct IntegralLoggableTypeTag
{
  static const type_tag_t type_tag =
      (std::is_signed<T>::value)
    ?
      (sizeof(T) == 1) ? type_8  :
      (sizeof(T) == 2) ? type_16 :
      (sizeof(T) == 4) ? type_32 :
      (sizeof(T) == 8) ? type_64 : type_none
    : (sizeof(T) == 1) ? type_u8 :
      (sizeof(T) == 2) ? type_u16:
      (sizeof(T) == 4) ? type_u32:
      (sizeof(T) == 8) ? type_u64: type_none
    ;
};

template <typename MaybeLoggable>
struct LoggableDescriptor
{
  typedef MaybeLoggable type;
  typedef FieldDescriptor<type, 0> descriptor;
  static const type_tag_t type_tag =
      (std::is_integral<MaybeLoggable>::value)
    ? IntegralLoggableTypeTag<MaybeLoggable>::type_tag
    : (is_loggable_container<MaybeLoggable>::value)
    ? type_array
    : type_none;

  static_assert(type_tag != type_none, "Logging this type is not supported");
};

/**
* BINLOG_TYPE_SWITCH
*
* Time to time, it's necessary to map runtime values to types.
* Specifically, to map type_tag_t values to types.
* AFAICT, returning types based on runtime values is not possible,
* but a switch can emulate something very similar. This ugly
* macro below helps producing such switches and avoid duplicating
* the information of available loggable types.
*
* Usage:
*
* @code
*
* #define BINLOG_TYPE_SWITCH_BODY(TYPE) call_my_typed_func<TYPE>();
*
* switch(typeSpec)
* {
*   BINLOG_TYPE_SWITCH
* }
*
* #undef BINLOG_TYPE_SWITCH_BODY
*
* @endcode
*/

#define BINLOG_TYPE_SWITCH_CASE_TEMPLATE(TAG) \
  case ::binlog::detail::TAG: \
    BINLOG_TYPE_SWITCH_BODY(::binlog::detail::InverseLoggableDescriptor<::binlog::detail::TAG>::type) \
    break; \
  /**/

// switch (typeSpec)
// {
#define BINLOG_TYPE_SWITCH \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_bool)    \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_8)       \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_16)      \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_32)      \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_64)      \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_u8)      \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_u16)     \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_u32)     \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_u64)     \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_float)   \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_double)  \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_string)  \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_struct)  \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_array)   \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_tuple)   \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_variant) \
  BINLOG_TYPE_SWITCH_CASE_TEMPLATE(type_null)    \
/**/
// default:
//    failure();
//    break;
// } // end switch

/*
* Template metafunctions required to create
* FieldDescriptors and GetterDescriptors in a
* homogeneous way
*/

template <typename>
struct member_function_class
{
  typedef void type;
};

template <typename Class, typename Function>
struct member_function_class<Function Class::*>
{
  typedef Class type;
};

template <typename>
struct member_pointer_type;

template <typename T, typename Class>
struct member_pointer_type<T Class::*>
{
  typedef T type;
};

template <typename Getter_, Getter_ getter_>
struct GetterDescriptor
{
  typedef typename member_function_class<Getter_>::type Class;
  typedef decltype((std::declval<Class>().*getter_)()) type;
  typedef Getter_ Getter;
  static const std::size_t offset = 0;
};

/**
* This spec is used in the unused branch of std::contditional
* in FieldOrGetterDescriptor
*/
template <bool IsFunction, typename Field, Field>
struct Offsetof
{
  static const std::size_t value = 0;
};

/** Field is a field */
template <typename Class, typename Field, Field Class::* field>
class Offsetof<false, Field Class::*, field>
{
  /**
   * reinterpret_cast from const char* member pointer rvalue
   * to const char& produces a compile error, use this
   * pseudo_char instead.
   */
  struct pseudo_char {};
  static_assert(sizeof(pseudo_char) == 1, "");

public:
  // look at that offsetof hack. look at it!
  static const std::size_t value =
    reinterpret_cast<std::size_t>(
      & reinterpret_cast<const pseudo_char&>(
        reinterpret_cast<Class*>(1)->*field
      )
    ) - 1;
};

template <typename ScopeExpr, ScopeExpr scopeExpr>
class FieldOrGetterDescriptor
{
  static const bool isFunction = std::is_member_function_pointer<ScopeExpr>::value;
public:
  typedef typename std::conditional<
    isFunction,

    // Getter
    GetterDescriptor<ScopeExpr, scopeExpr>,

    // Field
    FieldDescriptor<
      typename member_pointer_type<ScopeExpr>::type, // field type
      Offsetof<isFunction, ScopeExpr, scopeExpr>::value // field offset
    >
  >::type type;
};

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_ARGUMENTS_H_ */
Attention:  ./lib/binlog/detail/Time.H
#ifndef BINLOG_DETAIL_TIME_H_
#define BINLOG_DETAIL_TIME_H_

#include <cstdint>

namespace binlog {
namespace detail {

/**
* @return the value of TSC
*
* @see http://en.wikipedia.org/wiki/Time_Stamp_Counter
*
* Using TSC is safe if CPU has constant_tsc flag.
*/
inline uint64_t readTsc()
{
  return __builtin_ia32_rdtsc();
}

/**
* @return the frequency of CPU0 in kHz or -1 if failed to get freq.
*/
int getCpufreq();

/**
* Converts TSC value `tsc` to seconds, assuming CPU frequency
* is `cpuFreq`.
*
* @param tsc TSC value to be converted
* @param cpuFreq CPU frequency in kHz
*
* @return Timespan in seconds represented by `tsc`
*/
inline double tscToSeconds(uint64_t tsc, int cpuFreq = getCpufreq())
{
  return (static_cast<double>(tsc) / cpuFreq / 1000);
}

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_TIME_H_ */
Attention:  ./lib/binlog/detail/Queue.H
#ifndef BINLOG_DETAIL_QUEUE_H_
#define BINLOG_DETAIL_QUEUE_H_

#include <cassert>
#include <atomic>
#include <memory>

namespace binlog {
namespace detail {

/*
* Branch hinting.
*
* GCC only.
*
* @see http://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html
*/
#ifdef __GNUC__
  #define binlog_likely(expr) __builtin_expect(expr, true)
#else
  #define binlog_likely(expr) expr
#endif

#ifdef __GNUC__
  #define binlog_unlikely(expr) __builtin_expect(expr, false)
#else
  #define binlog_unlikely(expr) expr
#endif

/**
* Single Producer Single Consumer Bounded Memory Queue
*
* Usage:
*  - Writer thread reserves some memory in queue,
*    writes data to received memory, commits written bytes.
*  - Reader thread checkouts committed memory,
*    reads received data then disposes it to free up queue space.
*
* [Writer] methods must be accessed only from the writer thread
* [Reader] methods from the reader thread.
*
* This class is optimized for speed, it's easy to mess things
* up by calling methods from the wrong thread, wrong order
* or with wrong arguments. Watch out.
*
* @code
* Queue q(256);
*
* // Writer thread
* char* pArena = q.reserve(sizeof(char));
* if (pArena)
* {
*   *pArena = 'A';
*   q.commit(sizeof(char));
* }
*
* // Reader thread
* std::size_t batchSize = 0;
* char* pBatch = q.checkout(batchSize);
*
* if (pBatch)
* {
*   assert(*pBatch == 'A');
*   q.dispose(batchSize);
* }
* @endcode
*
* Internals:
* Queue has a fixed size char array
* and three pointers pointing to various
* parts of this array.
*
* W: `_writeIndex`
* R: `_readIndex`
* E: `_wastedEndBegin`
*
* Initially, the queue is empty:
*  W
* [........................]
*                         R
*                         E
*
* The writer thread can reserve memory of size `s`,
* if the distance of W and R >= s.
*
* After successful reserve, the writer can write
* the allocated memory:
*
*  W
* [######..................]
*                         R
*                         E
*
* (If the reader tries to checkout, nullptr will be returned,
*  there is no data to be read, yet.)
* After the reader commits `s` bytes, the reader pointer advances:
*
*        W
* [######..................]
*                         R
*                         E
*
* After commit, the reader can checkout:
*
*        W
* [######..................]
*       R
*                         E
*
* And things start again. Only if W almost reaches the end:
*
*                      W
* [####################....]
*                         E
*
* If the writer request 10 bytes now, we are in trouble.
* There is no circular memory, we can't allocate 4 bytes at
* the end of the array and 6 at the beginning.
*
* So we just skip the end (-> wasted end), and fast forward
* W to the beginning of the array. (Note: R > 10 must be true)
*
* However, this way the reader will consume the garbage
* at the end of the array. To avoid this, we are setting E
* to the end of valuable data. Like this:
*
*  W
* [####################....]
*                      E
*
* R is not allowed to jump over W and has to jump to 0
* when passing over E.
*/
class Queue
{
  std::atomic<std::size_t> _writeIndex; /**< next index to write */
  std::atomic<std::size_t> _wastedEndBegin; /**< after this index, there's no valid data */

  const std::size_t _size;
  const std::size_t _maxIndex;

  static const int padding_size = 64
    - sizeof(_writeIndex) - sizeof(_wastedEndBegin)
    - sizeof(_size)       - sizeof(_maxIndex);

  char padding[padding_size]; /* force read_index and write_index to different cache lines */
  std::atomic<std::size_t> _readIndex; /**< last index read */

  std::unique_ptr<char[]> _data;

public:
  /**
   * Consturcts a new empty queue
   *
   * @param size Size of the internal buffer in bytes.
   * Will be rounded to the next power of 2, greater than 4.
   */
  Queue(std::size_t size)
    :_writeIndex(0),
     _size(nextPowerTwo(std::max(size, std::size_t{8u}))),
     _maxIndex(_size - 1),
     _readIndex(_size - 1),
     _data(new char[_size])
  {
    _wastedEndBegin = _size - 1;

    // prefault _data
    for (std::size_t i = _maxIndex; i >= 4096; i -= 4096)
    {
      _data[i] = 0;
    }
    _data[0] = 0;
  }

  /** Size of the internal buffer */
  std::size_t size() const
  {
    return _size;
  }

  /** It's not possible to `reserve` a larger chunk */
  std::size_t maxRequestSize() const
  {
    return _size - 1;
  }

  /**
   * [Writer]
   *
   * Allocates `entrySize` bytes in queue.
   *
   * @return pointer to reserved memory or nullptr if not enough memory
   */
  char* reserve(const std::size_t& entrySize)
  {
    std::size_t writeI = _writeIndex.load(std::memory_order_relaxed);
    std::size_t readI = _readIndex.load(std::memory_order_relaxed);

    if (binlog_unlikely(writeI + entrySize >= _size))
    {
      if (writeI > readI)
      {
        // set end buffer pos and skip
        _wastedEndBegin.store(writeI, std::memory_order_relaxed);
        writeI = 0;
      }
      else
      {
        // avoid skipping reader head
        return nullptr;
      }
    }

    if (binlog_likely(readI < writeI || writeI + entrySize <= readI))
    {
      return _data.get() + writeI;
    }
    else
    {
      // not enough free space,
      // let's wait for the reader
      return nullptr;
    }
  }

  /**
   * [Writer]
   *
   * Make previously allocated memory available to the reader
   */
  void commit(const std::size_t& entrySize)
  {
    std::size_t writeI = _writeIndex.load(std::memory_order_relaxed);

    if (binlog_likely(writeI + entrySize < _size))
    {
      _writeIndex.store(writeI + entrySize, std::memory_order_release);
    }
    else
    {
      _writeIndex.store(entrySize, std::memory_order_release);
    }
  }

  /**
   * [Reader]
   *
   * Gets available data to read.
   *
   * Size of available data is written to param `batchSize`,
   * if no data is available `batchSize` remains untouched.
   *
   * @return pointer to data or nullptr if no data is available
   *
   */
  char* checkout(std::size_t& batchSize)
  {
    std::size_t writeI = _writeIndex.load(std::memory_order_acquire);
    std::size_t readI  =
      (_readIndex.load(std::memory_order_relaxed) + 1) & _maxIndex;

    if (readI < writeI)
    {
      batchSize = writeI - readI;
      return _data.get() + readI;
    }
    else if (readI > writeI)
    {
      std::size_t wastedEnd = _wastedEndBegin.load(std::memory_order_relaxed);

      if (readI < wastedEnd)
      {
        batchSize = wastedEnd - readI;
        return _data.get() + readI;
      }
      else
      {
        _readIndex.store(_maxIndex, std::memory_order_relaxed);
        batchSize = writeI;
        return _data.get();
      }
    }
    else
    {
      return nullptr; // queue is empty
    }
  }

  /**
   * [Reader]
   *
   * Recirculates memory previously checked out.
   */
  void dispose(const std::size_t& batchSize)
  {
    std::size_t readI =
      (_readIndex.load(std::memory_order_relaxed) + 1) & _maxIndex;

    _readIndex.store(readI + batchSize - 1, std::memory_order_relaxed);
  }

  /**
   * [Reader]
   *
   * @return true if the queue is empty, false otherwise
   */
  bool empty() const
 {
    std::size_t writeI = _writeIndex.load(std::memory_order_relaxed);
    std::size_t readI =
      (_readIndex.load(std::memory_order_relaxed) + 1) & _maxIndex;

    return readI == writeI;
  }

  /**
   * [Writer]
   *
   * @return number of bytes available for immediate write
   */
  std::size_t writeAvailable() const
  {
    std::size_t writeI = _writeIndex.load(std::memory_order_relaxed);
    std::size_t readI =
      (_readIndex.load(std::memory_order_relaxed) + 1) & _maxIndex;

    std::size_t avail = readI - writeI;
    if (writeI >= readI)
    {
      avail += _size;
    }
    return avail;
  }

private:
  std::size_t nextPowerTwo(std::size_t n)
  {
    --n;
    std::size_t result = 2;
    while (n >>= 1) { result <<= 1; }
    return result;
  }
};

// cleanup branch hinting macros
#undef binlog_likely
#undef binlog_unlikely

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_QUEUE_H_ */
Attention:  ./lib/binlog/detail/Entry.H
#ifndef BINLOG_DETAIL_ENTRY_H_
#define BINLOG_DETAIL_ENTRY_H_

#include <string>
#include <cstring>
#include <vector>

#include <binlog/detail/EntryDefs.H>
#include <binlog/detail/ThreadContext.H>

namespace binlog {
namespace detail {

/**
* Simple abstraction of entries produced by
* loggers and consumed by `Core`.
*
* The class encapsulates a fixed size buffer
* one can append data to. The size is not
* known to the class, there's no bound checking.
*
* The simplicity of this class is motivated
* by performance requirements.
*
* Buffer layout:
* [ std::size_t size | {Payload} ]
*/
class Entry
{
  /*
   * It could be possible to copy Entry objects
   * but semantically incorrect. Let's delete them.
   */

  Entry(const Entry&) = delete;
  Entry& operator=(const Entry&) = delete;

public:
  typedef EntryDefs::entry_size_t entry_size_t;
  typedef EntryDefs::tag_t tag_t;
  typedef EntryDefs::tsc_t tsc_t;

  /**
   * Assign buffer to Entry
   *
   * Buffer will *not* be owned by Entry,
   * it's the responsibility of the caller
   * to keep the buffer as long as the entry.
   *
   * @param data Buffer to assigned
   */
  Entry(char* data)
    :_size(0),
     _data(data)
  {}

  /**
   * Memcopies `source` to the internal buffer
   *
   * @param source The POD type to copy
   */
  template <typename Source>
  void write(const Source& source)
  {
    write(&source, sizeof(Source));
  }

  /**
   * Copy `size` bytes data from `source`
   * to the internal buffer.
   *
   * @param source source buffer
   * @param size length of data to be copied in bytes
   */
  void write(const void* source, std::size_t size)
  {
    std::memcpy(_data + _size, source, size);
    _size += size;
  }

  /**
   * Size of meaningful data in buffer
   *
   * It's the sum of the `size` args passed to `append`
   */
  std::size_t getSize() const
  {
    return _size;
  }

  /**
   * Get encapsulated buffer
   */
  const char* getData() const
  {
    return _data;
  }

  /*
   * Factory methods
   *
   * The following methods could be constructors
   * of subclasses of Entry; LogEntry,
   * TscSync, ThreadProp and HostProp entry respectively.
   *
   * However, to satisfy low latency constraints,
   * entry sizes are calculated before creating the
   * entry and buffers are allocated e.g: in a thread
   * local memory queue (@see `Queue`).
   *
   * When finished, if the memory was allocated by
   * the factory method, it gets committed, making it
   * consumable by `Core`.
   */

  /**
   * Create a log entry and push it to the queue
   *
   * Log entry layout:
   * [
   *   std::size_t size : size of the whole entry
   *   tag_t formatId : incremental event source id + dynamic load address offset
   *   uint64_t tsc : TSC value
   *   [
   *     ? arg_i : event argument of arbitrary size
   *   ]*
   * ]
   */
  template <typename... Args>
  static void createLog(
    const tag_t formatId,
    Args&&... args
  );

  /*
   * The following factory methods assume a
   * well sized preallocated entry.
   */

  /**
   * Create a TSC synchronization entry in place
   *
   * The Reader have to match relative TSC values
   * to absolute wall clock timestamps; this is
   * enabled by periodically emitted sync entries.
   * (TSC skew is also corrected this way)
   *
   * TSC synchronization layout:
   * [
   *   std::size_t size : size of the whole entry
   *   tag_t -X : fixed value
   *   uint64_t tsc : TSC value
   *   time_point t : absolute wall clock time
   *   int64_t tzOffset : Time zone offset, seconds east of UTC
   *   int cpuFreq : CPU frequency in kHz
   * ]
   */
  void writeTSCSync();

  /**
   * Create a Thread Properties entry in place
   *
   * This entry sets the thread properties
   * of the subsequent events -- until the next
   * thread prop entry.
   *
   * The max length of thread name is set by EntryDefs
   *
   * Thread Properties Layout:
   * [
   *   std::size_t size : size of the whole entry
   *   tag_t -X : fixed value
   *   LWP lwp : light-weight process id of the thread
   *   char threadName[N] : fixed length user provided thread name
   * ]
   */
  void writeThreadProp(
    ThreadContext::LWP lwp,
    const char* threadName
  );

  /**
   * Create a Host properties entry in place
   *
   * This entry is used by the Reader to identify
   * the source of the subsequent entries.
   *
   * Host Properties layout:
   * [
   *   std::size_t size : size of the whole entry
   *   tag_t -X : fixed value
   *   cstring hostname : name returned by gethostname()
   * ]
   */
  void writeHostProperties();

private:
  std::size_t _size; /**< Size of meaningful data in `_data` */
  char* _data;  /**< Encapsulated buffer */
};

} // namespace detail
} // namespace binlog

#include <binlog/detail/Entry.HPP>

#endif /* BINLOG_DETAIL_ENTRY_H_ */
Attention:  ./lib/binlog/detail/Error.H
#ifndef BINLOG_DETAIL_ERROR_H_
#define BINLOG_DETAIL_ERROR_H_

#include <sstream>
#include <system_error>

namespace binlog {
namespace detail {
inline namespace error {

enum class Error : int
{
  no_error = 0,
  runtime_error,

  // Configuration
  config_invalid_json,
  config_no_binlog_key,
  config_invalid_severity,
  config_invalid_field,
  config_no_target_for_file,
  config_no_target_for_stream,
  config_invalid_target_for_stream,
  config_invalid_sink,
  config_invalid_predicate,

  // Entry parsing
  end_of_stream,
  invalid_entry_size,
  no_tag_found,
  payload_too_short,
  invalid_type_tag,
  no_string_arg,
  no_struct_id,
  invalid_struct_id,
  no_array_size,
  no_array_type_spec,
  no_tuple_size,
  no_tuple_type_spec,
  no_variant_type_spec,

  // EntryProcessor
  invalid_entry_tag,

  // TscSync
  no_tsc,
  no_time,
  no_timezone,
  no_cpu_freq,

  // EventSource
  no_source_id,
  no_instruction_pointer,
  no_category,
  no_severity,
  no_format_string,
  no_type_codes,
  no_function,
  no_file,
  no_line,
  no_program_code,

  // StructDef
  no_sdef_id,
  no_sdef_name,
  no_sdef_fields,
  no_sdef_field_name,
  no_sdef_field_type,

  // ThreadProp
  no_lwp,
  no_thread_name,

  // HostProp
  no_hostname,

  // ThreadActivity
  no_ta_tsc,

  // EventSourceStream
  no_ess_category_id,
  no_ess_severity,
  no_ess_type_tags,
  no_ess_format_string,

  // EventStream
  invalid_source_id,

  // Custom ELF
  not_binlog_user,
  section_not_found,

  // InputStream
  file_open,
};

/**
* Create corresponding error_code for the given `error`.
*
* Required because std::error_code == Error uses ADL
*/
__attribute__((visibility("default")))
std::error_code make_error_code(Error error);

/**
* Sets `ec` to `error` if `ec` is clear (not set already)
* and returns stream to specify custom error message parts.
*/
__attribute__((visibility("default")))
std::ostream& setError(std::error_code& ec, Error error);

class
__attribute__((visibility("default")))
ErrorCategory : public std::error_category
{
public:
  const char* name() const noexcept;
  std::string message(int ev) const;

private:
  friend std::ostream& setError(std::error_code&, Error);

  std::ostringstream _dynamicMessage;
};

bool checkTrue(bool condition, std::error_code& ec, Error error);

} // namespace error
} // namespace detail
} // namespace binlog

namespace std {

/** std::make_error_code(Error) uses this spec */
template<>
struct is_error_code_enum<binlog::detail::Error> : public true_type
{};

} // namespace std

#endif /* BINLOG_DETAIL_ERROR_H_ */
Attention:  ./lib/binlog/detail/Core.H
#ifndef BINLOG_CORE_H_
#define BINLOG_CORE_H_

#include <vector>
#include <mutex>
#include <atomic>

#include <binlog/detail/ThreadContext.H>
#include <binlog/detail/Entry.H>

namespace binlog {

namespace sink {
  class ConsumerBase;
} // namepace sink

namespace detail {

class WaitStrategy;

namespace test {
  // friend for the sake of testing
  struct CoreFactory;
} // namespace test

/**
* Aggregates entry producing threads
*
* Partly thread safe singleton class.
*
* Entry producers have to report themselves
* explicitly. @see ThreadContext() ctor
*
* Entry consumers call consumeOne to get
* access to the next available buffer.
*/
class
__attribute__((visibility("default")))
Core
{
public:
  /** Get singleton instance */
  static Core& getInstance();

  /**
   * Reports a new entry producing thread
   *
   * Thread safe.
   */
  void reportThread(ThreadContextPtr& threadPtr);

  /**
   * Process the next available buffer
   *
   * Checks the registered entry producers
   * and calls `consumerF` if a read buffer
   * was found.
   *
   * The consumable buffer contains one
   * or more binary entries processable
   * by the Reader.
   *
   * @param consumerF callable, signature:
   *        any(const char*, std::size_t)
  *
   * @return true, if consumerF was called
   *         false otherwise.
   */
  template <typename ConsumerF>
  bool consumeOne(ConsumerF consumerF)
  {
    if (! _recentThreads.empty())
    {
      mergeRecentThreads();
    }

    // Loop a bit until we find a non-empty producer buffer
    std::size_t maxCycle = _threads.size() * 2;
    std::size_t cycle = 0;

    while (cycle < maxCycle)
    {
      if (_nextThread == _threads.end())
      {
        _nextThread = _threads.begin();
      }

      auto& queue = (*_nextThread)->getEntryQueue();

      std::size_t bufferSize;
      const char* buffer = queue.checkout(bufferSize);
      if (buffer)
      {
        auto& threadPropBuf = (*_nextThread)->getThreadPropBuffer();
        consumerF(threadPropBuf.data(), threadPropBuf.size());

        consumerF(buffer, bufferSize);
        queue.dispose(bufferSize);

        ++_nextThread;
        return true;
      }

      ++_nextThread;
      ++cycle;
    }

    removeEmptyQueues();

    // If nothing else was to do, try a tsc sync at least
    char tscSyncBuffer[EntryDefs::tscSyncSize];
    if (writeTscSyncIfNeeded(tscSyncBuffer))
    {
      consumerF(tscSyncBuffer, EntryDefs::tscSyncSize);
      return true;
    }

    return false;
  }

  /**
   * @return true, if there is no queue registered
   *               or those are empty.
   */
  bool empty();

  /**
   * `consumeOne` should be always called by
   * the same consumer.
   *
   * It's an error to have multiple consumers
   * reading the same Core. To avoid this,
   * each consumer should `tryAcquire` the
   * core before consuming, and shouldn't
   * consume if the attempt fails.
   *
   * This is not equivalent to a lock in `consumeOne`.
   * The *lifetime* of the consumers are mutually
   * exclusive -- assuming a singleton Core --
   * and not the calls of `consumeOne`.
   *
   * @return true, if no other consumer was registered
   */
  bool tryAcquire(const sink::ConsumerBase* pConsumer);

  /**
   * Calling this means the consumer leaves
   * the core and lets other consumers consume it.
   *
   * Usually, there is no point to do this,
   * except for testing (or if the consumer
   * changed its mind...)
   *
   * @return true, if `consumer` was registered
   */
  bool tryRelease(const sink::ConsumerBase* pConsumer);

  /**
   * The consumer waits on a WaitStrategy, if there is
   * no buffer to consume. The used WS object should be
   * registered to the Core, @see `notifyConsumer`.
   *
   * @param pWaitStrategy Wait strategy used by the consumer
   * of this.
   */
  void setConsumerWaitStrategy(WaitStrategy* pWaitStrategy);

  /**
   * The producer threads connected to the core notify
   * the consumer by calling this method. The notify call
   * will be forwarded to the registered wait strategy,
   * if any. @see `setConsumerWaitStrategy`
   */
  void notifyConsumer();

private:
  /**
   * Constructor
   *
   * This is called from `getInstance()`.
   * Avoid calling external methods which might
   * call `getInstance()`, because that would
   * result in a deadlock.
   */
  Core();

  /**
   * To avoid locking on the consumer hot path,
   * recently started thread contexts are added
   * to a secondary vector, `_recentThreads`.
   *
   * This method moves `_recentThreads` into `_threads`
   * and clears the former.
   */
  void mergeRecentThreads();

  /** Removes exclusively owned empty producers. */
  void removeEmptyQueues();

  /**
   * Creates a TSC synchronization entry
   * in `target` if the last one was
   * created more than a few seconds ago.
   *
   * @param target Entry will be placed here, size >= EntryDefs::tscSyncSize
   *
   * @return true If a new entry was created
   *         false otherwise
   */
  bool writeTscSyncIfNeeded(char* target);

  /** Container of registered entry producers. */
  typedef std::vector<ThreadContextPtr> ThreadContextContainer;

  std::mutex _recentThreadsMutex; /**< Guards `_recentThreads` */
  ThreadContextContainer _recentThreads; /**< Producers not yet merged */

  ThreadContextContainer _threads; /**< Reported log producer threads */
  ThreadContextContainer::iterator _nextThread; /**< Next thread to check for data */

  std::atomic<const sink::ConsumerBase*> _consumer; /**< The only valid caller of `consumeOne` */
  std::atomic<WaitStrategy*> _consumerWaitStrategy; /**< @see `setConsumerWaitStrategy` */

  friend binlog::detail::test::CoreFactory; /**< Proper singleton testing */
};

} // namespace detail
} // namespace binlog

#endif /* BINLOG_CORE_H_ */
Attention:  ./lib/binlog/detail/Elf.H
#ifndef BINLOG_DETAIL_ELF_H_
#define BINLOG_DETAIL_ELF_H_

#include <string>
#include <system_error>

#include <gelf.h>

#include <binlog/detail/Fd.H>

namespace binlog {
namespace detail {

/**
* Provides convenient OO abstraction
* of Elf_Scn declared in gelf.h.
*
* Only features used by the library
* are exposed through this interface.
*/
class ElfSection
{
public:
  /** Trivial constructor */
  ElfSection(Elf_Scn* section);

  /**
   * Gets size of section
   *
   * @returns section size in bytes
   */
  uint64_t size(std::error_code& ec);

  /**
   * Gets raw data of the section.
   *
   * @param size [out] Size of the data buffer
   */
  void* data(std::size_t& size, std::error_code& ec);

  /**
   * Gets section virtual address
   * at execution (dynamic load address).
   */
  uint64_t address(std::error_code& ec);

private:
  Elf_Scn* _section; /**< section handle */
};

/**
* Represents and Elf file, maybe loaded in the app.
*
* Provides convenient OO abstraction
* of Elf declared in gelf.h.
*
* Only features used by the library
* are exposed through this interface.
*/
class Elf
{
public:
  /**
   * Opens ELF file
   *
   * @param elfPath path to the ELF file
   */
  Elf(const std::string& elfPath, std::error_code& ec);

  /**
   * Opens ELF file
   *
   * @param elfPath path to the ELF file
   * @param loadAddress virtual memory address the object was loaded at
   */
  Elf(const std::string& elfPath, std::size_t loadAddress, std::error_code& ec);

  Elf(Elf&&) = default;

  ~Elf();

  /**
   * Gets section of the represented ELF file
   *
   * @param sectionName e.g: ".text", ".ms.log.message"
   */
  ElfSection getSection(
    const std::string& sectionName,
    std::error_code& ec
  ) const;

  /**
   * @returns true, if represented ELF is an executable
   * (not a shared object or a relocatable file)
   */
  bool isExecutable(std::error_code& ec) const;

  /** Trivial getter */
  std::size_t loadAddress() const { return _loadAddress; }

  /** Trivial setter */
  void loadAddress(std::size_t addr) { _loadAddress = addr; }

  /** Trivial getter */
  const std::string path() const { return _path; }

private:
  std::string _path; /**< path to the represented ELF file */
  Fd _fd; /**< libelf reads this fd pointing to the ELF file */
  ::Elf* _elf = nullptr; /**< native libelf handle */
  std::size_t _loadAddress = 0; /**< memory address if the object is loaded */
};

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_ELF_H_ */
Attention:  ./lib/binlog/detail/WaitStrategy.H
#ifndef BINLOG_DETAIL_WAITSTRATEGY_H_
#define BINLOG_DETAIL_WAITSTRATEGY_H_

#include <chrono>
#include <mutex>
#include <condition_variable>

namespace binlog {
namespace detail {

class WaitStrategy
{
public:
  virtual ~WaitStrategy() {}
  virtual void reset() = 0;
  virtual void wait() = 0;
  virtual void notify() = 0;
};

class
__attribute__((visibility("default")))
SleepWaitStrategy final : public WaitStrategy
{
public:
  SleepWaitStrategy();

  SleepWaitStrategy(
    const std::chrono::milliseconds& minSleepDuration,
    const std::chrono::milliseconds& maxSleepDuration
  );

  /**
   * Resets next sleep duration to the minimum.
   */
  void reset();

  /**
   * Capped exponential backoff sleep.
   */
  void wait();

  /** Noop. Sleep cannot be notified */
  void notify() {}

private:
  /** The first call to `wait()` after a successful read will sleep this much */
  std::chrono::milliseconds _minSleepDuration;

  /** `wait()` won't sleep longer than this */
  std::chrono::milliseconds _maxSleepDuration;

  /** `wait()` will sleep this much */
  std::chrono::milliseconds _nextSleepDuration;
};

class
__attribute__((visibility("default")))
BlockWaitStrategy final : public WaitStrategy
{
public:
  BlockWaitStrategy();
  BlockWaitStrategy(const std::chrono::milliseconds& timeout);

  /** noop */
  void reset() {}

  /**
   * Blocks on `_signal` until
   * notified or `_timeout` expired.
   */
  void wait();

  /** Unblocks waiting */
  void notify();

private:
  std::mutex _mutex;
  std::condition_variable _signal;
  std::chrono::milliseconds _timeout;
};

/**
* Waits for read available on a file descriptor
*
* Uses eventfd if possible or pipe if eventfd is not available.
*/
class
__attribute__((visibility("default")))
PipeWaitStrategy final : public WaitStrategy
{
public:
  PipeWaitStrategy();
  PipeWaitStrategy(const std::chrono::milliseconds& timeout);
  ~PipeWaitStrategy();

  /** Consumes bytes available in `_fdRead` */
  void reset();

  /**
   * Blocks on `_fdRead` until read is available,
   * then consumes it. It's not called when using
   * select/epoll with `promoteToConsumerWaiter`
   */
  void wait();

  /** Writes `_fdWrite`, unblocks waiting read */
  void notify();

  /**
   * Registers itself to Core as a consumer WaitStrategy
   * and returns an fd which will be written if
   * data is ready in the producer queues.
   *
   * Designed for select/epoll usage.
   */
  int promoteToConsumerWaiter();

private:
  int _fdRead;
  int _fdWrite;
  timeval _timeout;
  bool _promoted;
};

} // namespace detail
} // namespace binlog


#endif /* BINLOG_DETAIL_WAITSTRATEGY_H_ */
Attention:  ./lib/binlog/detail/EntryDefs.H
#ifndef BINLOG_DETAIL_ENTRYDEFS_H_
#define BINLOG_DETAIL_ENTRYDEFS_H_

#include <cstddef>
#include <limits>
#include <climits> // HOST_NAME_MAX
#include <chrono>

#include <sys/types.h>

namespace binlog {
namespace detail {

struct EntryDefs
{
  /**
   * Entry size type
   *
   * Every entry knows its size, and this
   * size is the first field of every entry
   * to make processing easier.
   */
  typedef unsigned int entry_size_t;

  /**
   * Entry tag type
   *
   * A log file contains entries of several different entry types.
   * Entries are distinguished by their tags.
   *
   * @see factory methods on generated entry tags
   */
  typedef uint64_t tag_t;

  /**
   * TSC value type
   *
   * Each event has a timestamp of this type,
   * representing the actual TSC.
   */
  typedef uint64_t tsc_t;

  /** Thread name size in thread properties entry */
  static constexpr std::size_t threadNameLen = 32;

  // Size of fixed size entries

  /** TSCSync entry */
  static constexpr std::size_t tscSyncSize =
      sizeof(entry_size_t)
    + sizeof(tag_t)
    + sizeof(tsc_t)
    + sizeof(std::chrono::high_resolution_clock::time_point)
    + sizeof(int64_t) // time zone based offset
    + sizeof(int);     // cpu frequency

  /** Thread properties entry size */
  static constexpr std::size_t threadPropSize =
      sizeof(entry_size_t)
    + sizeof(tag_t)
    + sizeof(pid_t)
    + threadNameLen;

  /** Host properties maximum size */
  static constexpr std::size_t hostPropMaxSize =
      sizeof(entry_size_t)
    + sizeof(tag_t)
    + HOST_NAME_MAX + 1;
};

/**
* Most of the time, the tag of an entry
* is the id of the emitter source (event entries).
* However, there are special entries, distinguished
* by special entry tags, see below.
*
* - TSC synchronization: provides a connection between TSC value and
*   wall clock time.
*
* - Thread Properties: Describes the thread which produced
*   the following entries.
*
* - Event Source: static features of an event emitter.
*
* - Structure Definition: Reflection info about a loggable struct.
*
* - Host Properties: Describes the host machine which produced
*   the following entries.
*
* A namespace is used instead of enum struct to
* get scoping because an enum struct and its base
* type do not mix well.
*/
namespace EntryTag {

enum EntryTag : EntryDefs::tag_t
{
  deprecated_a = std::numeric_limits<EntryDefs::tag_t>::max() - 0,
  tscSync      = std::numeric_limits<EntryDefs::tag_t>::max() - 1,
  deprecated_b = std::numeric_limits<EntryDefs::tag_t>::max() - 2,
  threadProp   = std::numeric_limits<EntryDefs::tag_t>::max() - 3,
  eventSource  = std::numeric_limits<EntryDefs::tag_t>::max() - 4,
  deprecated_c = std::numeric_limits<EntryDefs::tag_t>::max() - 5,
  structDef    = std::numeric_limits<EntryDefs::tag_t>::max() - 6,
  hostProp     = std::numeric_limits<EntryDefs::tag_t>::max() - 7,
  // keep this as last
  smallestSpec = std::numeric_limits<EntryDefs::tag_t>::max() - 7,
};

} // namespace EntryTag

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_ENTRYDEFS_H_ */
Attention:  ./lib/binlog/detail/ArrayWrapper.H
#ifndef BINLOG_DETAIL_ARRAYWRAPPER_H_
#define BINLOG_DETAIL_ARRAYWRAPPER_H_

namespace binlog {

namespace detail {

/**
* Wrap C arrays before logging them
*
* It's not possible to tell the size of a
* C array after it decayed to a pointer.
*
* Binlog therefore needs a size hint to be
* able to log the whole array.
*
* @code
* int iarray[] = {1, 2, 3};
* BINLOG_INFO("An array: {0}", binlog::array(iarray, 3));
* @endcode
*
* It's especially useful when one wants to
* log a non-null terminated C style string.
*/
template <typename T>
struct ArrayWrapper
{
  typedef unsigned aw_size_t;
  typedef T value_type;

  const T* pData;
  const aw_size_t size;

  const T* begin() const { return pData; }
  const T* end()   const { return pData + size; }
};

} // namespace detail

template <typename T>
detail::ArrayWrapper<T> array(
  const T* pData,
  typename detail::ArrayWrapper<T>::aw_size_t size
)
{
  return detail::ArrayWrapper<T>{pData, size};
}

} // namespace binlog

#endif /* BINLOG_DETAIL_ARRAYWRAPPER_H_ */
Attention:  ./lib/binlog/detail/Preamble.H
#ifndef BINLOG_DETAIL_PREAMBLE_H_
#define BINLOG_DETAIL_PREAMBLE_H_

#include <mutex>
#include <vector>

#include <binlog/detail/Elf.H>

namespace binlog {
namespace detail {

namespace test {
  class PreambleFactory;
} // namespace test

/**
* Some entries are special, they are needed by the Reader
* to parse other entries (e.g: EventSource definitions).
*
* When adding a sink on the fly, or doing log rotation,
* such entries are required to be available again.
*
* The preamble consists of such entries.
*/
class
__attribute__((visibility("default")))
Preamble
{
public:
  static Preamble& getInstance();

  /**
   * Add contents to the preamble
   *
   * If the preamble was already consumed at least once,
   * it will also forward the buffer to the TL entry queue.
   */
  void addBuffer(const char* buffer, std::size_t size);

  /**
   * Add details of a loaded ELF using binlog to the preamble
   * to make its details available to the reader.
   */
  void addBinlogUserElf(const Elf& elf);

  /**
   * Calls `consumerF` with the preamble buffer.
   *
   * @param consumerF callable, signature:
   *        any(const char*, std::size_t)
   */
  template <typename ConsumerF>
  void readPreamble(ConsumerF consumerF)
  {
    std::lock_guard<std::mutex> lock(_mutex);

    _forward = true;

    consumerF(_buffer.data(), _buffer.size());
  }

private:
  /** Construct mandatory entries in buffer */
  Preamble();

  void addBuffer(std::lock_guard<std::mutex>&, const char* buffer, std::size_t size);
  void resolveBinlogElf(std::lock_guard<std::mutex>&, const Elf& elf);

  std::mutex _mutex;   /**< Guards the other members */
  std::vector<char> _buffer; /**< Preamble entries */

  /**
   * If true, added buffers will be also placed
   * into the TL entry queue
   */
  bool _forward = false;

  /** Proper singleton testing */
  friend binlog::detail::test::PreambleFactory;
};

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_PREAMBLE_H_ */
Attention:  ./lib/binlog/detail/ThreadContext.H
#ifndef BINLOG_DETAIL_THREADCONTEXT_H_
#define BINLOG_DETAIL_THREADCONTEXT_H_

#include <memory>
#include <array>
#include <atomic>

#include <sys/types.h>

#include <binlog/detail/Queue.H>
#include <binlog/detail/EntryDefs.H>

namespace binlog {
namespace detail {

class
__attribute__((visibility("default")))
ThreadContext
{
public:
  typedef pid_t LWP;
  typedef std::array<char, 32> ThreadName;
  typedef std::array<char, EntryDefs::threadPropSize> ThreadPropBuf;

  ThreadContext();

  // used by ThisThreadContext
  ThreadContext(std::size_t queueSize, LWP lwp, const ThreadName& threadName);

  Queue& getEntryQueue() { return _entryQueue; }
  LWP getLwp() const { return _lwp; }
  const ThreadName& getThreadName() const { return _threadName; }

  const ThreadPropBuf& getThreadPropBuffer() const
  {
    return _threadPropBuf;
  }

  void setName(const std::string& name);

  static void setMinQueueSize(std::size_t minSize);
  static std::size_t getMinQueueSize();

private:
  void initThreadPropBuf();

  static std::atomic<std::size_t> s_minQueueSize;

  Queue _entryQueue;
  LWP _lwp;
  ThreadName _threadName;
  ThreadPropBuf _threadPropBuf;
};

typedef std::shared_ptr<ThreadContext> ThreadContextPtr;

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_THREADCONTEXT_H_ */
Attention:  ./lib/binlog/detail/ElfConfig.H
#ifndef BINLOG_DETAIL_ELFCONFIG_H_
#define BINLOG_DETAIL_ELFCONFIG_H_

#include <memory>

namespace binlog {
namespace detail {

/**
* Configuration of EventSources of the same ELF
*
* Encapsulates some ELF details and
* source specific configuration of
* an ELF object.
*
* Instances of this struct are usually
* global variables defined by macro:
* `BINLOG_DEFINE_ELF`.
*
* Source specific config consists of
* 1 bit for each event source in the ELF,
* the disable flag.
* The source is enabled if the flag is not set.
*
* The config is zeroed by default, which means
* every source is enabled.
*/
class
__attribute__((visibility("default")))
ElfConfig
{
public:
  /**
   * Initializes ELF path, load address
   * and the source config structure,
   * reports itself to main config and preamble.
   */
  ElfConfig();

  /**
   * Removes itself from config.
   */
  ~ElfConfig();

  ElfConfig(ElfConfig&&) = delete;
  void operator=(ElfConfig&&) = delete;

  /** Set source specific settings */
  void enableSource (std::size_t sourceIndex);
  void disableSource(std::size_t sourceIndex);

  /** Get source specific settings */
  bool isSourceEnabled(std::size_t sourceIndex) const;

  /** Getters */
  const std::string& getPath()  const { return _path; }
  std::size_t getMemoryOffset() const { return _memoryOffset; }
  std::size_t getSourceCount()  const { return _sourceConfigSize * 4; }

  /** Translates formatId to source index, specific to the ELF object */
  std::size_t getSourceIndex(std::size_t formatId) const;

private:
  void initSourceConfig(std::size_t size);

  /** _sourceConfig operators */
  void setBit  (std::size_t bitIndex);
  void clearBit(std::size_t bitIndex);
  bool isBitSet(std::size_t bitIndex) const;

  std::string _path;  /**< Path to the ELF file */
  std::size_t _memoryOffset = 0; /**< dynamic load address of the ELF */
  std::size_t _formatIdOffset = 0; /**< := _memoryOffset >> 3 */
  std::unique_ptr<char[]> _sourceConfig; /**< message config structure */
  std::size_t _sourceConfigSize = 0; /**< size of `_sourceConfig` in bytes */
};

// Methods called from the hot path are inline:

inline bool ElfConfig::isSourceEnabled(std::size_t sourceIndex) const
{
  return isBitSet(sourceIndex) == false;
}

inline std::size_t ElfConfig::getSourceIndex(std::size_t formatId) const
{
  return formatId - _formatIdOffset;
}

inline bool ElfConfig::isBitSet(std::size_t bitIndex) const
{
  if (bitIndex / 8 < _sourceConfigSize)
  {
    return _sourceConfig[bitIndex / 8] & (1 << (bitIndex & 7));
  }
  else
  {
    return false; // should not happen
  }
}

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_ELFCONFIG_H_ */
Attention:  ./lib/binlog/detail/generated/ForeachMacro.H
// Generated by generate_foreach_macro.py

#define FOREACH_0(M)
#define FOREACH_1(M,a)                                      ,M(a,0)
#define FOREACH_2(M,a,b)                                    ,M(a,0),M(b,1)
#define FOREACH_3(M,a,b,c)                                  ,M(a,0),M(b,1),M(c,2)
#define FOREACH_4(M,a,b,c,d)                                ,M(a,0),M(b,1),M(c,2),M(d,3)
#define FOREACH_5(M,a,b,c,d,e)                              ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4)
#define FOREACH_6(M,a,b,c,d,e,f)                            ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5)
#define FOREACH_7(M,a,b,c,d,e,f,g)                          ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5),M(g,6)
#define FOREACH_8(M,a,b,c,d,e,f,g,h)                        ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5),M(g,6),M(h,7)
#define FOREACH_9(M,a,b,c,d,e,f,g,h,i)                      ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5),M(g,6),M(h,7),M(i,8)
#define FOREACH_10(M,a,b,c,d,e,f,g,h,i,j)                    ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5),M(g,6),M(h,7),M(i,8),M(j,9)
#define FOREACH_11(M,a,b,c,d,e,f,g,h,i,j,k)                  ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5),M(g,6),M(h,7),M(i,8),M(j,9),M(k,10)
#define FOREACH_12(M,a,b,c,d,e,f,g,h,i,j,k,l)                ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5),M(g,6),M(h,7),M(i,8),M(j,9),M(k,10),M(l,11)
#define FOREACH_13(M,a,b,c,d,e,f,g,h,i,j,k,l,m)              ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5),M(g,6),M(h,7),M(i,8),M(j,9),M(k,10),M(l,11),M(m,12)
#define FOREACH_14(M,a,b,c,d,e,f,g,h,i,j,k,l,m,n)            ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5),M(g,6),M(h,7),M(i,8),M(j,9),M(k,10),M(l,11),M(m,12),M(n,13)
#define FOREACH_15(M,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)          ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5),M(g,6),M(h,7),M(i,8),M(j,9),M(k,10),M(l,11),M(m,12),M(n,13),M(o,14)
#define FOREACH_16(M,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)        ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5),M(g,6),M(h,7),M(i,8),M(j,9),M(k,10),M(l,11),M(m,12),M(n,13),M(o,14),M(p,15)
#define FOREACH_17(M,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)      ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5),M(g,6),M(h,7),M(i,8),M(j,9),M(k,10),M(l,11),M(m,12),M(n,13),M(o,14),M(p,15),M(q,16)
#define FOREACH_18(M,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)    ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5),M(g,6),M(h,7),M(i,8),M(j,9),M(k,10),M(l,11),M(m,12),M(n,13),M(o,14),M(p,15),M(q,16),M(r,17)
#define FOREACH_19(M,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)  ,M(a,0),M(b,1),M(c,2),M(d,3),M(e,4),M(f,5),M(g,6),M(h,7),M(i,8),M(j,9),M(k,10),M(l,11),M(m,12),M(n,13),M(o,14),M(p,15),M(q,16),M(r,17),M(s,18)

#define FOREACH_NO_SEP_0(M)
#define FOREACH_NO_SEP_1(M,a)                                      M(a,0)
#define FOREACH_NO_SEP_2(M,a,b)                                    M(a,0) M(b,1)
#define FOREACH_NO_SEP_3(M,a,b,c)                                  M(a,0) M(b,1) M(c,2)
#define FOREACH_NO_SEP_4(M,a,b,c,d)                                M(a,0) M(b,1) M(c,2) M(d,3)
#define FOREACH_NO_SEP_5(M,a,b,c,d,e)                              M(a,0) M(b,1) M(c,2) M(d,3) M(e,4)
#define FOREACH_NO_SEP_6(M,a,b,c,d,e,f)                            M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5)
#define FOREACH_NO_SEP_7(M,a,b,c,d,e,f,g)                          M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5) M(g,6)
#define FOREACH_NO_SEP_8(M,a,b,c,d,e,f,g,h)                        M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5) M(g,6) M(h,7)
#define FOREACH_NO_SEP_9(M,a,b,c,d,e,f,g,h,i)                      M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5) M(g,6) M(h,7) M(i,8)
#define FOREACH_NO_SEP_10(M,a,b,c,d,e,f,g,h,i,j)                    M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5) M(g,6) M(h,7) M(i,8) M(j,9)
#define FOREACH_NO_SEP_11(M,a,b,c,d,e,f,g,h,i,j,k)                  M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5) M(g,6) M(h,7) M(i,8) M(j,9) M(k,10)
#define FOREACH_NO_SEP_12(M,a,b,c,d,e,f,g,h,i,j,k,l)                M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5) M(g,6) M(h,7) M(i,8) M(j,9) M(k,10) M(l,11)
#define FOREACH_NO_SEP_13(M,a,b,c,d,e,f,g,h,i,j,k,l,m)              M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5) M(g,6) M(h,7) M(i,8) M(j,9) M(k,10) M(l,11) M(m,12)
#define FOREACH_NO_SEP_14(M,a,b,c,d,e,f,g,h,i,j,k,l,m,n)            M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5) M(g,6) M(h,7) M(i,8) M(j,9) M(k,10) M(l,11) M(m,12) M(n,13)
#define FOREACH_NO_SEP_15(M,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)          M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5) M(g,6) M(h,7) M(i,8) M(j,9) M(k,10) M(l,11) M(m,12) M(n,13) M(o,14)
#define FOREACH_NO_SEP_16(M,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)        M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5) M(g,6) M(h,7) M(i,8) M(j,9) M(k,10) M(l,11) M(m,12) M(n,13) M(o,14) M(p,15)
#define FOREACH_NO_SEP_17(M,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)      M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5) M(g,6) M(h,7) M(i,8) M(j,9) M(k,10) M(l,11) M(m,12) M(n,13) M(o,14) M(p,15) M(q,16)
#define FOREACH_NO_SEP_18(M,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)    M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5) M(g,6) M(h,7) M(i,8) M(j,9) M(k,10) M(l,11) M(m,12) M(n,13) M(o,14) M(p,15) M(q,16) M(r,17)
#define FOREACH_NO_SEP_19(M,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)  M(a,0) M(b,1) M(c,2) M(d,3) M(e,4) M(f,5) M(g,6) M(h,7) M(i,8) M(j,9) M(k,10) M(l,11) M(m,12) M(n,13) M(o,14) M(p,15) M(q,16) M(r,17) M(s,18)

#define FOREACH_ARG_0(M,arg)
#define FOREACH_ARG_1(M,arg,a)                                      M(arg,a)
#define FOREACH_ARG_2(M,arg,a,b)                                    M(arg,a),M(arg,b)
#define FOREACH_ARG_3(M,arg,a,b,c)                                  M(arg,a),M(arg,b),M(arg,c)
#define FOREACH_ARG_4(M,arg,a,b,c,d)                                M(arg,a),M(arg,b),M(arg,c),M(arg,d)
#define FOREACH_ARG_5(M,arg,a,b,c,d,e)                              M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e)
#define FOREACH_ARG_6(M,arg,a,b,c,d,e,f)                            M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f)
#define FOREACH_ARG_7(M,arg,a,b,c,d,e,f,g)                          M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f),M(arg,g)
#define FOREACH_ARG_8(M,arg,a,b,c,d,e,f,g,h)                        M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f),M(arg,g),M(arg,h)
#define FOREACH_ARG_9(M,arg,a,b,c,d,e,f,g,h,i)                      M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f),M(arg,g),M(arg,h),M(arg,i)
#define FOREACH_ARG_10(M,arg,a,b,c,d,e,f,g,h,i,j)                    M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f),M(arg,g),M(arg,h),M(arg,i),M(arg,j)
#define FOREACH_ARG_11(M,arg,a,b,c,d,e,f,g,h,i,j,k)                  M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f),M(arg,g),M(arg,h),M(arg,i),M(arg,j),M(arg,k)
#define FOREACH_ARG_12(M,arg,a,b,c,d,e,f,g,h,i,j,k,l)                M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f),M(arg,g),M(arg,h),M(arg,i),M(arg,j),M(arg,k),M(arg,l)
#define FOREACH_ARG_13(M,arg,a,b,c,d,e,f,g,h,i,j,k,l,m)              M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f),M(arg,g),M(arg,h),M(arg,i),M(arg,j),M(arg,k),M(arg,l),M(arg,m)
#define FOREACH_ARG_14(M,arg,a,b,c,d,e,f,g,h,i,j,k,l,m,n)            M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f),M(arg,g),M(arg,h),M(arg,i),M(arg,j),M(arg,k),M(arg,l),M(arg,m),M(arg,n)
#define FOREACH_ARG_15(M,arg,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)          M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f),M(arg,g),M(arg,h),M(arg,i),M(arg,j),M(arg,k),M(arg,l),M(arg,m),M(arg,n),M(arg,o)
#define FOREACH_ARG_16(M,arg,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)        M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f),M(arg,g),M(arg,h),M(arg,i),M(arg,j),M(arg,k),M(arg,l),M(arg,m),M(arg,n),M(arg,o),M(arg,p)
#define FOREACH_ARG_17(M,arg,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)      M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f),M(arg,g),M(arg,h),M(arg,i),M(arg,j),M(arg,k),M(arg,l),M(arg,m),M(arg,n),M(arg,o),M(arg,p),M(arg,q)
#define FOREACH_ARG_18(M,arg,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)    M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f),M(arg,g),M(arg,h),M(arg,i),M(arg,j),M(arg,k),M(arg,l),M(arg,m),M(arg,n),M(arg,o),M(arg,p),M(arg,q),M(arg,r)
#define FOREACH_ARG_19(M,arg,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)  M(arg,a),M(arg,b),M(arg,c),M(arg,d),M(arg,e),M(arg,f),M(arg,g),M(arg,h),M(arg,i),M(arg,j),M(arg,k),M(arg,l),M(arg,m),M(arg,n),M(arg,o),M(arg,p),M(arg,q),M(arg,r),M(arg,s)

#define COUNT_X(P,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,...) t

#define COUNT(P, ...) \
  COUNT_X(P, ##__VA_ARGS__, 19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0)
Attention:  ./lib/binlog/detail/ThisThreadContext.H
#ifndef BINLOG_DETAIL_THISTHREADCONTEXT_H_
#define BINLOG_DETAIL_THISTHREADCONTEXT_H_

#include <memory>

#include <binlog/detail/ThreadContext.H>

namespace binlog {
namespace detail {

class
__attribute__((visibility("default")))
ThisThreadContext
{
  typedef ThreadContext T;

public:
  static T& get()
  {
    return *getSharedPtr();
  }

  static void resetQueue(std::size_t minSize);

private:

  /**
   * Get reference to thread local object
   * wrapped in a shared_ptr.
   *
   * The dynamic linker is not able to merge different instances
   * of the same function static variable if the visibility
   * of the function is hidden, thus default visibility
   * is required to ensure correct singularity of the
   * thread local variable.
   *
   * Because of the [vague linkage][0] of the static variable
   * of an inlined function of a class template, noinline is
   * required, the dynamic linker does not merge vague linked objects.
   *
   * This method is called on the primary hot path. Moving
   * it to a source file would cause GOT/PLT lookups
   * and seriously degrade performance. Check generated ASM
   * after changing this.
   *
   * [0]: http://mentorembedded.github.io/cxx-abi/abi.html#vague
   */
  __attribute__((visibility("default")))
  __attribute__((noinline))
  static std::shared_ptr<T>& getSharedPtr()
  {
    static thread_local std::shared_ptr<T> tPtr = create();
    return tPtr;
  }

  static std::shared_ptr<T> create();
};

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_THISTHREADCONTEXT_H_ */
Attention:  ./lib/binlog/detail/Serialize.H
#ifndef BINLOG_DETAIL_SERIALIZE_H_
#define BINLOG_DETAIL_SERIALIZE_H_

#include <tuple>
#include <string>

#include <binlog/Transform.H>
#include <binlog/detail/Entry.H>
#include <binlog/detail/Arguments.H>

namespace binlog {
namespace detail {

/*
* Arguments of log entries are packed in a tuple.
* We have to sum the size of such arguments and
* serialize them into an entry.
*
* Size and copy are special in case of strings
* and structures, trivial for other types.
*
* For the sake of completeness, every combination
* of const|volatile arguments are supported.
*
* LoggableDescriptor is used to traverse compound
* types (registered structures).
*/

template <typename>
struct is_tuple : public std::false_type {};

template <typename... T>
struct is_tuple<std::tuple<T...>> : public std::true_type {};

template <typename T1, typename T2>
struct is_tuple<std::pair<T1, T2>> : public std::true_type {};

//
// index_sequence
//

template <std::size_t... Is>
struct index_sequence {};

template <typename, typename, typename>
struct index_sequence_cat;

template <std::size_t... N1, std::size_t... N2, std::size_t... N3>
struct index_sequence_cat<
  index_sequence<N1...>,
  index_sequence<N2...>,
  index_sequence<N3...>
> 
{
  using type = index_sequence<
    N1...,
    (sizeof...(N1) + N2)...,
    (sizeof...(N1) + sizeof...(N2) + N3)...
  >;
};

template <std::size_t N>
struct make_index_sequence_: index_sequence_cat<
  typename make_index_sequence_<N / 2>::type,
  typename make_index_sequence_<N / 2>::type,
  typename make_index_sequence_<N % 2>::type
> 
{};

template <>
struct make_index_sequence_<0> { using type = index_sequence<>; };

template <>
struct make_index_sequence_<1> { using type = index_sequence<0>; };

template <std::size_t N>
using make_index_sequence = typename make_index_sequence_<N>::type;

//
// Forward declarations
//

template <typename Loggable>
class SelectSerializer;

template <typename Descriptor>
class DescriptorAction;

template <typename Arg>
std::size_t argumentSerializedSize(/*const*/ Arg& arg);

template <typename Arg>
void serializeArgument(/*const*/ Arg& arg, Entry& entry);

//
// Serializers
//

template <typename Loggable>
struct ArithmeticSerializer
{
  static constexpr std::size_t size(const Loggable&)
  {
    return sizeof(Loggable);
  }

  static void serialize(const Loggable& loggable, Entry& entry)
  {
    entry.write(loggable);
  }
};

template <typename Loggable>
struct ArithmeticSerializer<volatile Loggable>
{
  static constexpr std::size_t size(const volatile Loggable&)
  {
    return sizeof(Loggable);
  }

  static void serialize(const volatile Loggable& loggable, Entry& entry)
  {
    auto&& noVLoggable = static_cast<const Loggable>(loggable);
    entry.write(noVLoggable);
  }
};

template <typename Element>
void writeTypeTag(Entry& entry)
{
  const char typeTag = LoggableDescriptor_t<Element>::type_tag;
  entry.write(typeTag);
}

template <typename Tuple>
class TupleSerializer
{
  static const std::size_t tuple_size = std::tuple_size<Tuple>::value;

  template <std::size_t... Indices>
  static std::size_t elementsSize(const Tuple& tuple, index_sequence<Indices...>)
  {
    using swallow = std::size_t[];

    std::size_t sum = 0;
    (void)swallow{1, (sum += argumentSerializedSize(std::get<Indices>(tuple)))...};
    return sum;
  }

  template <typename... Elements>
  static void writeTypeTags(const std::tuple<Elements...>&, Entry& entry)
  {
    using swallow = int[];
    (void)swallow{1, (writeTypeTag<Elements>(entry), int{})...};
  }

  template <typename... Elements>
  static void writeTypeTags(const std::pair<Elements...>&, Entry& entry)
  {
    using swallow = int[];
    (void)swallow{1, (writeTypeTag<Elements>(entry), int{})...};
  }

  template <std::size_t... Indices>
  static void serializeElements(const Tuple& tuple, index_sequence<Indices...>, Entry& entry)
  {
    using swallow = int[];
    (void)swallow{1, (serializeArgument(std::get<Indices>(tuple), entry), int{})...};
  }

public:
  static std::size_t size(const Tuple& tuple)
  {
    return
    + sizeof(char) // tuple_size
    + tuple_size * sizeof(char) // type_tag_t for each element
    + elementsSize(tuple, make_index_sequence<tuple_size>{});
  }

  static void serialize(const Tuple& tuple, Entry& entry)
  {
    const char tupleSize = tuple_size;
    entry.write(tupleSize);

    writeTypeTags(tuple, entry);
    serializeElements(tuple, make_index_sequence<tuple_size>{}, entry);
  }
};

template <typename Container>
class ContainerSerializer
{
protected:
  typedef typename Container::value_type T;
  typedef typename ArrayWrapper<T>::aw_size_t aw_size_t;
  typedef typename SelectSerializer<T>::type Serializer;

  static const std::size_t preambleSize =
    sizeof(aw_size_t) // size of container
  + sizeof(char);     // type_tag_t of T

public:
  static std::size_t size(const Container& container)
  {
    // simulate array of value_type
    std::size_t size = preambleSize;

    for (auto&& item : container)
    {
      size += Serializer::size(item);
    }

    return size;
  }

  static void serialize(const Container& container, Entry& entry)
  {
    const auto size = aw_size_t(std::distance(container.begin(), container.end()));
    const char typeTag = LoggableDescriptor_t<T>::type_tag;

    entry.write(size);
    entry.write(typeTag);

    for (auto&& item : container)
    {
      Serializer::serialize(item, entry);
    }
  }
};

template <typename Descriptor>
std::size_t fieldSerializedSize(const char* obj)
{
  typedef DescriptorAction<Descriptor> Action;

  return Action::size(obj);
}

template <typename... Descriptors>
std::size_t fieldsSerializedSize(std::tuple<Descriptors...>, const char* obj)
{
  using swallow = std::size_t[];

  std::size_t sum = 0;
  (void)swallow{1, (sum += fieldSerializedSize<Descriptors>(obj))...};
  return sum;
}

template <typename Descriptor>
void serializeField(const char* obj, Entry& entry)
{
  typedef DescriptorAction<Descriptor> Action;

  Action::serialize(obj, entry);
}

template <typename... Descriptors>
void serializeFields(std::tuple<Descriptors...>, const char* obj, Entry& entry)
{
  using swallow = int[];

  (void)swallow{1, (serializeField<Descriptors>(obj, entry),int{})...};
}

template <typename Struct>
class StructSerializer
{
  typedef typename LoggableDescriptor_t<Struct>::descriptor FieldDescs;

public:
  static std::size_t size(const Struct& obj)
  {
    return
      sizeof(typeid_t) // Struct id
    + fieldsSerializedSize(FieldDescs{}, reinterpret_cast<const char*>(&obj));
  }

  static void serialize(const Struct& obj, Entry& entry)
  {
    typeid_t typeId = LoggableDescriptor_t<Struct>::typeId();
    entry.write(typeId);

    serializeFields(FieldDescs{}, reinterpret_cast<const char*>(&obj), entry);
  }
};

template <typename>
class TransformationSerializer;

template <typename Source, typename Target>
class TransformationSerializer<Transformation<Source, Target, false /* not container */>>
{
  typedef Transformation<Source, Target, false> Trafo;
  typedef typename SelectSerializer<Target>::type Serializer;

public:
  static std::size_t size(Trafo& trafo)
  {
    return Serializer::size(trafo.transform(trafo.source));
  }

  static void serialize(Trafo& trafo, Entry& entry)
  {
    Serializer::serialize(trafo.transform(trafo.source), entry);
  }
};

template <typename Source, typename Target>
class TransformationSerializer<Transformation<Source, Target, true /* container */>>
  : private ContainerSerializer<Transformation<Source, Target, true /* container */>>
{
  typedef Transformation<Source, Target, true> Trafo;
  typedef ContainerSerializer<Trafo> Parent;

  typedef typename Parent::Serializer Serializer;
  typedef typename Parent::aw_size_t aw_size_t;

public:
  static std::size_t size(Trafo& trafo)
  {
    std::size_t size = TransformationSerializer::preambleSize;

    for (auto&& item : trafo.source)
    {
      size += Serializer::size(trafo.transform(item));
    }

    return size;
  }

  static void serialize(Trafo& trafo, Entry& entry)
  {
    const auto size = aw_size_t(std::distance(trafo.source.begin(), trafo.source.end()));
    const char typeTag = LoggableDescriptor_t<typename Trafo::value_type>::type_tag;

    entry.write(size);
    entry.write(typeTag);

    for (auto&& item : trafo.source)
    {
      Serializer::serialize(trafo.transform(item), entry);
    }
  }
};

template <typename Serializable>
struct CustomSerializer;

// CustomSerializer specs

template <>
struct CustomSerializer<char*>
{
  static std::size_t size(const char* const& str)
  {
    return strlen(str) + 1;
  }

  static void serialize(const char* const& str, Entry& entry)
  {
    entry.write(str, strlen(str) + 1);
  }
};

template <>
struct CustomSerializer<volatile char*>
{
  static std::size_t size(const volatile char* const& str)
  {
    auto&& noVStr = const_cast<const char* const&>(str);
    return CustomSerializer<char*>::size(noVStr);
  }

  static void serialize(const volatile char* const& str, Entry& entry)
  {
    auto&& noVStr = const_cast<const char* const&>(str);
    CustomSerializer<char*>::serialize(noVStr, entry);
  }
};

template <std::size_t N>
struct CustomSerializer<char[N]>
{
  static std::size_t size(const char[N])
  {
    return N;
  }

  static void serialize(const char str[N], Entry& entry)
  {
    entry.write(str, N);
  }
};

template <>
struct CustomSerializer<std::string>
{
  static std::size_t size(const std::string& str)
  {
    return str.size() + 1;
  }

  static void serialize(const std::string& str, Entry& entry)
  {
    entry.write(str.data(), str.size() + 1);
  }
};

template <>
struct CustomSerializer<volatile std::string>
{
  static std::size_t size(const volatile std::string& str)
  {
    auto&& noVStr = const_cast<const std::string&>(str);
    return CustomSerializer<std::string>::size(noVStr);
  }

  static void serialize(const volatile std::string& str, Entry& entry)
  {
    auto&& noVStr = const_cast<const std::string&>(str);
    CustomSerializer<std::string>::serialize(noVStr, entry);
  }
};

template <typename Loggable>
class SelectSerializer
{
  typedef typename std::remove_reference<Loggable>::type NoRefT;
  typedef typename remove_pointer_const<
    typename std::remove_const<NoRefT>::type
  >::type NoCRefT;
  typedef typename no_cv<NoRefT>::type NoCVRefT;

  template <typename Serializer, typename T>
  class is_serializer
  {
    template <typename U>
    static U& declref() noexcept;

    template <typename S2>
    static decltype(S2::size(declref<T>())) hasSize(int);

    template <typename>
    static long hasSize(...);

    template <typename S2>
    static decltype(S2::serialize(declref<T>(), declref<Entry>())) hasSerialize(int);

    template <typename>
    static long hasSerialize(...);

  public:
    enum
    {
      value = std::is_same<std::size_t, decltype(hasSize<Serializer>(0))>::value
           && std::is_same<void,   decltype(hasSerialize<Serializer>(0))>::value
    };
  };

  template <typename InvalidType>
  struct InvalidSerializer
  {
    static_assert(sizeof(InvalidType) == 0, "No serialization method is defined for this type");
    static std::size_t size(const InvalidType&); // Declare these to get shorter compile errors
    static void serialize(const InvalidType&, Entry&);
  };

public:
  typedef

    typename std::conditional<
    is_serializer<CustomSerializer<NoCRefT>, NoCRefT>::value, CustomSerializer<NoCRefT>,

    typename std::conditional<
    std::is_arithmetic<NoRefT>::value, ArithmeticSerializer<NoRefT>,

    typename std::conditional<
    is_tuple<NoCRefT>::value, TupleSerializer<NoCRefT>,

    typename std::conditional<
    is_loggable_container<NoCRefT>::value, ContainerSerializer<NoRefT>,

    typename std::conditional<
    is_transformation<NoCVRefT>::value, TransformationSerializer<NoCVRefT>,

    typename std::conditional<
    LoggableDescriptor_t<Loggable>::type_tag == type_struct, StructSerializer<NoRefT>,

    // default:
    InvalidSerializer<NoCRefT>

    >::type>::type>::type>::type>::type>::type type;
};

//
// DescriptorAction
//

// Descriptor of a field
template <typename Field, std::size_t Offset>
class DescriptorAction<FieldDescriptor<Field, Offset>>
{
  typedef typename SelectSerializer<Field>::type Serializer;

public:
  static std::size_t size(const char* source)
  {
    return Serializer::size(
      *reinterpret_cast<const Field*>(source + Offset)
    );
  }

  static void serialize(const char* source, Entry& entry)
  {
    Serializer::serialize(
      *reinterpret_cast<const Field*>(source + Offset),
      entry
    );
  }
};

// Descriptor of a getter
template <typename Getter, Getter getter>
class DescriptorAction<GetterDescriptor<Getter, getter>>
{
  typedef GetterDescriptor<Getter, getter> Descriptor;
  typedef typename Descriptor::type Field;
  typedef typename Descriptor::Class Class;
  typedef typename SelectSerializer<Field>::type Serializer;

public:
  static std::size_t size(const char* source)
  {
    const Class* pc = reinterpret_cast<const Class*>(source);
    auto&& field = (pc->*getter)();
    return Serializer::size(field);
  }

  static void serialize(const char* source, Entry& entry)
  {
    const Class* pc = reinterpret_cast<const Class*>(source);
    auto&& field = (pc->*getter)();
    Serializer::serialize(field, entry);
  }
};

template <typename Arg>
std::size_t argumentSerializedSize(/*const*/ Arg& arg)
{
  typedef typename SelectSerializer<Arg>::type Serializer;
  return Serializer::size(arg);
}

template <typename Arg>
void serializeArgument(/*const*/ Arg& arg, Entry& entry)
{
  typedef typename SelectSerializer<Arg>::type Serializer;

  Serializer::serialize(arg, entry);
}

//
// INTERFACE
//

// Args is a pack of log arguments

template <typename... Args>
std::size_t argumentsSerializedSize(Args&&... args)
{
  using swallow = std::size_t[];

  std::size_t sum = 0;
  (void)swallow{1, (sum += argumentSerializedSize(args))...};
  return sum;
}

template <typename... Args>
void serializeArguments(Entry& entry, Args&&... args)
{
  using swallow = int[];

  (void)swallow{1, (serializeArgument(args, entry), int{})...};
}

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_SERIALIZE_H_ */
Attention:  ./lib/binlog/detail/Fd.H
#ifndef BINLOG_DETAIL_FD_H_
#define BINLOG_DETAIL_FD_H_

#include <unistd.h>  // close

namespace binlog {
namespace detail {

/**
* Simple RAII wrapper around a file descriptor
* closable with close()
*
* This class could be extended to support custom
* close functions similar to the Deleter of std::unique_ptr.
*/
class
__attribute__((visibility("default")))
Fd
{
public:
  /** Initialize empty state */
  Fd() = default;

  /** Take ownership of `fd` */
  explicit Fd(int fd) : _fd(fd) {}

  /**
   * Disable copy and assign.
   *
   * We could use dup() here instead,
   * but usually it's not something
   * we'd like to do.
   */
  Fd(const Fd&) = delete;
  void operator=(const Fd&) = delete;

  /** Transform state, leave `rhs` empty */
  Fd(Fd&& rhs) : _fd(rhs._fd) { rhs._fd = -1; }

  /** Reset state if any, move `rhs` */
  Fd& operator=(Fd&& rhs)
  {
    close();
    _fd = rhs._fd;
    rhs._fd = -1;
    return *this;
  }

  /** Reset state if any, take ownership of `fd` */
  Fd& operator=(int fd)
  {
    close();
    _fd = fd;
    return *this;
  }

  /** Close owned file descriptor if any */
  ~Fd() { close(); }

  /**
   * Close owned file descriptor if it
   * seems to be a valid one.
   */
  void close()
  {
    if (_fd >= 0)
    {
      ::close(_fd);
      _fd = -1;
    }
  }

  /** @returns true if owns a valid file descriptor */
  explicit operator bool() const
  {
    return (_fd >= 0);
  }

  /** @returns the owned file descriptor */
  int operator*() const { return _fd; }

private:
  int _fd = -1; /**< The wrapped file desciptor */
};

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_FD_H_ */
Attention:  ./lib/binlog/detail/Pattern.H
#ifndef BINLOG_DETAIL_PATTERN_H_
#define BINLOG_DETAIL_PATTERN_H_

#include <string>

namespace binlog {
namespace detail {

/**
* Simple wildcard pattern matching/replacing
*
* Allowed wildcard: *
* * matches anything, in a non-greedy/lazy way, like regex `.*?`
*/
class
__attribute__((visibility("default")))
Pattern
{
public:
  Pattern(const std::string& pattern);

  /**
   * Match pattern
   *
   * At the end of the pattern an implicit * is assumed.
   *
   * E.g: "foo/biz/baz" matches "foo/b*z/b" and "foo" and "foo/b*"
   * but not "biz/b*" or "foo*z/"
   *
   * @returns true, if `input` matches pattern, false otherwise
   */
  bool matches(const std::string& input) const;

  /**
   * Replace pattern
   *
   * Replace the first occurrence of the represented pattern
   * in `input` by `replacement`.
   *
   * E.g:
   * assuming pattern is 'bar\*', replacement is 'rep':
   * foo\bar\baz -> foo\rep
   * foo\baz\baz -> foo\baz\baz
   *
   * @returns true, if `input` was changed, false otherwise
   */
  bool replace(std::string& input, const std::string& replacement) const;

private:
  std::string _pattern;
};

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_PATTERN_H_ */
Attention:  ./lib/binlog/detail/asm.H
#ifndef BINLOG_DETAIL_ASM_H_
#define BINLOG_DETAIL_ASM_H_

#include <cstdlib> // std::size_t

#include <boost/preprocessor/stringize.hpp>
#include <boost/preprocessor/cat.hpp>
#include <boost/preprocessor/tuple/rem.hpp>
#include <boost/preprocessor/control/if.hpp>

#include <binlog/detail/Arguments.H>
#include <binlog/detail/generated/ForeachMacro.H>

namespace binlog {
namespace detail {

/*
* Behold, the core of Binlog, where the magic happens.
*
* To understand the motivation behind this code
* (compile time Event Source id generation),
* please refer to the Developer Manual.
*
* The quirks of the asm blocks are described in the GCC docs:
*  - gcc.gnu.org/onlinedocs/gcc/Basic-Asm.html
*  - gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html
*
* For reference on the asm directives, check the GAS doc:
*  - https://sourceware.org/binutils/docs/as/Pseudo-Ops.html
*
* The easiest way to understand this code is to produce a preprocessed
* example first by compiling on of the example programs with -E.
* The second step should be to use -S and -fverbose-asm.
*/

/**
* Taking the address of a label is simple:
* > lea label, %%(r|e)ax
* For example on x86:
* > leal 1b, %0 ; takes the address of label '1', found _b_efore
*
* This construct is also valid on x86_64, however, it produces
* an R_X86_64_32S relocation, which is incompatible with -fPIC,
* thus cannot be used in shared objects. To workaround this,
* we are using RIP relative addressing instead:
* > leaq 1b(%%rip), %0 ; works well
*/
#if defined __x86_64__
  #define GET_LABEL_ADDR(label, output) \
    "leaq " label "(%%rip)," output "\n"
#else
  #define GET_LABEL_ADDR(label, output) \
    "leal " label "," output "\n"
#endif

#define FOREACH(m,...)                                                     \
  BOOST_PP_CAT(FOREACH_,COUNT(m, ##__VA_ARGS__))(m, ## __VA_ARGS__)        \
  /**/

#define FOREACH_NO_SEP(m,...)                                              \
  BOOST_PP_CAT(FOREACH_NO_SEP_,COUNT(m, ##__VA_ARGS__))(m, ## __VA_ARGS__) \
  /**/

#define FOREACH_WITH_ARG(m,arg,...)                                          \
  BOOST_PP_CAT(FOREACH_ARG_,COUNT(m, ##__VA_ARGS__))(m, arg, ## __VA_ARGS__) \
  /**/

/*
* The following constructs are used in macro
* `BINLOG_MESSAGE_ID` to build a asm block
* placeholder strings and arguments.
*/

#define ASM_TYPE_TEMPLATE(_,idx) "%c[param_type" BOOST_PP_STRINGIZE(idx) "], "

#define ASM_TYPE_PARAM(val,idx)                                     \
  [BOOST_PP_CAT(param_type,idx)] "i" (                              \
    ::binlog::detail::LoggableDescriptor_t<decltype(val)>::type_tag \
  )

/**
* Create category id
*
* Puts the given category id (e.g: meta_proj_cat)
* and the given description into the .ms.log.category ELF section.
*
* The address of this entry will be later used as the
* category identifier.
*
* .ms.log.category layout:
* [<id><0><description><0>]*
*/
#define BINLOG_CATEGORY_ID(id,description)                       \
  __asm__                                                        \
  (                                                              \
    ".pushsection \".ms.log.category\",\"G\",$mslog.category$" BOOST_PP_STRINGIZE(id)   \
      ",comdat"                                            "\n"  \
    "$mslog.category$" BOOST_PP_STRINGIZE(id) ":"          "\n"  \
    ".asciz" BOOST_PP_STRINGIZE(BOOST_PP_STRINGIZE(id))    "\n"  \
    ".ascii" BOOST_PP_STRINGIZE(description)               "\n"  \
    ".byte 0" /* description closing zero */               "\n"  \
    ".globl $mslog.category$" BOOST_PP_STRINGIZE(id)       "\n"  \
    ".size $mslog.category$" BOOST_PP_STRINGIZE(id) ","          \
      ". -" "$mslog.category$" BOOST_PP_STRINGIZE(id)      "\n"  \
    ".popsection"                                          "\n"  \
  );                                                             \
  /**/

/**
* Create message id
*
* Puts events source info into the .ms.log.message ELF section.
*
* @param category A valid category id, @see BINLOG_CATEGORY_ID.
* @param severity Severity of the event source
* @param format Format string, e.g: "Log message: {0}"
* @param ... arguments, their types will be used
*
* .ms.log.message layout:
* [
*  <category_addr> : two bytes
*  <severity> : two bytes
*  <format string> : null terminated string
*  [
*    <arg_i_typeid> : single byte arg type info, @see Arguments.H
*  ]*
*  <closing zero> : single byte
* ]*
*
* .ms.log.descriptor layout:
* [
*  <source_begin> : 4 bytes, points to the beginnig of the respective entry in `.ms.log.message`
*  <rip>   : 4 bytes, offset address of the lea instr., used to get func/file/line from debug info
* ]*
*
* `.ascii format` must be in a separate, Basic Asm block (one without args),
* because curly braces (the dialect specifiers) are stripped in Extended Asm blocks.
*
* `.ascii` is used instead of `asciz`, because of formats specified by multiple
* string literals concatenated automatically.
*
* Matching .[push,pop]section directives should be in the same asm block: the
* compiler might inject code between them (e.g: when using --coverage)
* resulting in invalid section data and code.
*
* Unused __COUNTER__: The compiler might judge the last asm block redundant
* in some cases (e.g: if/else), and merge some of them. To avoid this,
* a dummy __COUNTER__ argument is used which makes them unique.
*
* Instruction lea is used to get the format address.
*
* After the last asm block, `_binlog_id` will hold the address of the first long
* of this entry in the descriptor section. Since there are two longs (8 bytes)
* in this section for each entry, shifting `_binlog_id` by 3 we get a nice consecutive id.
*
* To avoid shadowing user variables passed in `...`, every local variable
* defined here must use the `_binlog_` prefix.
*/
# define BINLOG_MESSAGE_ID(category,severity,format,...)\
  ({                                                    \
    std::size_t _binlog_id = 0;                         \
    __asm__ __volatile__                                \
    (                                                   \
      ".pushsection \".ms.log.message\",\"?\",@progbits"              "\n"  \
      "0:"                                              \
      ".short $mslog.category$" BOOST_PP_STRINGIZE(category)          "\n"  \
      ".short %c[sev]"                          "\n"    \
      ".byte " FOREACH_NO_SEP(ASM_TYPE_TEMPLATE , ## __VA_ARGS__) "0" "\n"  \
      ".popsection"                             "\n"    \
        : : [sev] "i"(severity)                         \
        FOREACH(ASM_TYPE_PARAM, ## __VA_ARGS__)         \
    );                                                  \
    __asm__ __volatile__                                \
    (                                                   \
      ".pushsection \".ms.log.message\",\"?\",@progbits"              "\n"  \
      ".ascii " BOOST_PP_STRINGIZE(format)      "\n"    \
      ".byte 0" /* format closing zero */       "\n"    \
      ".popsection"                             "\n"    \
    );                                                  \
    __asm__ __volatile__                                \
    (                                                   \
      ".pushsection \".ms.log.descriptor\",\"?\",@progbits"           "\n"  \
      "1:"                                      "\n"    \
      ".long 0b"                                "\n"    \
      ".long 2f"                                "\n"    \
      ".popsection"                             "\n"    \
      "2:"                                      "\n"    \
      GET_LABEL_ADDR("1b", "%0")                        \
      : "=r"(_binlog_id)                                \
      : [cnt] "i" (__COUNTER__) /* @see doc above */    \
    );                                                  \
    (_binlog_id >> 3);                                  \
  })                                                    \
  /**/


//
// Structure introspection
//

// decltype is not able to grok unresolved overload,
// let's give it a hand and explain what we want.

template <typename Class, typename Field>
Field Class::* resolveOverload(Field Class::*);

template <typename Class, typename Ret>
auto resolveOverload(Ret (Class::*getter)() const) -> decltype(getter);

// CLASS must be a parenthesized type name
#define FIELD_DESCRIPTOR_TEMPLATE(CLASS, FIELD)        \
  typename FieldOrGetterDescriptor<                    \
    decltype(resolveOverload(                          \
    & BOOST_PP_TUPLE_REM_CTOR(CLASS)::FIELD)),         \
    & BOOST_PP_TUPLE_REM_CTOR(CLASS)::FIELD            \
  >::type                                              \
  /**/

/**
* Double stringize the argument while expanding it.
*
* e.g: foo -> "\"foo\""
*
* This behavior is required by .ascii and asciz directives
* in asm blocks.
*/
#define ASM_STRINGIZE_P(str) #str
#define ASM_STRINGIZE(str) ASM_STRINGIZE_P(#str)

/**
* Double stringize variadic number of arguments
* while expanding them, and intersperse commas.
*
* e.g: Foo<int, int> -> "\"Foo<int\"" "," "\"int>\""
*/
#define ASM_STRINGIZE_CONCAT(str, idx) BOOST_PP_STRINGIZE(BOOST_PP_IF(idx, ",",) # str)
#define ASM_STRINGIZE_VP(...) FOREACH_NO_SEP(ASM_STRINGIZE_CONCAT, ## __VA_ARGS__)
#define ASM_STRINGIZE_V(...) ASM_STRINGIZE_VP(__VA_ARGS__)

#define ASM_FIELD_DESC_TEMPLATE(name, idx)                                                      \
  static_assert(                                                                                \
    LoggableDescriptor_t<typename std::tuple_element<idx, descriptor>::type::type>::type_tag != type_none,\
    "Member of struct is not loggable. Missing BINLOG_MAKE_LOGGABLE?"                           \
  );                                                                                            \
  __asm__ __volatile__                                                                          \
  (                                         \
    ".pushsection \".ms.log.struct\",\"?\",@progbits" "\n" \
    ".asciz " ASM_STRINGIZE(name)      "\n" \
    ".byte "  "%c0"  /* type id */     "\n" \
    ".popsection"                      "\n" \
    :                                       \
    : "i" ( LoggableDescriptor_t<typename std::tuple_element<idx, descriptor>::type::type>::type_tag ) \
  );                                                                                            \
  /**/

/**
* Creates the appropiate LoggableDescriptor specialization
* for the given class to support logging.
*
* @param CLASS parenthesized name of the custom loggable type
* @param ... loggable field names of the type
*
* `CLASS` must have a standard layout because
* serialization is done by memcpy from an offset,
* and using offsetof on a non standard layout type is undefined.
* However, we do not static_assert on it, because it 'works' anyway.
*
* @see http://en.cppreference.com/w/cpp/concept/StandardLayoutType
*
* The parens around CLASS is required to be able to receive type
* names containing comas, e.g: Foo<int, int>. Without the parens,
* the preprocessor would split the name along the commas.
* Please note, using BOOST_PP_COMMA or equivalent is not an option,
* when passing the argument through subsequent macros.
*
* The layout of the created .ms.log.struct ELF section:
* [
*  <class_name> : null terminated string
*  <filed_count> : 1 byte
*  [
*    <field_name> : null terminated string
*    <field_type_id> : single byte arg type info, @see Arguments.H
*  ] <field_count> times
* ]*
*/
#define BINLOG_UNQUALIFIED_MAKE_LOGGABLE(CLASS, ...)           \
  struct LoggableDescriptor<BOOST_PP_TUPLE_REM_CTOR(CLASS)>    \
  {                                                            \
    static const type_tag_t type_tag = type_struct;            \
                                                               \
    typedef BOOST_PP_TUPLE_REM_CTOR(CLASS) type;               \
                                                               \
    typedef std::tuple<                                        \
      FOREACH_WITH_ARG(FIELD_DESCRIPTOR_TEMPLATE, CLASS, ## __VA_ARGS__) \
    > descriptor;                                              \
                                                               \
    static std::size_t typeId()                                \
    {                                                          \
      std::size_t id = 0;                                      \
                                                               \
      __asm__ __volatile__                                     \
      (                                                        \
        ".pushsection \".ms.log.struct\",\"?\",@progbits" "\n" \
        "1:"                                                   \
        ".ascii " ASM_STRINGIZE_V(BOOST_PP_TUPLE_REM_CTOR(CLASS)) "\n"   \
        ".byte " "0"   /* closing zero of class name */   "\n" \
        ".byte " "%c1" /* field count */                  "\n" \
        ".popsection"                                     "\n" \
        "2:"                                              "\n" \
        GET_LABEL_ADDR("1b", "%0")                             \
        : "=r" (id)                                            \
        : "i" (COUNT(x, ## __VA_ARGS__))                       \
      );                                                       \
                                                               \
      /* for each field, write name and type */                \
      FOREACH_NO_SEP(ASM_FIELD_DESC_TEMPLATE, ## __VA_ARGS__)  \
                                                               \
      return id;                                               \
    }                                                          \
  };                                                           \
  /**/

/**
* @param CLASS must be a non-parenthesized type name
* @see BINLOG_UNQUALIFIED_MAKE_LOGGABLE
*/
#define BINLOG_MAKE_LOGGABLE(CLASS, ...)                       \
  namespace binlog { namespace detail {                        \
    template <>                                                \
    BINLOG_UNQUALIFIED_MAKE_LOGGABLE((CLASS), ## __VA_ARGS__)  \
  }} /* namespace binlog::detail */                            \
  /**/

} // namespace detail
} // namespace binlog


#endif /* ASM_H_ */
Attention:  ./lib/binlog/sink/AnySink.H
#ifndef BINLOG_SINK_ANYSINK_H_
#define BINLOG_SINK_ANYSINK_H_

#include <binlog/sink/Sink.H>

namespace binlog {
namespace sink {

/**
* Non-owning Sink type erasure
*
* Use-case: Consumer<S> keeps S by value.
* If the type of S is not known compile time,
* this class can be useful.
*
* However, this class is not designed to
* replace the underlying sink while the
* consumer runs.
*
* AnySink does not take ownership of the
* sink set by setSink()
*/
class
__attribute__((visibility("default")))
AnySink final : public Sink
{
public:
  AnySink() = default;
  AnySink(Sink& sink) : _sink(&sink) {}

  /** Set `_sink` to sink and add preamble */
  void setSink(Sink& sink);

  void operator()(const char* buffer, std::size_t size)
  {
    if (_sink)
    {
      (*_sink)(buffer, size);
    }
  }

  void afterConsume()
  {
    if (_sink)
    {
      _sink->afterConsume();
    }
  }

private:
  Sink* _sink = nullptr;
};

} // namespace sink
} // namespace binlog

#endif /* BINLOG_SINK_ANYSINK_H_ */
Attention:  ./lib/binlog/sink/FileSink.H
#ifndef BINLOG_SINK_FILESINK_H_
#define BINLOG_SINK_FILESINK_H_

#include <string>
#include <atomic>
#include <chrono>

#include <binlog/sink/Sink.H>
#include <binlog/detail/Fd.H>

namespace binlog {
namespace sink {

/**
* Receives binary log buffers and writes them
* to a file.
*
* Supports file size and age based log rotation.
* If log rotation is enabled, the current
* log file will always use the name
* specified by `logfile`.
*
* Rotated files will have the name `logfile`.n,
* the smaller `n` values denote older files.
*
* If enabled, compresses rotated logfiles.
* Compression is disabled by default.
*/
class
__attribute__((visibility("default")))
FileSink final : public Sink
{
public:
  /**
   * Constructs valid file sink or throws
   *
   * Adds #!/path/to/Reader to the beginnig
   * of the file. @see BINLOG_READER_BINARY.
   *
   * chmod +x is applied to the output file.
   *
   * If `logfile` exists, it tries to rename it
   * by adding a '.' and a number to form a unique name.
   * If compression is enabled, the moved file
   * will be compressed.
   *
   * @param logfile path to the log file
   * @throw std::runtime_error if failed to open `logfile`
   */
  FileSink(const std::string& logfile);

  FileSink(FileSink&& rhs);

  FileSink(const FileSink&) = delete;
  FileSink& operator=(const FileSink&) = delete;
  FileSink& operator=(FileSink&&) = delete;

  // Sink interface

  /** Consumer method */
  void operator()(const char* buffer, std::size_t size);

  /** Flushes the output file, initiates rotation if needed */
  void afterConsume();

  /**
   * Sets log rotation criteria.
   *
   * Log file will be rotated if it reaches the
   * specified limit. The limit is a lower boundary only,
   * depending on the workload, the resulting files could
   * be slightly larger than the specified limit.
   *
   * Setting the limit to 0 disables this kind of rotation.
   *
   * @param fileSizeLimit file size limit in bytes
   */
  void rotateBySize(std::size_t fileSizeLimit);

  /**
   * Sets log rotation criteria.
   *
   * Log file will be rotated if it gets older than
   * the specified limit. The limit is a lower boundary only,
   * depending on the workload, the rotation could be late.
   *
   * Setting this limit to std::chrono::seconds::zero()
   * disables this kind of rotation.
   *
   * @param elapsedTimeLimit log file age limit
   */
  void rotateByTime(std::chrono::seconds elapsedTimeLimit);

  /**
   * @param enable enables compression if true, disables otherwise
   */
  void compression(bool enable);

private:
  typedef std::chrono::steady_clock clock;

  bool open(const std::string& logfile);
  bool rotate();

  std::string _path;   /**< Path to the output file */
  detail::Fd _logfile; /**< Output file fd */
  unsigned _nextIndex = 0; /**< Next name index to try if rotation occurs */
  unsigned _compressionLevel = 0; /**< Compression level of rotated files, 0 means disabled */

  std::size_t _bytesWritten = 0; /**< to _path, since the last rotation attempt */
  clock::time_point _lastRotation; /**< Date of the last rotation attempt */

  // Rotation occurs if one of the following limits are
  // non-zero and reached by the above counters
  std::atomic<std::size_t> _fileSizeLimit;
  std::atomic<std::chrono::seconds> _fileAgeLimit;
};

} // namespace sink
} // namespace binlog

#endif /* BINLOG_SINK_FILESINK_H_ */
Attention:  ./lib/binlog/sink/MultiSink.H
#ifndef BINLOG_SINK_MULTISINK_H_
#define BINLOG_SINK_MULTISINK_H_

#include <string>
#include <vector>
#include <mutex>
#include <functional>

#include <boost/container/flat_map.hpp>
#include <boost/container/flat_set.hpp>

#include <binlog/sink/Sink.H>

#include <binlog/reader/entry/Entry.H>
#include <binlog/reader/entry/EventSource.H>

namespace binlog {
namespace sink {

/**
* Multiplexes binary entries to
* registered sinks with predicate based
* filtering.
*
* The predicate is EventSource -> bool.
* It decides whether events emitted by
* a specific event source should be routed
* to the sink. The predicate will be evaluated
* for each EventSource, but not for the entries.
*
* The predicate callback must remain valid until
* MultiSink is valid.
*
* @see EventSource
*/
class
__attribute__((visibility("default")))
MultiSink final : public Sink
{
  typedef binlog::reader::entry::Entry Entry;
public:
  // Sink interface

  /**
   * Consumes entries in `buffer` and forwards them
   * to the added sinks. Special entries are received
   * by every sink. Other entries are forwarded only
   * if the sink is enabled and its predicate enabled
   * the EventSource of the event.
   */
  void operator()(const char* buffer, std::size_t size);

  /** Calls `afterConsume` of every sink. */
  void afterConsume();

  // MultiSink specific interface

  /** Type of the argument the EventSourcePredicate receives */
  typedef binlog::reader::entry::EventSource EventSource;

  /** Predicate for filtering EventSources when adding sinks */
  typedef std::function<bool(const EventSource&)> EventSourcePredicate;

  /** Type of the data structure used to describe sinks */
  typedef std::string SinkDescription;

  /**
   * Add sink
   *
   * The given sink will receive every special entry and every
   * event emitted by an event source enabled by `predicate`.
   *
   * Attaches the given `description` to the sink
   * to be queried later by `getSinkDescriptions()`.
   *
   * Does not take ownership of `sink`.
   */
  void addSink(
    Sink& sink,
    const EventSourcePredicate& predicate,
    const SinkDescription& description = {}
  );

  /** Removes `sink` @return true, if sink was added */
  bool removeSink(const Sink& sink);

  /**
   * Temporarily disables sink
   *
   * The disabled sink will receive special entries only,
   * but shouldn't produce any output.
   *
   * @param sink previously added sink to toggle
   * @param enable `sink` will be enabled if true, disabled if false.
   * @return true on success, false if `sink` not found
   */
  bool toggleSink(const Sink& sink, bool enable);

  /**
   * @return Descriptions of attached sinks
   */
  std::vector<SinkDescription> getSinkDescriptions();

private:

  std::mutex _mutex; /**< Guards every other field */

  // EventSource processing

  void processEventSource(
    const char* buffer, std::size_t size,
    std::lock_guard<std::mutex>& // assumes `_mutex` is locked by caller
  );

  std::vector<EventSource> _eventSources; /**< sources seen so far */
  std::vector<std::string> _appFlows;     /**< flow names seen so far */

  struct FlowSource
  {
    enum Type { BEGIN, REGULAR, END };

    unsigned flowIndex;
    Type type;
  };

  boost::container::flat_map<Entry::tag_t, FlowSource> _flowSources;

  // Sinks

  class AttachedSink
  {
  public:
    AttachedSink(
      Sink& sink,
      const EventSourcePredicate& predicate,
      const SinkDescription& description
    );

    AttachedSink(AttachedSink&&) = default;
    AttachedSink& operator=(AttachedSink&&) = default;

    void addMatchingSource(Entry::tag_t sourceId);
    bool isMatchingSource(Entry::tag_t sourceId) const;
    bool isMatchingSource(const EventSource& source);

    bool operator==(const Sink& sink) const;
    SinkDescription getDescription() const;

    /** add this entry to the pendings (overwrite), clear active flag */
    void addPending(
      const char* thread,
      const unsigned flowIndex,
      const char* buffer,
      const Entry::entry_size_t size
    );

    /** send inactive pending flow begins, mark them as active */
    void sendPendings(const char* thread);

    void discardPending(const char* thread, const unsigned flowIndex);

    void persistPendings(const char* thread);

    void setFlowActive(const char* thread, const unsigned flowIndex);
    bool isFlowActive(const char* thread, const unsigned flowIndex) const;

    Sink* impl;
    bool enabled = true;

  private:
    EventSourcePredicate _predicate;
    SinkDescription _description;
    boost::container::flat_set<Entry::tag_t> _matchingSourceIds;

    // Pending flow markers:

    struct EntryRef { const char* begin; Entry::entry_size_t size; };
    struct PersistedEntry { std::unique_ptr<char[]> begin; Entry::entry_size_t size = 0; };

    boost::container::flat_map<
      const char*,  // thread
      boost::container::flat_map<
        unsigned,  // flow index
        EntryRef
      >
    > _pendings;

    boost::container::flat_map<
      const char*,  // thread
      boost::container::flat_map<
        unsigned,  // flow index
        PersistedEntry
      >
    > _persistedPendings;
  };

  std::vector<AttachedSink> _sinks; /**< Added sinks */

  // Event processing

  const char* _latestThreadProp = nullptr;

  bool verifyEntryBuffer(const char* buffer, std::size_t bufferSize) const;
};

} // namespace sink
} // namespace binlog

#endif /* BINLOG_SINK_MULTISINK_H_ */
Attention:  ./lib/binlog/sink/Sink.H
#ifndef BINLOG_SINK_SINK_H_
#define BINLOG_SINK_SINK_H_

namespace binlog {
namespace sink {

/**
* Sink interface
*
* Binary log entries are fed to sinks by the
* consumer through this interface.
*/
class Sink
{
public:
  virtual ~Sink() {}

  /** Consume the given `buffer` of `size` bytes */
  virtual void operator()(const char* buffer, std::size_t size) = 0;

  /**
   * Called when the consumer finished with a larger batch
   * and there is nothing immediate to do.
   * Ideal place for flushing.
   */
  virtual void afterConsume() {}
};

} // namespace sink
} // namespace binlog

#endif /* BINLOG_SINK_SINK_H_ */
Attention:  ./lib/binlog/sink/SyslogSink.H
#ifndef BINLOG_SINK_SYSLOGSINK_H_
#define BINLOG_SINK_SYSLOGSINK_H_

#include <string>

#include <binlog/sink/Sink.H>
#include <binlog/sink/PlaintextSink.H>

namespace binlog {
namespace sink {

class
__attribute__((visibility("default")))
SyslogSink final : public Sink
{
public:
  SyslogSink(const std::string& format, const char* program, int option, int facility);
  SyslogSink(const std::string& format);
  SyslogSink();

  void operator()(const char* buffer, std::size_t size);

private:
  PlaintextSink _plaintextSink;
};

} // namespace sink
} // namespace binlog

#endif /* BINLOG_SINK_SYSLOGSINK_H_ */
Attention:  ./lib/binlog/sink/Consumer.H
#ifndef BINLOG_SINK_CONSUMER_H_
#define BINLOG_SINK_CONSUMER_H_

#include <atomic>
#include <thread>
#include <memory>

#include <binlog/detail/Core.H>
#include <binlog/detail/WaitStrategy.H>
#include <binlog/detail/Preamble.H>

namespace binlog {
namespace sink {

class
__attribute__((visibility("default")))
ConsumerBase
{
public:
  typedef binlog::detail::WaitStrategy WaitStrategy;

  /** Unregisters itself from the `_core` */
  virtual ~ConsumerBase();

  // Consumer scheduling related methods

protected:
  /** Registers itself in the `core` */
  ConsumerBase(binlog::detail::Core& core);

  // WaitStrategy related methods

  template <typename WaitStrategyT>
  void setWaitStrategy()
  {
    _ownWaitStrategy.reset(new WaitStrategyT());
    setWaitStrategy(_ownWaitStrategy.get());
  }

  void setWaitStrategy(WaitStrategy* pWaitStrategy);
  WaitStrategy* getWaitStrategy() { return _pWaitStrategy; }

  binlog::detail::Core& _core;  /**< Source of buffers to consume */

private:
  WaitStrategy* _pWaitStrategy = nullptr; /**< Consumer thread wait control */
  std::unique_ptr<WaitStrategy> _ownWaitStrategy; /**< @see setWaitStrategy<WS> */
};

/**
* Wraps a sink and creates a runnable interface to it.
*
* Methods of this template are not thread safe.
*
* Creating different Consumers and running them at the
* same time is an error, it will result garbage in the
* wrapped sinks. To have multiple sinks in the same
* application, however, @see MultiConsumer.
*
* `SinkImpl` must be default constructible
*/
template <typename SinkImpl>
class Consumer : public ConsumerBase
{
public:
  typedef binlog::detail::WaitStrategy WaitStrategy;

  /**
   * Constructs a sink
   *
   * @param sinkArgs Arguments forwarded to the wrapped sink
   *
   * @throws Whatever SinkImpl constructor throws
   */
  template <typename... SinkImplArgs>
  Consumer(SinkImplArgs&&... sinkArgs);

  /** Calls `stop()` */
  virtual ~Consumer();

  /**
   * Starts a new consumer thread, running
   * until `stop()` or the destructor is
   * called and the producer is empty.
   *
   * @see run<WaitStrategyT>()
   *
   * @returns true on success, false if previously
   * started thread is not stopped.
   */
  template <typename WaitStrategyT = binlog::detail::SleepWaitStrategy>
  bool start();

  /**
   * Starts a new consumer thread, running
   * until `stop()` or the destructor is
   * called and the producer is empty.
   *
   * `waitStrategy` must remain valid until
   * this Consumer instance exists.
   *
   * @param waitStrategy Controls waiting if nothing to do
   *
   * @returns true on success, false if previously
   * started thread is not stopped.
   */
  bool start(WaitStrategy& waitStrategy);

  /**
   * Calls `run()` with default constructed `WaitStrategyT`
   *
   * @see run(waitStrategy)
   */
  template <typename WaitStrategyT = binlog::detail::SleepWaitStrategy>
  void run();

  /**
   * Runs consumer cycle until `stop()` or
   * the destructor is called and the producer is empty.
   *
   * This is functionally equivalent to `start()`
   * but runs in the thread provided by the application.
   *
   * It should not be called again until the previously
   * launched thread is stopped by calling `stop()` and joined.
   *
   * @param waitStrategy Controls waiting if nothing to do
   */
  void run(WaitStrategy& waitStrategy);

  /**
   * Do a few consume cycles while there is
   * data available without blocking.
   *
   * @returns true, if there were buffers to consume
   */
  bool consume();

  /**
   * Stops consumer thread launched by `start()`
   * and consumer cycle of `run()`.
   */
  void stop();

  // Getters and Observers

  SinkImpl& getSink() { return _sink; }
  const SinkImpl& getSink() const { return _sink; }

  /** @returns true, if a consumer is possibly running */
  bool isRunning() const { return _runConsumer; }

private:
  SinkImpl _sink;

  std::atomic<bool> _runConsumer; /**< True if the consumer can run */
  std::thread _tConsumer; /**< Consumer thread handle */
};

/*
* Core will outlive Consumer because:
*
* C++11 3.6.3.1
* (...)If the completion of the constructor
* or dynamic initialization of an object with static storage
* duration is sequenced before that of another,
* the completion of the destructor of the second is sequenced
* before the initiation of the destructor of the first.
*/
template <typename SinkImpl>
template <typename... SinkImplArgs>
Consumer<SinkImpl>::Consumer(SinkImplArgs&&... sinkArgs)
  :ConsumerBase(binlog::detail::Core::getInstance()),
   _sink(std::forward<SinkImplArgs>(sinkArgs)...),
   _runConsumer(true)
{
  // add preamble
  detail::Preamble::getInstance().readPreamble(
    [this](const char* buffer, std::size_t size)
    {
      _sink(buffer, size);
    }
  );
}

template <typename SinkImpl>
Consumer<SinkImpl>::~Consumer()
{
  stop();
}

template <typename SinkImpl>
template <typename WaitStrategyT>
bool Consumer<SinkImpl>::start()
{
  if (_tConsumer.joinable()) { return false; }

  setWaitStrategy<WaitStrategyT>();

  return start(*getWaitStrategy());
}

template <typename SinkImpl>
bool Consumer<SinkImpl>::start(WaitStrategy& waitStrategy)
{
  if (_tConsumer.joinable()) { return false; }

  _runConsumer = true;

  _tConsumer = std::thread
  (
    static_cast<void(Consumer<SinkImpl>::*)(WaitStrategy&)>(
      &Consumer<SinkImpl>::run
    ),
    this,
    std::ref(waitStrategy)
  );

  return true;
}

template <typename SinkImpl>
template <typename WaitStrategyT>
void Consumer<SinkImpl>::run()
{
  setWaitStrategy<WaitStrategyT>();
  run(*getWaitStrategy());
}

template <typename SinkImpl>
void Consumer<SinkImpl>::run(WaitStrategy& waitStrategy)
{
  setWaitStrategy(&waitStrategy);

  do
  {
    bool didConsume = consume();

    if (didConsume)
    {
      getWaitStrategy()->reset();
    }
    else
    {
      getWaitStrategy()->wait();
    }
  }
  while (_runConsumer || !_core.empty());
}

template <typename SinkImpl>
bool Consumer<SinkImpl>::consume()
{
  bool didConsume = false;

  while (_core.consumeOne<SinkImpl&>(_sink))
  {
    didConsume = true;
  }

  if (didConsume)
  {
    _sink.afterConsume();
  }

  return didConsume;
}

template <typename SinkImpl>
void Consumer<SinkImpl>::stop()
{
  // stop consumer thread, if any
  // (it's not necessarily `_tConsumer`, might be user thread also)
  _runConsumer = false;

  if (_tConsumer.joinable())
  {
    _tConsumer.join();
  }

  // make it possible to restart by calling `run()`
  _runConsumer = true;
}

} // namespace sink
} // namespace binlog

#endif /* BINLOG_SINK_CONSUMER_H_ */
Attention:  ./lib/binlog/sink/SingleConsumer.H
#ifndef BINLOG_SINK_SINGLECONSUMER_H_
#define BINLOG_SINK_SINGLECONSUMER_H_

#include <memory>

#include <binlog/sink/Consumer.H>
#include <binlog/sink/AnySink.H>

namespace binlog {
namespace sink {

class FileSink;
class StreamSink;
class SyslogSink;

/**
* Convenience wrapper of a Consumer<Sink>
*
* This class provides a singleton interface
* (However, the singleton property is not enforced)
* and enables simple runtime sink creation.
*
* Use this class if you need a single sink only.
*
* A slightly more efficient way is
* to use the Consumer<Sink> interface directly,
* if the most derived type of Sink is known.
*/
class
__attribute__((visibility("default")))
SingleConsumer final : public Consumer<AnySink>
{
public:

  /** Access to a static instance */
  static SingleConsumer& getInstance();

  /**
   * @throws std::runtime_error If fails to acquire core
   * @see binlog::detail::Core::tryAcquire
   */
  SingleConsumer() = default;

  /**
   * Stops started consumer thread if any, releases Core
   */
  ~SingleConsumer();

  SingleConsumer(const SingleConsumer&) = delete;
  SingleConsumer(SingleConsumer&&) = delete;
  void operator=(const SingleConsumer&) = delete;
  void operator=(SingleConsumer&&) = delete;

  // set generic sink

  /**
   * Creates an arbitrary sink
   *
   * The SingleConsumer owns the created sink and it will live
   * until the SingleConsumer lives or until an other sink is set.
   *
   * @param sinkImplArgs SinkImpl contructor arguments to forward
   * @return reference to the added sink
   * @throw whatever SinkImpl constructor throws
   */
  template <typename SinkImpl, typename... SinkImplArgs>
  SinkImpl& setSink(SinkImplArgs&&... sinkImplArgs);

  // set specific sink (convenience)

  /**
   * Log binary events to `logfile`
   *
   * @see FileSink
   * @return reference to the added sink
   * @throw whatever FileSink constructor throws
   */
  FileSink& setFileSink(const std::string& logfile);

  /**
   * Log plain text events to `output` in `format`
   *
   * @see StreamSink
   * @see PrettyPrint for the available format options
   * @return reference to the added sink
   */
  StreamSink& setStreamSink(std::ostream& output, const std::string& format);

  /**
   * Log messages to syslog
   *
   * Because of the default syslog config, probably events only
   * of higher severity than error will be appear in the log.
   *
   * @see SyslogSink
   * @return reference to the added sink
   */
  SyslogSink& setSyslogSink();

private:
  /** Holds a sink if one was set, empty otherwise */
  std::unique_ptr<Sink> _sinkPtr;
};

template <typename SinkImpl, typename... SinkImplArgs>
SinkImpl& SingleConsumer::setSink(SinkImplArgs&&... sinkImplArgs)
{
  SinkImpl* pSinkImpl = new SinkImpl(sinkImplArgs...);
  _sinkPtr.reset(pSinkImpl);
  getSink().setSink(*_sinkPtr);
  return *pSinkImpl;
}

} // namespace sink
} // namespace binlog

#endif /* BINLOG_SINK_SINGLECONSUMER_H_ */
Attention:  ./lib/binlog/sink/PlaintextSink.H
#ifndef BINLOG_SINK_PLAINTEXTSINK_H_
#define BINLOG_SINK_PLAINTEXTSINK_H_

#include <functional>

#include <binlog/sink/Sink.H>

#include <binlog/reader/detail/MemoryInputStream.H>
#include <binlog/reader/EntryStream.H>
#include <binlog/reader/EventStream.H>

namespace binlog {
namespace sink {

/**
* Converts binary log buffers to Events.
*
* Typical usage: create the sink and connect it
* to a consumer. The consumer will use the
* `Sink` interface; the application can
* process the created events in the given
* callback without further attention.
*/
class
__attribute__((visibility("default")))
PlaintextSink final : public Sink
{
public:
  /** Event received by the consumer callback */
  typedef reader::entry::Event Event;
  /** Consumer callback type */
  typedef std::function<void(Event&)> Consumer;

  /**
   * @param consumer Callback called each time
   * a new Event is available to process
   */
  PlaintextSink(Consumer consumer);

  PlaintextSink(PlaintextSink&&) = delete;
  PlaintextSink(const PlaintextSink& rhs) = delete;
  void operator=(PlaintextSink&&) = delete;
  void operator=(const PlaintextSink&) = delete;

  /**
   * Parses binary buffer, invokes consumer callback
   * if new event is available.
   */
  void operator()(const char* buffer, std::size_t size);

private:
  Consumer _consumer;

  reader::detail::MemoryInputStream _buffer;
  reader::EntryStream _entryStream;
  reader::EventStream _events;
};

} // namespace sink
} // namespace binlog

#endif /* BINLOG_SINK_PLAINTEXTSINK_H_ */


Attention:  ./lib/binlog/sink/MultiConsumer.H
#ifndef BINLOG_SINK_MULTICONSUMER_H_
#define BINLOG_SINK_MULTICONSUMER_H_

#include <vector>
#include <memory>
#include <type_traits>

#include <binlog/sink/Consumer.H>
#include <binlog/sink/MultiSink.H>
#include <binlog/sink/FileSink.H>
#include <binlog/sink/StreamSink.H>
#include <binlog/sink/SyslogSink.H>

namespace binlog {

namespace reader {
namespace entry {

class EventSource;

} // namespace entry
} // namespace reader

namespace sink {

class FileSink;
class StreamSink;
class SyslogSink;

/**
* Convenience wrapper of a Consumer<MultiSink>
*
* This class provides simple methods to
* add/remove/toggle sinks, and also
* has a singleton interface.
* (However, the singleton property is not enforced)
*
* @see MultiSink regarding the `predicate` parameters
* controlling which `EventSources` will be
* connected to the attached sinks.
*/
class
__attribute__((visibility("default")))
MultiConsumer final : public Consumer<MultiSink>
{
public:

  /** Access to a static instance. */
  static MultiConsumer& getInstance();

  /**
   * @throws std::runtime_error If fails to acquire core
   * @see binlog::detail::Core::tryAcquire
   */
  MultiConsumer() = default;

  /**
   * Stops started consumer thread if any, releases Core
   */
  ~MultiConsumer();

  MultiConsumer(const MultiConsumer&) = delete;
  MultiConsumer(MultiConsumer&&) = delete;
  void operator=(const MultiConsumer&) = delete;
  void operator=(MultiConsumer&&) = delete;

  // Predicate typedefs

  /** Type of the argument the EventSourcePredicate receives */
  typedef MultiSink::EventSource EventSource;

  /** Predicate for filtering EventSources when adding sinks */
  typedef MultiSink::EventSourcePredicate EventSourcePredicate;

  /** Type of the data structure used to describe sinks */
  typedef MultiSink::SinkDescription SinkDescription;

  // add generic sinks

  /**
   * Adds an arbitrary sink to the underlying MultiSink
   *
   * The MultiConsumer owns the created sink and it will live
   * until the MultiConsumer lives or the sink is removed by
   * removeSink().
   *
   * @param sinkImplArgs SinkImpl constructor arguments to forward
   * @return reference to the added sink
   * @throw whatever SinkImpl constructor throws
   */
  template <typename SinkImpl, typename... SinkImplArgs, typename std::enable_if<
    std::is_constructible<SinkImpl, SinkImplArgs...>::value
  ,int>::type = 0>
  SinkImpl& addSink(SinkImplArgs&&... sinkImplArgs)
  {
    return addSink<SinkImpl, SinkImplArgs...>(
      [](const EventSource&) { return true; }, // no filter
      SinkDescription{},                       // empty description
      std::forward<SinkImplArgs&&>(sinkImplArgs)...
    );
  }

  /**
   * Adds an arbitrary sink with predicate.
   *
  * The sink will receive events emitted
   * by event sources allowed by `predicate` only.
   *
   * The MultiConsumer owns the created sink and it will live
   * until the MultiConsumer lives or the sink is removed by
   * removeSink().
   *
   * A default constructed `description` is fine if
   * there is nothing else to say.
   *
   * @see MultiSink regarding `predicate` and `description`
   * @param description Describes the sink
   * @param sinkImplArgs SinkImpl constructor arguments to forward
   * @return reference to the added sink
   * @throw whatever SinkImpl constructor throws
   */
  template <typename SinkImpl, typename... SinkImplArgs>
  SinkImpl& addSink(
    const EventSourcePredicate& predicate,
    const SinkDescription& description,
    SinkImplArgs&&...
  );

  /**
   * Adds a pre-constructed sink
   *
   * Takes ownership of the given sink.
   */
  void addSink(
    std::unique_ptr<Sink> sinkPtr,
    const EventSourcePredicate& predicate,
    const SinkDescription& description = {}
  );

  // add specific sinks (convenience)

  /**
   * Log binary events to `logfile`
   *
   * @see FileSink
   * @return reference to the added sink
   * @throw whatever FileSink constructor throws
   */
  FileSink& addFileSink(const std::string& logfile);

  /**
   * Log binary events to `logfile`, if enabled by `predicate
   * `.
   * @see FileSink
   * @see MultiSink regarding `predicate` and `description`
   * @return reference to the added sink
   * @throw whatever FileSink constructor throws
   */
  FileSink& addFileSink(
    const std::string& logfile,
    const EventSourcePredicate& predicate,
    const SinkDescription& description = {}
  );

  /**
   * Log plain text events to `output` in `format`
   *
   * @see StreamSink
   * @see PrettyPrint for the available format options
   * @return reference to the added sink
   */
  StreamSink& addStreamSink(std::ostream& output, const std::string& format);

  /**
   * Log plain text events to `output` in `format`,
   * if enabled by `predicate
   *
   * @see StreamSink
   * @see PrettyPrint for the available format options
   * @see MultiSink regarding `predicate` and `description`
   * @return reference to the added sink
   */
  StreamSink& addStreamSink(
    std::ostream& output, const std::string& format,
    const EventSourcePredicate& predicate,
    const SinkDescription& description = {}
  );

  /**
   * Log messages to syslog
   *
   * Because of the default syslog config, events only
   * of higher severity than error will be logged.
   *
   * @see SyslogSink
   * @return reference to the added sink
   */
  SyslogSink& addSyslogSink();

  /**
   * Log messages to syslog
   *
   * Because of the default syslog config, events of
   * lower severity than error will be discarded.
   * Make sure you create your predicate accordingly.
   *
   * @see SyslogSink
   * @see MultiSink regarding `predicate` and `description`
   * @return reference to the added sink
   */
  SyslogSink& addSyslogSink(
    const EventSourcePredicate& predicate,
    const SinkDescription& description = {}
  );

  // remove/toggle added sinks

  /**
   * @param sink previously added sink to remove
   * @return true on success, false if `sink` not found
   */
  bool removeSink(const Sink* sink);

  /**
   * Temporarily disables sink
   *
   * The disabled sink will receive special entries only,
   * but shouldn't produce any output.
   *
   * @param sink previously added sink to toggle
   * @param enable `sink` will be enabled if true, disabled if false.
   * @return true on success, false if `sink` not found
   */
  bool toggleSink(const Sink* sink, bool enable);

  /**
   * List of the owned sinks.
   *
   * Ownership is not transferred.
   *
   * @return vector of pointers to owned sinks.
   */
  std::vector<Sink*> listSinks();

  /**
   * Writes information on the registered sinks
   * in json-like format to the given stream.
   */
  void describeSinks(std::ostream& output);

  // Convenience for addSink

private:
  class Threshold
  {
  public:
    Threshold(binlog::Severity threshold) : _threshold(threshold) {}

    bool operator()(const EventSource& source)
    {
      return source.severity() >= _threshold;
    }

  private:
    binlog::Severity _threshold;
  };

public:
  /**
   * The most common predicate used is a severity filter.
   * This convenience member provides a simple way to
   * create such predicates:
   *
   * @param threshold The lowest allowed severity
   *
   * @code
   * mc.addFileSink(logfile, mc.threshold(binlog::critical));
   * @endcode
   */
  Threshold threshold(binlog::Severity threshold)
  {
    return Threshold(threshold);
  }

private:
  std::vector<std::unique_ptr<Sink>> _sinks;  /**< Added sinks */
};

template <typename SinkImpl, typename... SinkImplArgs>
SinkImpl& MultiConsumer::addSink(
  const EventSourcePredicate& predicate,
  const SinkDescription& description,
  SinkImplArgs&&... sinkImplArgs
)
{
  SinkImpl* pSinkImpl = new SinkImpl(sinkImplArgs...);
  std::unique_ptr<Sink> sinkImplPtr(pSinkImpl);
  addSink(std::move(sinkImplPtr), predicate, description);
  return *pSinkImpl;
}

} // namespace sink
} // namespace binlog

#endif /* BINLOG_SINK_MULTICONSUMER_H_ */
Attention:  ./lib/binlog/sink/StreamSink.H
#ifndef BINLOG_SINK_STREAMSINK_H_
#define BINLOG_SINK_STREAMSINK_H_

#include <ostream>

#include <binlog/sink/PlaintextSink.H>
#include <binlog/reader/PrettyPrinter.H>

namespace binlog {
namespace sink {

/**
* Writes human readable events to the
* given stream in the given format.
*
* @see PrettyPrint on the available placeholders in format
*/
class StreamSink final : public Sink
{
public:
  StreamSink(std::ostream& output, const std::string& format)
    :_plaintextSink(Consumer(output, format))
  {}

  void operator()(const char* buffer, std::size_t size)
  {
    _plaintextSink(buffer, size);
  }

  void afterConsume()
  {
    _plaintextSink.afterConsume();
  }

private:
  class Consumer
  {
  public:
    Consumer(std::ostream& output, const std::string& format)
      :_output(output)
    {
      _printer.setEventFormat(format + "\n");
    }

    void operator()(PlaintextSink::Event& event)
    {
      _printer.print(event, _output);
    }

  private:
    std::ostream& _output;
    reader::PrettyPrinter _printer;
  };

  PlaintextSink _plaintextSink;
};

} // namespace sink
} // namespace binlog

#endif /* BINLOG_SINK_STREAMSINK_H_ */
Attention:  ./lib/binlog/FunctionGuard.H
#ifndef BINLOG_FUNCTIONGUARD_H_
#define BINLOG_FUNCTIONGUARD_H_

#include <tuple>

#include <binlog/Binlog.H>

namespace binlog {

struct EnterFunctionGuard
{
  __attribute__((always_inline))
  EnterFunctionGuard()
  {
    BINLOG_DEBUG("Enter function");
  }

  template <typename... Args>
  __attribute__((always_inline))
  EnterFunctionGuard(const Args&... args)
  {
    BINLOG_DEBUG("Enter function, arguments: {0}", std::forward_as_tuple(args...));
  }
};

struct LeaveFunctionGuard
{
  __attribute__((always_inline))
  ~LeaveFunctionGuard()
  {
    BINLOG_DEBUG("Leave function");
  }
};

/*
* Implementation note:
* FunctionGuard shouldn't be implemented in terms of EnterFunctionGuard
* and LeaveFunctionGuard, to avoid making multiple inliner resolving necessary.
*/

struct FunctionGuard
{
  __attribute__((always_inline))
  FunctionGuard()
  {
    BINLOG_DEBUG("Enter function");
  }

  template <typename... Args>
  __attribute__((always_inline))
  FunctionGuard(const Args&... args)
  {
    BINLOG_DEBUG("Enter function, arguments: {0}", std::forward_as_tuple(args...));
  }

  __attribute__((always_inline))
  ~FunctionGuard()
  {
    BINLOG_DEBUG("Leave function");
  }
};

} // namespace binlog

#endif /* BINLOG_FUNCTIONGUARD_H_ */
Attention:  ./examples/02-libraries/Log.C
/*
* This file is kind of boring.
*
* If you want, you can omit this one
* and put BINLOG_INIT into Application.C instead.
*/
//[basics
#include "Log.H"

BINLOG_INIT
//]

// Each custom category declaration requires a definition here
//[custom_category
BINLOG_DEFINE_SUBCATEGORY(CUSTOM_CATEGORY)
//]
Attention:  ./examples/02-libraries/calculator/Log.C
/*
* Always the same boring content
*/
#include "Log.H"

BINLOG_INIT
Attention:  ./examples/02-libraries/calculator/Calculator.C
#include <cmath>
#include <stdexcept>

#include "Calculator.H"
//[logging_basics
#include "Log.H"

float sqrt(float arg)
{
  binlog::FunctionGuard guard(arg);

  if (arg < 0)
  {
    BINLOG_ERROR("Expected positive number, got: {0}", arg);
    throw std::domain_error("sqrt arg is negavite");
  }

  float result = std::sqrt(arg);

  BINLOG_DEBUG("Result: {0}", result);

  return result;
}
//]
Attention:  ./examples/02-libraries/Application.C
/**
* Using Binlog in libraries
*
* Things to be learned here:
*  - How to do category init nicely
*  - How to do it in a DSO (in the same way)
*  - How to do it in a header only library
*/

#include <iostream>

/*
* Log specific boilerplate code goes into Log.H/C
*/
//[consumer_basics
#include "Log.H"
//]

/*
* Use a simple library
*/
#include "calculator/Calculator.H"

/*
* Use a simple header only library
*
* This must come after #include "Log.H",
* if you want to enable logging in this library.
*/
#include "nofooter/Functional.H"

//[consumer_basics

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-example-02.log";
  binlog::openLogFile(logfile); // this will start the consuming in a separate thread

  sqrt(123.456f);
//]

  BINLOG_INFO("Call the nofooter library...");

  auto sum = sumPositive(13, 37);

  BINLOG_INFO("Result: 13 + 37 = {0}", sum);

  //[custom_category_long
  BINLOG_CATEGORIZED_INFO(CUSTOM_CATEGORY, "Using a custom category in the hard way");
  //]

  // Creating and using a custom category is straightforward, @see Log.H
  //[custom_category_short
  CUSTOM_INFO("Using a custom category");
  //]

  std::cout << "The log file was written to: '" << logfile
    << "'. To see the contents, execute the logfile." << std::endl;

//[consumer_basics

  return 0;
}
//]
Attention:  ./examples/04-structure_logging/Application.C
/**
* Structure logging in Binlog
*
* Things to be learned here:
*  - Log standard containers and tuples
*  - Log arrays
*  - Make custom structures loggable
*  - Create custom serialization (advanced)
*/

#define BINLOG_USER_RELEASE "example_structlog"
#include <binlog/Binlog.H>
BINLOG_INIT

#include <iostream>
#include <vector>
#include <array>
#include <set>
#include <list>
#include <map>
#include <tuple>
#include <algorithm>

#include <boost/container/flat_map.hpp>
#include <boost/smart_ptr.hpp>
#include <boost/make_shared.hpp>

void logCustomStruct();
void logTransformedStruct();

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-example-04.log";
  binlog::openLogFile(logfile);

  /*
   * Logging standard containers is trivial
   */
  std::vector<int>   vec{1, 2, 3};
  std::array<int, 3> arr{1, 2, 3};
  std::set<int>      set{1, 2, 3};
  std::list<int>    list{1, 2, 3};
  BINLOG_INFO("Containers: {0} {1} {2} {3}", vec, arr, set, list);

  std::map<int, std::string> map{{13, "foo"}, {37, "bar"}};
  BINLOG_INFO("Map: {0}", map);

  /*
   * Tuples or pairs are also simple
   */
  auto pair  = std::make_pair (257, "foobar");
  auto tuple = std::make_tuple(257, "foobar", 1.5f);
  BINLOG_INFO("pair: {0}, tuple: {1}", pair, tuple);

  /*
   * Any container like object is loggable,
   * as long as its value_type is loggable
   */
  {
    std::vector<char> v1{'a', 'b', 'c'};
    std::vector<char> v2{'d', 'e', 'f'};

    boost::container::flat_map<int, std::vector<char>> map2;
    map2.emplace(123, v1);
    map2.emplace(456, v2);

    BINLOG_INFO("Nothing extra for boost container is required: {0}", map2);
  }

  // let's take a leap of faith
  logCustomStruct();

  // advanced features
  logTransformedStruct();

  std::cout << "The log file was written to: '" << logfile
    << "'. To see the contents, execute the logfile." << std::endl;

  return 0;
}

/*
* This is a pretty custom structure,
* nothing special is involved
*/
struct LotteryResults
{
  int id;
  std::vector<short> numbers;

  int sum() const
  {
    return std::accumulate(numbers.begin(), numbers.end(), 0);
  }
};

/*
* Make this structure loggable
*
* `sum` is a getter, it's able to calculate derived fields.
*/
BINLOG_MAKE_LOGGABLE(LotteryResults, id, numbers, sum)

void logCustomStruct()
{
  LotteryResults results{2014, {4, 8, 15, 16, 23, 42}};
  BINLOG_INFO("The results are: {0}", results);
}

//
// ADVANCED USAGE BELOW
// You are not expected to use this (most of the time)
//

/*
* Let's assume you have a container of boost::shared_ptr's pointing
* to strings. You'd like to log this container, but you don't
* want to see the shared_ptr internals in the output.
*
* In the following, we define a custom serialization method
* for boost::shared_ptr to solve this.
*
* Please note, instead of doing this, you should
* #include <binlog/make_loggable/BoostPointers.H>
* instead, the following is for illustrational purpose only.
*/

namespace binlog {
namespace detail {

// Yes, it's in the detail namespace
// It's an implementation detail and subject to change

template <typename T>
struct LoggableDescriptor<boost::shared_ptr<T>>
  :public TrivialLoggableDescriptor<
     boost::shared_ptr<T>,
     LoggableDescriptor<T>::type_tag
   >
{};

template <typename T>
struct CustomSerializer<boost::shared_ptr<T>>
{
  static std::size_t size(const boost::shared_ptr<T>& tPtr)
  {
    return SelectSerializer<T>::type::size(*tPtr);
  }

  static void serialize(const boost::shared_ptr<T>& tPtr, Entry& entry)
  {
    SelectSerializer<T>::type::serialize(*tPtr, entry);
  }
};

// I hope all this thing was scary enough to put you off
// This solution is really just a last resort.

} // detail
} // binlog

void logTransformedStruct()
{
  std::vector<boost::shared_ptr<std::string>> vecOfPtrOfStr {
    boost::make_shared<std::string>("foo"),
    boost::make_shared<std::string>("bar"),
    boost::make_shared<std::string>("baz")
  };

  BINLOG_INFO("This was indirectly hard: {0}", vecOfPtrOfStr);
}
Attention:  ./examples/09-multisink/Application.C
/**
* Using MultiSink
*
* Print critical messages to the standard out,
* while writing a logfile containing every event.
*
* The results of this example are very similar to
* those of the previous one, but it shows what
* happens behind the scenes, instead of hiding
* details in MultiConsumer.
*
* Things to be learned here:
*  - How to use multiple sinks
*  - How to create a plaintext sink
*/

#include <iostream>

#define BINLOG_USER_RELEASE "example_multisink"
#include <binlog/Binlog.H>
BINLOG_INIT

#include <binlog/sink/Consumer.H>
#include <binlog/sink/MultiSink.H>
#include <binlog/sink/PlaintextSink.H>
#include <binlog/sink/FileSink.H>

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-example-09.log";

  using binlog::sink::Consumer;
  using binlog::sink::MultiSink;
  using binlog::sink::FileSink;
  using binlog::sink::PlaintextSink;

  /*
   * A PlaintextSink transforms binary buffers emitted by the
   * logger threads to Events. Events are processed by a user
   * supplied callback.
   *
   * In this example, we are printing received event messages
   * to the standard output.
   */
  PlaintextSink stdoutSink([](PlaintextSink::Event& event)
  {
    std::cout << event.message() << std::endl;
  });

  /*
   * A FileSink writes binary buffers emitted by the logger
   * threads to a file.
   *
   * Constructor throws on failure (i.e: can't open file)
   */
  FileSink fileSink(logfile);

  /*
   * After we have our sinks ready, we need to attach them
   * to a multi sink consumer. This procedure requires a
   * filter, which controls what events should be sent to
   * what sinks.
   *
   * The filter is a predicate, which accepts an EventSource
   * and returns true, iff Events emitted by the source should
   * be transmitted to the sink.
   *
   * The predicate is called for each EventSource once
   * (typically on startup); it isn't going to be called for each
   * Event.
   */

  // This filter enables EventSources with at least critical severity
  auto leastCritical = [](const MultiSink::EventSource& source)
  {
    return source.severity() >= binlog::critical;
  };

  // This filter enables EventSources of a specific category
  auto thisCategory = [](const MultiSink::EventSource& source)
  {
    return source.category() == "mstk/binlog/example_multisink";
  };

  /*
   * Create the multi sink.
  *
   * The Consumer<> template provides a convenience
   * startable/runnable/pollable interface for the sink.
   */
  Consumer<MultiSink> consumer;
  auto&& multiSink = consumer.getSink();

  /*
   * We have everything ready, let's connect
   * the sinks to the multi sink consumer.
   *
   * The addSink method takes the sinks by reference,
   * it doesn't take ownership. Therefore it's important
   * to ensure the sinks outlive the consumer. If a sink
   * is destroyed while attached to a consumer, the application
   * might crash if the consumer thread is still running.
   */
  multiSink.addSink(stdoutSink, leastCritical);
  multiSink.addSink(fileSink, thisCategory);

  /*
   * Start the consumer
   *
   * The easiest way is to let the library manage the threading,
   * `start()` will launch a new thread without further blocking.
   * The thread will asked to join if `stop()` is called or the
   * consumer object gets out of scope.
   *
   * If you'd like to use your own thread, @see `run()` or `consume()`.
   */
  consumer.start();

  // Rest of the application

  BINLOG_DEBUG("Debug");
  BINLOG_INFO("Info");
  BINLOG_WARNING("Warning");
  BINLOG_ERROR("Error");
  BINLOG_CRITICAL("Critical, this should appear on stdout");

  std::cout << "The log file is written to: '" << logfile
    << "'. To see the contents, execute the logfile.\n";

  return 0;
}
Attention:  ./examples/08-multiconsumer/Application.C
/**
* Using MultiConsumer
*
* This example shows how to use the MultiConsumer
* convenience class. By setting it up properly,
* while writing the logfile in the usual way,
* critical messages will printed to the standard output.
*
* Things to be learned here:
*  - How to use MultiConsumer
*/

#include <iostream>

#define BINLOG_USER_RELEASE "example_multiconsumer"
#include <binlog/Binlog.H>
BINLOG_INIT

#include <binlog/sink/MultiConsumer.H>

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-example-08.log";

  /*
   * Create a Consumer instance
   *
   * There must be only a single living consumer at
   * any time in an application. If you have more,
   * e.g: both SingleConsumer and MultiConsumer,
   * a std::runtime_error will be thrown.
   *
   * getInstance() is there for your convenience,
   * but a default constructor is also available
   * for finer grained lifetime managment.
   */
  auto&& multiConsumer = binlog::sink::MultiConsumer::getInstance();

  /*
   * Setup a file sink
   *
   * Since no criteria was specified, this sink
   * will receive every event generated by the application.
   */
  multiConsumer.addFileSink(logfile);

  /*
   * Setup a stream sink
   *
   * A stream sink will write human readable,
   * formatted events to the stream specified.
   *
   * It is slower than a binary sink, use it with care.
   *
   * In this example, we are specifying a criteria,
   * using `multiConsumer.threshold`: only
   * events of equal or higher severity than critical
   * will be forwarded to this sink.
   *
   * On specifying a more fine grained criteria,
   * @see MultiConsumer::EventSourcePredicate
   * or the next, `multisink` example project.
   */
  multiConsumer.addStreamSink(
    std::cout, "%S %C [%d] %t %N %m",
    multiConsumer.threshold(binlog::critical)
  );

  /*
   * If you'd like to add your own custom sinks,
   * @see MultiConsumer::addSink<SinkImpl, SinkImplArgs...>
   */

  /*
   * After all the necessary sinks are attached,
   * we can launch the consumer.
   * (It's ok to start the consumer before attaching
   * any sinks, if you don't mind losing some events
   * emitted before the sinks are ready)
   *
   * `start()` creates a dedicated thread doing the
   * consuming. If you'd like to get more control,
   * @see Consumer<>::run()
   * @see Consuner<>::consume()
   * @see Consuner<>::stop()
   */
  multiConsumer.start();

  // Rest of the application

  BINLOG_DEBUG("Debug");
  BINLOG_INFO("Info");
  BINLOG_WARNING("Warning");
  BINLOG_ERROR("Error");
  BINLOG_CRITICAL("Critical, this should appear on stdout");

  std::cout << "The log file is written to: '" << logfile
    << "'. To see the contents, execute the logfile.\n";

  return 0;
}
Attention:  ./examples/11-watchtower_sink/Application.C
/**
* Watchtower integration
*
* Watchtower is a monitoring platform.
*
* This sample application shows a custom sink,
* which transforms custom loggable structures to
* Watchtower events and metrics.
*
* The sink produces JSON output, for the sake
* of the example. However, a real sink
* should use the binary WT API, if it's available.
*/

#define BINLOG_USER_RELEASE "example_watchtower"
#include <binlog/Binlog.H>
#include <binlog/sink/MultiConsumer.H>

BINLOG_INIT

#include "WatchtowerSink.H"

/*
* Every loggable struct can represent
* a monitoring event.
*
* The event name becomes the name of the
* structure, the payload consists of the
* fields.
*/

struct Connection
{
  int localPort;
  int remotePort;
  bool connected;
};

BINLOG_MAKE_LOGGABLE(Connection, localPort, remotePort, connected);

/*
* The example sink creates a metric request
* (instead of event) from the "MetricData"
* instances. This choice is arbitrary.
*
* By using the `name` field as `itemKey`
* instead of the class name, we make
* it possible to produce dynamically
* named (e.g: grouped) metrics.
*/

struct MetricData
{
  const char* name;
  std::size_t value;
};

BINLOG_MAKE_LOGGABLE(MetricData, name, value);

// Shortcuts

MetricData metrics(const char* name, std::size_t value)
{
  return MetricData{name, value};
}

void dummyConnect(int l, int r)
{
  Connection c{l, r, true};
  BINLOG_INFO("Connection established: {0}", c);
}

void dummyDisconnect(int l, int r)
{
  Connection c{l, r, false};
  BINLOG_INFO("Connection disposed: {0}", c);
}

int main()
{
  /*
   * Setup the consumer
   *
   * Attach our sink, which will
   * receive events with a structure argument only.
   *
   * We also provide the application identity key
   * and instance name, required by watchtower.
   */

  using binlog::sink::MultiConsumer;

  auto&& mc = MultiConsumer::getInstance();
  mc.addSink<WatchtowerSink>(
    [](const MultiConsumer::EventSource& source)
    {
      return source.typeCodes().find(binlog::detail::type_struct) != std::string::npos;
    },
    {}, "1234-app", "port123"
  );

  mc.start();

  BINLOG_INFO("Start application");

  dummyConnect(80, 123);
  dummyConnect(80, 456);

  BINLOG_INFO("On connection: {0}", metrics("bytes_transmitted", 100));
  BINLOG_INFO("On connection: {0}", metrics("bytes_transmitted", 200));
  BINLOG_INFO("On connection: {0}", metrics("bytes_transmitted", 300));

  dummyDisconnect(80, 123);
  dummyDisconnect(80, 456);

  BINLOG_INFO("Stop application");

  return 0;
}
Attention:  ./examples/11-watchtower_sink/WatchtowerSink.C
#include <sstream>
#include <iostream>
#include <chrono>

#include <binlog/detail/Arguments.H> // type_struct
#include <binlog/reader/detail/DeserializedStruct.H>

#include "WatchtowerSink.H"

WatchtowerSink::WatchtowerSink(
  const std::string& appIdentity,
  const std::string& instanceName
)
  :_sink([this](Event& event) { processEvent(event); }),
   _instanceName(instanceName),
   _resourceId("1234567890")
{
  // send identity request
  std::ostringstream idReq;
  idReq <<
    "{\n"
    "  \"request\":\"identity\",\n"
    "  \"identity\":\"" << appIdentity << "\",\n"
    "  \"facet\":\"APPLICATION\"\n"
    "}\n";

  std::cout << idReq.str();

  // TODO parse the response, extract resourdeId
}

namespace {

struct StructArgVisitor : public boost::static_visitor<>
{
  StructArgVisitor(
    std::ostream& output,
    int64_t milliseconds,
    const std::string& instanceName,
    const std::string& resourceId
  )
    :_output(output),
     _milliseconds(milliseconds),
     _instanceName(instanceName),
     _resourceId(resourceId)
  {}

  template <typename T>
  void operator()(const T&) const
  {
    std::cerr << "StructArgVisitor visits non Struct argument\n";
  }

  void operator()(const binlog::reader::detail::DeserializedStruct& ds) const
  {
    _output << "{ \"data\": [{\n"
      "  \"resourceId\": \"" << _resourceId << "\",\n"
      "  \"instanceName\": \"" << _instanceName << "\",\n";

    if (ds.getName() == "MetricData")
    {
      // create metric
      _output << "  \"clock\": " << _milliseconds << ",\n"
        "  \"itemKey\": \"" << ds.getFields()[0].second << "\",\n"
        "  \"value\": \"" << ds.getFields()[1].second << "\"\n"
        "  }],\n"
        "  \"request:\" \"metric_data\"\n";
    }
    else
    {
      // create event
      _output << "  \"eventType: \"" << ds.getName() << "\",\n"
        "  \"creationTime\": " << _milliseconds << ",\n"
        "  \"payload\": {\n";

      bool first = true;
      for (auto&& field : ds.getFields())
      {
        if (first) { first = false; } else { _output << ",\n"; }
        _output << "    \"" << field.first << "\": \"" << field.second << "\"";
      }

      _output << "\n  }}],\n"
        "  \"request\": \"event_data\"\n";
    }

    _output << "}";
  }

private:
  std::ostream& _output;
  int64_t _milliseconds;
  const std::string& _instanceName;
  const std::string& _resourceId;
};

} // namespace

void WatchtowerSink::processEvent(Event& event)
{
  auto millis = std::chrono::duration_cast<std::chrono::milliseconds>(
    event.dateTime().time_since_epoch()
  ).count();

  StructArgVisitor argVisitor(std::cout, millis, _instanceName, _resourceId);
  auto&& args = event.arguments();

  auto typeCodes = event.source().typeCodes();
  for (std::size_t argIndex = 0; argIndex < typeCodes.size(); ++argIndex)
  {
    if (typeCodes[argIndex] == binlog::detail::type_struct)
    {
      boost::apply_visitor(argVisitor, args[argIndex]);
      std::cout << std::endl;
    }
  }
}
Attention:  ./examples/10-network_sink/Client.C
#include <iostream>

#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>

#include <binlog/Binlog.H>
#include <binlog/sink/Sink.H>
#include <binlog/sink/Consumer.H>

BINLOG_INIT

void failure(const char* message)
{
  perror(message);
  exit(2);
}

class NetworkSink : public binlog::sink::Sink
{
public:
  NetworkSink(const char* serverAddr, int serverPort);
  ~NetworkSink();

  void operator()(const char* buffer, std::size_t size);

private:
  int _sock;
  struct sockaddr_in _server;
};

NetworkSink::NetworkSink(const char* serverAddr, int serverPort)
{
  // Create server addr
  memset(&_server, 0, sizeof(_server));
  _server.sin_family = AF_INET;
  _server.sin_port = htons(uint16_t(serverPort));
  if (! inet_aton(serverAddr, &_server.sin_addr))
  {
    failure("Invalid server address specified");
  }

  // Open socket
  if ((_sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
  {
    failure("Failed to create socket");
  }

  // connect
  if (connect(
    _sock,
    reinterpret_cast<struct sockaddr*>(&_server),
    sizeof(_server)
  ) < 0)
  {
    failure("Failed to connect to the server");
  }
}

void NetworkSink::operator()(const char* body, std::size_t size)
{
  const uint32_t bodySize = uint32_t(size);
  const void* header = &bodySize;
  const uint32_t headerSize = sizeof(bodySize);

  if (send(_sock, header, headerSize, MSG_MORE) != ssize_t(headerSize))
  {
    perror("Failed to send header");
    return;
  }

  if (send(_sock, body, bodySize, 0) != ssize_t(bodySize))
  {
    perror("Failed to send body");
    return;
  }
}

NetworkSink::~NetworkSink()
{
  if (_sock >= 0)
  {
    close(_sock);
  }
}

int main(int argc, const char* argv[])
{
  if (argc < 3)
  {
    fprintf(stderr, "USAGE: %s <server_ip> <port>\n", argv[0]);
    exit(1);
  }

  binlog::sink::Consumer<NetworkSink> sink(argv[1], atoi(argv[2]));

  fprintf(stdout, "Type any string to send a message, 'q' quits\n");

  std::string s;
  do
  {
    std::getline(std::cin, s);

    if (s == "q")
    {
      BINLOG_INFO("End of story");
      break;
    }
    else
    {
      BINLOG_INFO("String received: {0}", s);
    }

    sink.consume();

  } while (std::cin);

  sink.consume();

  return 0;
}
Attention:  ./examples/10-network_sink/Server.C
#include <iostream>
#include <thread>

#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>

#include <binlog/sink/StreamSink.H>

void failure(const char* message)
{
  perror(message);
  exit(2);
}

ssize_t readBuffer(int sock, void* target, std::size_t size)
{
  return recv(sock, target, size, MSG_WAITALL);
}

template <typename Field>
bool readField(int sock, Field& field)
{
  return readBuffer(sock, &field, sizeof(field)) == ssize_t(sizeof(field));
}

void handleClient(int sock)
{
  binlog::sink::StreamSink streamSink(std::cout, "%h %S %C [%d] %t %N %m");

  uint32_t bufferSize = 255;
  std::unique_ptr<char[]> buffer(new char[bufferSize]);

  while (true)
  {
    // read buffer header = body size
    uint32_t bodySize = 0;
    if (! readField(sock, bodySize))
    {
      break;
      //failure("Failed to receive entry header");
    }

   // realloc buffer
    if (bodySize > bufferSize)
    {
      bufferSize = bodySize;
      buffer.reset(new char[bufferSize]);
    }

    // read body
    if (readBuffer(sock, buffer.get(), bodySize) != ssize_t(bodySize))
    {
      failure("Error while receiving entry body");
    }

    // process received buffer
    streamSink(buffer.get(), bodySize);
  }

  close(sock);
}

#define MAXPENDING 5    /* Max connection requests */

int main(int argc, char *argv[])
{
  int serversock;
  struct sockaddr_in server;

  if (argc != 2)
  {
    fprintf(stderr, "USAGE: %s <port>\n", argv[0]);
    exit(1);
  }

  auto port = uint16_t(std::stoi(argv[1]));

  /* Create the TCP socket */
  if ((serversock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
  {
    failure("Failed to create socket");
  }

  /* Construct the server sockaddr_in structure */
  memset(&server, 0, sizeof(server));         /* Clear struct */
  server.sin_family = AF_INET;                /* Internet/IP */
  server.sin_addr.s_addr = htonl(INADDR_ANY); /* Incoming addr */
  server.sin_port = htons(port);              /* server port */

  /* Bind the server socket */
  if (bind(serversock, reinterpret_cast<struct sockaddr*>(&server), sizeof(server)) < 0)
  {
    failure("Failed to bind the server socket");
  }

  /* Listen on the server socket */
  if (listen(serversock, MAXPENDING) < 0)
  {
    failure("Failed to listen on server socket");
  }

  /* Run until cancelled */
  while (true)
  {
    struct sockaddr_in client;
    unsigned int clientlen = sizeof(client);
    int clientsock;

    /* Wait for client connection */
    if ((clientsock = accept(serversock, reinterpret_cast<struct sockaddr*>(&client), &clientlen)) < 0)
    {
      failure("Failed to accept client connection");
    }

    fprintf(stdout, "Client connected: %s\n", inet_ntoa(client.sin_addr));
    std::thread handler{handleClient, clientsock};
    handler.detach();
  }

  return 0;
}
Attention:  ./examples/06-crash_recovery/Application.C
/**
* Crash recovery in Binlog
*
* Things to be learned here:
*  - How to recover events stuck in the buffer when
*    the application crashes.
*/

#include <iostream>
#include <thread>

#define BINLOG_USER_RELEASE "example_crash"
#include <binlog/Binlog.H>
BINLOG_INIT

void doLog()
{
  BINLOG_CRITICAL("This comes from a thread.");
}

int main()
{
  /*
   * We do not open a log file here
   * to make sure events will be stuck in the
   * internal buffers.
   */

  BINLOG_CRITICAL("This message won't make it to the logfile.");
  BINLOG_CRITICAL("Neither will this one.");
  BINLOG_CRITICAL("Third buddy out of luck.");

  /*
   * Do logging in a different thread,
   * this will have a different buffer,
   * but no event will be lost at the end.
   */
  std::thread t(doLog);
  t.join();

  std::cout << "This example will crash in a second."
    " To recover messages, do the following:\n"
    "$ export GDB_PATH=/ms/dist/mstk/PROJ/rhdevtoolset/3.1-rhel5\n"
    "$ $GDB_PATH/bin/gdb --data-directory=$GDB_PATH/share/gdb \\ \n"
    "                    /path/to/binary                         \\ \n"
    "                    /path/to/coredump.core \n"
    "(gdb) source /ms/dist/mstk/PROJ/binlog/latest/src/python/binlog/binlog.py\n"
    "(gdb) binlog-recovery\n";

  std::cout << "Core intentionally..." << std::endl;
  std::abort();
}
Attention:  ./examples/03-configuration/Application.C
/**
* Configuring Binlog
*
* Things to be learned here:
*  - Open output file explicitly
*  - Config category severity threshold by #define
*  - Config category severity threshold by env var
*  - Config category severity threshold by function call
*  - Enable disable event sources, one-by-one
*/

/*
* Disable event sources below the INFO
* severity compile time. This have to
* come before #includeing Binlog.H
*
* A better way to set this macro is to put
* defines{'BINLOG_MIN_SEVERITY_INFO'}
* into your premake-build.lua file.
*
* Compile time switches to control logging:
* - BINLOG_MIN_SEVERITY_DEBUG
* - BINLOG_MIN_SEVERITY_INFO
* - BINLOG_MIN_SEVERITY_WARNING
* - BINLOG_MIN_SEVERITY_ERROR
* - BINLOG_MIN_SEVERITY_CRITICAL
*
* By defining BINLOG_MIN_SEVERITY_<X>,
* calls to the log library with severity < X
* will be removed by the preprocessor.
*/
#define BINLOG_MIN_SEVERITY_INFO

#define BINLOG_USER_RELEASE "example_config"

#include <binlog/Binlog.H>
#include <binlog/Configuration.H>

BINLOG_INIT

#include <iostream>

void produceEvents();
void disableEventSources();
void initFromEnv();

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-example-03.log";

  /*
   * Configuring the output file
   *
   * This opens the specified log file
   * and starts the consumer in a dedicated thread.
   *
   * This function and the file based configuration
   * is mutually exclusive. This one is considered
   * useful in simple/example applications only.
   *
   * This function throws std::runtime_error on failure.
   */
  binlog::openLogFile(logfile);

  /*
   * Configure severity threshold runtime.
   *
   * The category names map to meta/project/release.
   * The * wildcard matches like the lazy .*? regexp.
   */
  binlog::setCategoryConfigs({
    {"mstk/binlog/example_config",{binlog::debug}},
    {"mstk/binlog/*",             {binlog::critical}},
    {"*",                         {binlog::none}}
  });

  /*
   * The same could be achieved by calling the
   * function defined below after setting up
   * the BINLOG_THRESHOLD envvar.
   *
   * Use envvars only when absolutely neccessary.
   */

  // $ export BINLOG_THRESHOLD=
  // "mstk/binlog/example_config:DEBG,mstk/binlog/*:CRIT,*:NONE"

  initFromEnv();

  /*
   * Config file support is also available.
   * We could achieve the same by doing:
   *
   * binlog::getConfiguration().initFromConfig("config.json");
   * binlog::sink::MultiConsumer::getInstance().start();
   *
   * This version is mutually exclusive with `openLogFile`.
   */

  /*
   * Because this example is compiled with
   * BINLOG_MIN_SEVERITY_INFO defined, the
   * following event source won't produce
   * any event, even if the dynamic threshold
   * is set to debug for this category.
   */
  BINLOG_DEBUG("You can't see me.");

  /*
   * There's a way to configure each
   * event source dynamically.
   *
   * To show this, we activate some event
   * sources in a function, then disable
   * those sources and see, they no
   * longer produce events.
   */

  produceEvents();
  disableEventSources();

  BINLOG_INFO("You shouldn't see events from the produceEvents() function now");
  produceEvents();

  std::cout << "The log file was written to: '" << logfile
    << "'. To see the contents, execute the logfile." << std::endl;

  // THE END
  return 0;
}

unsigned g_marker = __LINE__;

void produceEvents()
{
  BINLOG_INFO("This is the last time you see me");
  BINLOG_WARNING("I'll be disabled");
  BINLOG_CRITICAL("Then no more events, see?");
}

void disableEventSources()
{
  auto& config = binlog::getConfiguration();
  config.toggleSource("Application.C", g_marker + 4, false);
  config.toggleSource("Application.C", g_marker + 5, false);
  config.toggleSource("Application.C", g_marker + 6, false);
}

void initFromEnv()
{
  auto thresholdOrNull = getenv("BINLOG_THRESHOLD");
  if (! thresholdOrNull) { return; }

  std::string thresholds(thresholdOrNull);
  std::vector<std::pair<std::string, binlog::CategoryConfig>> configs;

  std::size_t categoryBegin = 0;
  std::size_t colonPos = thresholds.find(':', categoryBegin);
  while (colonPos != std::string::npos)
  {
    std::string category = thresholds.substr(categoryBegin, colonPos - categoryBegin);
    auto commaPos = thresholds.find(',', colonPos);

    if (commaPos == std::string::npos)
    {
      commaPos = thresholds.size();
    }

    std::string severityStr = thresholds.substr(colonPos + 1, commaPos - colonPos - 1);
    auto severity = binlog::stringToSeverity(severityStr);
    if (severity != binlog::unknown)
    {
      configs.push_back({category, binlog::CategoryConfig(severity)});
    }
    else
    {
      throw std::runtime_error(
        "Invalid severity specified in BINLOG_THRESHOLD envvar: '"
        + severityStr + "'");
    }

    // find next category
    categoryBegin = commaPos + 1;
    colonPos = thresholds.find(':', categoryBegin);
  }

  binlog::getConfiguration().setCategoryConfigs(configs);
}
Attention:  ./examples/07-epoll_consumer/Application.C
/**
* Do non-blocking consume in epoll
*
* @see http://man7.org/linux/man-pages/man7/epoll.7.html
*
* If you use waiting consumers, don't forget to
* #define BINLOG_PRODUCERS_NOTIFY_CONSUMER
*
* Please note, this is advanced usage.
* If a waiting thread is ok for you, use
* Consumer<>::start() instead.
*
* Things to be learned here:
*  - How to create a consumer
*  - How to integrate it into the applications main loop
*/

#include <iostream>
#include <string>
#include <stdexcept>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/epoll.h>

#define BINLOG_USER_RELEASE "example_epollconsumer"
#include <binlog/Binlog.H>
BINLOG_INIT

#include <binlog/sink/Consumer.H>
#include <binlog/sink/FileSink.H>
#include <binlog/detail/WaitStrategy.H>

void check(long int status, const char* msg)
{
  if (status == -1)
  {
    perror(msg);
    exit(EXIT_FAILURE);
  }
}

void watchFd(int epollfd, int fd)
{
  epoll_event event;
  event.events = EPOLLIN;
  event.data.fd = fd;

  int status = epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &event);
  check(status, "epoll_ctl");
}

// business logic
bool processFd(int fd);

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-example-07.log";

  try
  {

  /*
   * binlog::openLogFile is a convenience function.
   *
   * It starts a new thread which polls the log
   * producer queues, writes queue content to
   * `logfile` and does an exponential backoff
   * sleep if nothing to do.
   *
   * If you don't want to have a dedicated log
   * thread, a little bit of extra work is required.
   */
//  binlog::openLogFile(logfile);

  /**
   * FileSink is the default implementation of a sink:
   * it reads entries available and writes them to a file.
   *
   * The FileSink constructor throws std::runtime_error
   * if it fails to open the logfile.
   *
   * Consumer<Sink> is a wrapper around a well formed
   * sink. It implements common logic of consuming, e.g:
   * consumer thread management or waiting.
   *
   * Consumer<Sink> constructor passes its
   * arguments to the Sink constructor.
   *
   * consumer.start(...)  would start a new thread and get
   * the consuming done without further attention.
   * However, in this example, we'd like to use our own thread.
   *
   * Keep `consumer` around until there's logging to do.
   * It's best to keep it in a global/function static variable.
   */
  binlog::sink::Consumer<binlog::sink::FileSink> consumer(logfile);

  /*
   * Instead of the default, we create a custom
   * wait strategy. Wait strategies are used to
   * block the log consumer until log data is
   * available. If BINLOG_PRODUCERS_NOTIFY_CONSUMER
   * is #defined, log producers will wake up
   * the consumer through the registered wait strategy
   * if a critical queue load is reached.
   * (@see BINLOG_CRIT_LOAD_FACTOR in the Integrators Handbook)
   *
   * By calling PipeWaitStrategy::promoteToConsumerWaiter,
   * we register it as a consumer wait strategy, and obtain
   * a file descriptor at the same time. This fd is used
   * to signal log data availability.
   *
   * Keep `waitStrategy` around until there's logging to do.
   * It's best to keep it in a global/function static variable.
   */
  binlog::detail::PipeWaitStrategy waitStrategy;
  int logAvailable = waitStrategy.promoteToConsumerWaiter();
  check(logAvailable, "promoteToConsumerWaiter");

  // setup epoll
  int epollfd = epoll_create(10);
  check(epollfd, "epoll_create");

  // add logAvailable file descriptor to epoll
  watchFd(epollfd, logAvailable);

  // add stdin to epoll
  watchFd(epollfd, STDIN_FILENO);

  std::cout << "Echo application. Type 'quit' to exit.\n> " << std::flush;

  // start application main loop
  bool finished = false;
  epoll_event events[10];

  while (!finished)
  {
    BINLOG_DEBUG("Entering epoll_wait");

    // block until there's work to be done
    int availableCount = epoll_wait(epollfd, events, 10, -1);
    check(availableCount, "epoll_wait");

    BINLOG_DEBUG("Done epoll_wait, available fd count: {0}", availableCount);

    // process each fd with I/O event
    for (int i = 0; i < availableCount; ++i)
    {
      int fd = events[i].data.fd;
      BINLOG_DEBUG("I/O event on fd: {0:fd}", fd);

      if (fd == logAvailable)
      {
        /*
         * Log data is available to write
         *
         * Consuming is done in a thread provided
         * by the application, no new thread created here.
         */
        BINLOG_DEBUG("Run binlog consumer");
        consumer.consume();
        waitStrategy.reset();
      }
      else
      {
        // continue as usual with application logic
        finished = processFd(fd);
      }
    }
  }

  std::cout << "\nThe log file was written to: '" << logfile
    << "'. To see the contents, execute the logfile.\n";

  return 0;

  }
  catch (const std::runtime_error& ex)
  {
    std::cerr << "Failure: " << ex.what() << std::endl;
    return 2;
  }
}

bool processFd(int fd)
{
  BINLOG_DEBUG("Execute business logic (i.e: echo) on file descriptor");

  char buffer[128];
  ssize_t size = read(fd, buffer, 127);
  check(size, "processFd read");

  if (size)
  {
    buffer[size - 1] = '\0';
    BINLOG_INFO("Input received: {0}", buffer);
    printf("echo: %s\n> ", buffer);
    fflush(stdout);

    if (strcmp(buffer, "quit") == 0)
    {
      BINLOG_INFO("quit command received");
      return true;
    }
  }

  return false;
}
Attention:  ./examples/05-flow_tracking/Application.C
/**
* Data flow tracking in Binlog
*
* Before reading this, please read the
* Data Flow tracking section in the UserGuide
*
* This example is a simplified version
* of test/integration/FlowWriter.C
*
* Things to be learned here:
*  - How to define a data flow
*  - How to mark flow boundaries explicitly
*/

#include <iostream>
#include <random>
#include <thread>

#include <boost/lockfree/queue.hpp>
#include <boost/lexical_cast.hpp>

#define BINLOG_USER_RELEASE "example_flow"
#include <binlog/Binlog.H>
BINLOG_INIT

/*
* This example launches two threads,
* a producer and a consumer, passing
* entities between each other.
*
* The Entity has a natural id,
* it will serve as a flow id.
*/

typedef std::ranlux48_base RandomGenerator;

struct Entity
{
  std::size_t id;
  RandomGenerator::result_type hash;
  std::size_t counter;
};

// Communication channel
typedef boost::lockfree::queue<
  Entity,
  boost::lockfree::capacity<1 << 10>
> Queue;

Queue entityQueue;

void sleep()
{
  std::this_thread::sleep_for(std::chrono::milliseconds{1});
}

/**
* Creates entities with random generated
* hash values and pushes them into `entityQueue`
*/
void producer(const std::size_t entityCount)
{
  RandomGenerator generator;

  // This event source is not part of a flow
  BINLOG_INFO("Producer starts, generated hash look like: {0}", generator());

  for (std::size_t i = 0; i < entityCount; ++i)
  {
    // create an entity
    Entity entity{i, generator(), 1};

    /*
     * This event source has a named placeholder `{0:entityId}`
     * thus it belong to the `entityId` flow.
     */
    BINLOG_INFO("Entity created, id: {0:entityId}, hash: {1}", entity.id, entity.hash);

    while( ! entityQueue.push(entity))
    {
      /*
       * Events emitted by this event source will be also part of
       * the `entityId` flow, because they are always preceded by
       * a flow event.
       */
      BINLOG_WARNING("Producer failed to enqueue entity, try again");
      sleep();
    }

    /*
     * End the flow explicitly on this thread
     *
     * This call is optional
     *
     * Subsequent events with no explicit flow specifier
     * will belong to no flow.
     */
    BINLOG_END_FLOW("{0:entityId}", entity.id);
  }

  /*
   * Because of the explicit flow end,
   * the last event of this thread won't
   * belong to any flow.
   */
  BINLOG_INFO("Producer exits after {0} entities", entityCount);
}

void consumer(const std::size_t entityCount)
{
  BINLOG_INFO("Consumer starts");

  std::size_t recvEntityCount = 0;

  while (recvEntityCount < entityCount)
  {
    Entity entity;

    std::size_t tryCount = 0;
    while (tryCount < 10 && ! entityQueue.pop(entity))
    {
      ++tryCount;
    }

    if (tryCount < 10)
    {
      /*
       * Begin flow explicitly
       *
       * This is optional; any other log macro will start
       * a flow if it has a named placeholder.
       *
       * Events emitted by this event source will not show
       * up in the Reader listing.
       */
      BINLOG_BEGIN_FLOW("Hello {0:entityId}", entity.id);

      BINLOG_INFO("Entity received! id: {0:entityId}", entity.id);

      entity.counter++;

      if (entity.hash % 10 == 0 && entity.counter < 18)
      {
        BINLOG_WARNING("This entity does not look well...");
      }

      BINLOG_INFO("Consume entity...");
      ++recvEntityCount;

      /*
       * This call is still optional, even if we had a
       * BINLOG_BEGIN_FLOW before.
       */
      BINLOG_END_FLOW("{0:entityId} bye...", entity.id);
    }
    else
    {
      BINLOG_DEBUG("No input in consumer queue after 10 tries");
      sleep();
    }
  }

  BINLOG_INFO("Consumer exits");
}

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-example-05.log";
  const std::size_t entityCount = (argc >= 3) ? boost::lexical_cast<std::size_t>(argv[2]) : 50;

  binlog::openLogFile(logfile);

  std::thread prod(producer, entityCount);
  std::thread cons(consumer, entityCount);

  prod.join();
  cons.join();

  std::cout << "The log file was written to: '" << logfile
    << "'. To see the contents, execute the logfile.\n"
       "Try to experiment with different flow commands:\n  "
       << logfile << " # regular output"   "\n  "
       << logfile << " --group entityId"   "\n  "
       << logfile << " --flow"             "\n  "
       << logfile << " --flow entityId"    "\n  "
       << logfile << " --flow entityId:0"
    << std::endl;

  return 0;
}
Attention:  ./examples/01-basics/Application.C
/**
* Basic usage of the Binlog logging library
*
* Things to be learned here:
*  - Mandatory category setup
*  - Opening logfile
*  - Create simple events
*/

#include <iostream>

#include <binlog/Binlog.H>

/*
* Initialize Binlog.
*
* This call must be in no namespace,
* in a source file. (*.C, *.cpp)
*
* Since every executable and DSO must have it,
* Binlog is not able to do it for you.
*/
BINLOG_INIT

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-example-01.log";

  /**
   * In this example, we save the log in a file.
   * Let's open log file now.
   *
   * This call might be preceded by log calls.
   * The previously created log entries will
   * be written upon opening, no event is lost.
   */
  binlog::openLogFile(logfile);

  /**
   * Let's log an event using one the log
   * macros. Multiple severities and argument
   * types are accepted.
   *
   * Please see the User Guide for the available
   * severities, loggable argument types and
   * format string tricks.
   */
  BINLOG_INFO("The log file was written to: {0}", logfile);

  // Let's produce some more events
  for (int i = 10; i >= 0; --i)
  {
    BINLOG_WARNING("It's the final countdown: {0}", i);
  }

  std::cout << "The log file was written to: '" << logfile
    << "'. To see the contents, execute the logfile.\n"
       "Try to experiment with different format strings:\n\n"
       << logfile <<                               "\n"
       << logfile << " --format \"%S [%d] %t %m\"" "\n"
       << logfile << " --format \"%S %L %m\""      "\n"
       "\nFor more options, see --help"
    << std::endl;

  // THE END
  return 0;
}
Attention:  ./test/perf/Dumper.C
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <memory>

#define BINLOG_USER_RELEASE "perftest_dumper"
#include <binlog/Binlog.H>

BINLOG_INIT

void producer(const long messageCount)
{
  const long cycleCount = messageCount >> 2;

  std::string strArg("foobar");

  for (long i = 0; i < cycleCount; ++i)
  {
    BINLOG_INFO("Cycle Start: {0}", i);

    BINLOG_CRITICAL("A critical event, and a string arg: {0}", strArg);
    BINLOG_WARNING("Multiple arguments: {3}, {2}, {1}, {0}", 1, 2u, 3, 4l);

    BINLOG_INFO("Cycle End: {0}", i);
  }
}

int main(int argc, char* argv[])
{
  const char* outputFile    = (argc > 1) ? argv[1] : "/tmp/binlog-dump.log";
  const std::size_t threadCount     = (argc > 2) ? std::stoul(argv[2]) : 2u;
  const std::size_t messageCount    = (argc > 3) ? std::stoul(argv[3]) : 10000u;
  const std::size_t startupSleepSec = (argc > 4) ? std::stoul(argv[4]) : 3u;

  binlog::openLogFile(outputFile);

  // sleep here makes collector thread lazy
  // this will result in a bunch of unsorted event blocks
  {
    std::cout << "Sleep... ";
    std::chrono::seconds startupSleep(startupSleepSec);
    std::this_thread::sleep_for(startupSleep);
    std::cout << "done." << std::endl;
  }

  auto threads = std::unique_ptr<std::thread[]>(new std::thread[threadCount]);

  // launch threads
  std::cout << "Launch threads" << std::endl;
  for (std::size_t i = 0; i < threadCount; ++i)
  {
    threads[i] = std::thread(producer, messageCount);
  }

  // join threads
  for (std::size_t i = 0; i < threadCount; ++i)
  {
    threads[i].join();
  }

  return 0;
}
Attention:  ./test/perf/Perftest.C
#include <thread>
#include <iostream>
#include <climits>
#include <atomic>
#include <memory>

/*
* This perftest demo comes with utune support
*
* Example utune command line (performance monitoring):
*
* /ms/dist/mstk/PROJ/utune/dev/utune \
    --temp-dir /var/tmp/$USER \
    --config utune-pmu-config.xml \
    --report-dir /var/tmp/$USER/binlog-utune-pmu \
    -- ./UtunePerftest 1 10000
*
* Similar, but branch tracing mode:
* /ms/dist/mstk/PROJ/utune/dev/utune \
    --temp-dir /var/tmp/$USER \
    --config utune-bts-config.xml \
    --report-dir /var/tmp/$USER/binlog-utune-bts \
    --record-branch-trace \
    -- ./UtunePerftest 1 10000
*
* Both measures 10.000 events emitted by a single thread
*/

#include "UTune.HPP"

#define BINLOG_USER_RELEASE "perftest"
#include <binlog/Binlog.H>
#include <binlog/detail/Time.H>
#include <binlog/sink/Consumer.H>
#include <binlog/sink/FileSink.H>
#include <binlog/sink/PlaintextSink.H>

BINLOG_INIT

using binlog::detail::tscToSeconds;
using binlog::detail::readTsc;

void printElapsed(uint64_t elapsedTsc, const int messageCount)
{
  auto elapsedSec = tscToSeconds(elapsedTsc);

  std::cout << "Elapsed time: " << elapsedSec << " seconds, " <<
    elapsedSec * 1000 * 1000 / messageCount << " microseconds per message" << std::endl;
}

template <typename Func>
void producer(Func& func, const int messageCount)
{
  BINLOG_INFO("Perftest thread warmup: {0}", 1);

  // avoid moving string ctor after readTsc();
  std::atomic_thread_fence(std::memory_order_release);

  auto start = readTsc();

  for (int i = 0; i < messageCount; ++i)
  {
    func(i);
  }

  std::atomic_thread_fence(std::memory_order_release);
  auto end = readTsc();
  printElapsed(end - start, messageCount);
}

template <typename Func>
void launcher(
  Func& func,
  const std::size_t threadCount,
  const int messageCount
)
{
  auto threads = std::unique_ptr<std::thread[]>(new std::thread[threadCount]);

  // launch threads
  for (std::size_t i = 0; i < threadCount; ++i)
  {
    threads[i] = std::thread(producer<Func>, std::ref(func), messageCount);
  }

  // join threads
  for (std::size_t i = 0; i < threadCount; ++i)
  {
    threads[i].join();
  }
}

void producerTest(std::size_t threadCount, int messageCount)
{
  binlog::sink::Consumer<binlog::sink::FileSink> consumer("/tmp/binlog-perftest.log");
  consumer.start();

  std::cout << "Run Perftest on " << threadCount << " threads, "
    "each logs " << messageCount << " events" << std::endl;

  std::string str("abcdefg");

  std::cout << "Int and string:" << std::endl;

  auto logIntAndString = [&str](int i)
  {
    UTUNE_PROBE(enter_int_and_string);
    BINLOG_INFO("The argument of message #{0} is: '{1}'", i, str);
    UTUNE_PROBE(leave_int_and_string);
  };
  launcher(logIntAndString, threadCount, messageCount);

  std::cout << "Single integer:" << std::endl;

  auto logInt = [](int i)
  {
    UTUNE_PROBE(enter_int);
    BINLOG_INFO("This is the #{0}. event", i);
    UTUNE_PROBE(leave_int);
  };
  launcher(logInt, threadCount, messageCount);
}

void consumerTest(int messageCount)
{
  std::cout << "Transforming to plaintext:" << std::endl;

  using binlog::sink::PlaintextSink;

  binlog::sink::Consumer<PlaintextSink> consumer(
    [](PlaintextSink::Event& event)
    {
      (void)event;
    }
  );

  // warmup
  BINLOG_INFO("Perftest thread warmup: {0}", 1);

  consumer.consume();

  for (int i = 0; i < messageCount; ++i)
  {
    BINLOG_INFO("This is the #{0}. event", i);
  }

  std::atomic_thread_fence(std::memory_order_release);

  auto start = readTsc();

  bool run = true;
  while (run)
  {
    UTUNE_PROBE(enter_consume);
    run = consumer.consume();
    UTUNE_PROBE(leave_consume);
  }

  std::atomic_thread_fence(std::memory_order_release);
  auto end = readTsc();
  printElapsed(end - start, messageCount);
}

/**
* Configuration:
*
* @param argc == 3
* @param argv[1] std::size_t thread count
* @param argv[2] int message count / thread
*/
int main(int argc, char* argv[])
{
  // parse args
  if (argc < 3)
  {
    std::cerr << "Usage: "
      << argv[0] << " threadCount messageCount"
      << std::endl;

    return 1;
  }

  const std::size_t threadCount = std::stoul(argv[1]);
  const int messageCount = std::stoi(argv[2]);

  // warmup
  BINLOG_INFO("Perftest warmup: {0}", 1);
  BINLOG_INFO("Avoid runtime DSO binding: {0}", std::string("foobar"));

  producerTest(threadCount, messageCount);

  consumerTest(messageCount);

  return 0;
}
Attention:  ./test/unit/Testfile.C
#include "Testfile.H"

#include <cstdlib> // mkstemp
#include <stdexcept>
#include <errno.h> // perror
#include <unistd.h> // unlink

namespace binlog {
namespace test {

Testfile::Testfile(const std::string& content)
{
  char filename[] = "/tmp/binlog_testdata_XXXXXX";
  int tmpfile = mkstemp(filename);
  if (tmpfile == -1)
  {
    perror("mkstemp");
    throw std::runtime_error("Failed to create testfile");
  }

  // tmpfile is opened for r/w
  write(tmpfile, content.data(), content.size());
  close(tmpfile);

  _path = filename;
}

Testfile::~Testfile()
{
  unlink(_path.c_str());
}

const std::string& Testfile::getPath() const
{
  return _path;
}

} // namespace test
} // namespace binlog
Attention:  ./test/unit/FileInputStreamTest.C
#include <string>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/reader/FileInputStream.H>

#include "Testfile.H"

using binlog::reader::FileInputStream;
using binlog::reader::detail::InputStream;

BOOST_AUTO_TEST_SUITE(FileInputStreamSuite)

BOOST_AUTO_TEST_CASE(Basics)
{
  binlog::test::Testfile file("abcdefghijklmnopqrstvwxyz");
  FileInputStream fileStr(file.getPath(), false);
  InputStream& str(fileStr);

  // Seeking

  BOOST_TEST(0 == str.tellg());
  BOOST_TEST(str.seekg(10));
  BOOST_TEST(10 == str.tellg());
  BOOST_TEST(str.seekg(0));
  BOOST_TEST(0 == str.tellg());

  // Reading
  BOOST_TEST("" == str.readShebang());

  BOOST_TEST(!!str);

  char c = 0;
  BOOST_TEST(str.read(c));
  BOOST_TEST('a' == c);
  BOOST_TEST(str.read(c));
  BOOST_TEST('b' == c);

  char buf[10];
  BOOST_TEST(10 == str.read(buf, 10));

  BOOST_TEST(!!str);

  char rest[100];
  str.read(rest, 100);

  BOOST_TEST(! !!str);
}

BOOST_AUTO_TEST_CASE(Shebang)
{
  binlog::test::Testfile file(
    "#!/foo/bar/baz\n"
    "abcdefghijklmnopqrstvwxyz"
  );
  FileInputStream str(file.getPath(), false);

  BOOST_TEST("#!/foo/bar/baz\n" == str.readShebang());
}

BOOST_AUTO_TEST_CASE(LongShebang)
{
  binlog::test::Testfile file(
    "#!/afoo/bar/baz/foo/bar/baz/foo/bar/baz"
    "/bfoo/bar/baz/foo/bar/baz/foo/bar/baz"
    "/cfoo/bar/baz/foo/bar/baz/foo/bar/baz"
    "/dfoo/bar/baz/foo/bar/baz/foo/bar/baz"
    "/efoo/bar/baz/foo/bar/baz/foo/bar/baz"
    "/ffoo/bar/baz/foo/bar/baz/foo/bar/baz\n"
    "abcdefghijklmnopqrstvwxyz"
  );
  FileInputStream str(file.getPath(), false);

  BOOST_TEST(
    "#!/afoo/bar/baz/foo/bar/baz/foo/bar/baz"
    "/bfoo/bar/baz/foo/bar/baz/foo/bar/baz"
    "/cfoo/bar/baz/foo/bar/baz/foo/bar/baz"
    "/dfoo/bar/baz/foo/bar/baz/foo/bar/baz"
    "/efoo/bar/baz/foo/bar/baz/foo/bar/baz"
    "/ffoo/bar/baz/foo/bar/baz/foo/bar/baz\n"
    == str.readShebang()
  );

}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/FdTest.C
#include <unistd.h>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/detail/Fd.H>

using namespace binlog::detail;

BOOST_AUTO_TEST_SUITE(FdSuite)

BOOST_AUTO_TEST_CASE(Basics)
{
  int x = dup(STDIN_FILENO);
  Fd a(x);
  BOOST_TEST(!!a);

  Fd b;
  BOOST_TEST(!b);

  b = std::move(a);
  BOOST_TEST(!a);
  BOOST_TEST(!!b);

  BOOST_TEST(*b == x);

  Fd c(std::move(b));
  BOOST_TEST(!b);
  BOOST_TEST(!!c);

  c.close();
  BOOST_TEST(!b);
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/CoreTest.C
#include <memory>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/detail/Core.H>
#include <binlog/detail/WaitStrategy.H>

using binlog::detail::Core;

namespace binlog {

namespace detail {
namespace test   {

struct CoreFactory
{
  static Core& create()
  {
    static std::unique_ptr<Core> ptr;
    ptr.reset(new Core());
    return *ptr;
  }
};

} // namespace test
} // namespace detail

namespace sink {
  class ConsumerBase;
} // namespace sink

} // namespace binlog

using binlog::detail::test::CoreFactory;

BOOST_AUTO_TEST_SUITE(CoreSuite)

BOOST_AUTO_TEST_CASE(acquireRelease)
{
  using binlog::sink::ConsumerBase;
  auto&& core = CoreFactory::create();

  ConsumerBase* consumerA = reinterpret_cast<ConsumerBase*>(0xBABA);
  ConsumerBase* consumerB = reinterpret_cast<ConsumerBase*>(0xBEEF);

  BOOST_TEST(  core.tryAcquire(consumerA));
  BOOST_TEST(! core.tryAcquire(consumerB));
  BOOST_TEST(  core.tryRelease(consumerA));
  BOOST_TEST(! core.tryRelease(consumerA));

  BOOST_TEST(  core.tryAcquire(consumerB));
  BOOST_TEST(! core.tryAcquire(consumerA));
  BOOST_TEST(  core.tryRelease(consumerB));
}

struct DummyConsumer
{
  void operator()(const char*, std::size_t) {}
};

BOOST_AUTO_TEST_CASE(empty)
{
  auto&& core = CoreFactory::create();
  DummyConsumer consumer;

  BOOST_TEST(core.empty());

  {
    auto tcPtr = std::make_shared<binlog::detail::ThreadContext>();
    BOOST_TEST((tcPtr->getEntryQueue().reserve(10) != nullptr));
    tcPtr->getEntryQueue().commit(10);

    core.reportThread(tcPtr);

    BOOST_TEST(! core.empty());

    while (core.consumeOne(consumer)) /* spin */;

    // tcPtr is alive, but empty
    BOOST_TEST(core.empty());
  }

  while (core.consumeOne(consumer)) /* spin */;
  BOOST_TEST(core.empty()); // tcPtr is dead
}

struct DummyWaitStrategy : public binlog::detail::WaitStrategy
{
public:
  bool notified = false;

  void reset() {}
  void wait() {}
  void notify() { notified = true; };
};

BOOST_AUTO_TEST_CASE(notify)
{
  auto&& core = CoreFactory::create();
  core.notifyConsumer(); // should not crash

  DummyWaitStrategy ws;

  core.setConsumerWaitStrategy(&ws);
  core.notifyConsumer();
  BOOST_TEST(ws.notified);
  ws.notified = false;

  core.setConsumerWaitStrategy(nullptr);
  core.notifyConsumer(); // should not crash
  BOOST_TEST(! ws.notified);
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/EntryTest.C
#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/detail/Entry.H>

using namespace binlog::detail;

BOOST_AUTO_TEST_SUITE(Entry)

BOOST_AUTO_TEST_CASE(getMemoryTest)
{
  const std::size_t memSize = 1 << 10;
  for (std::size_t i = 0; i < 50000; ++i)
  {
    auto memory = getMemory(memSize);
    memory.commit(memSize);
  }

  BOOST_TEST(true);
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/SerializeTest.C
#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/detail/Serialize.H>
#include <binlog/detail/asm.H>

namespace {

struct SimplePerson
{
  std::string name;
  int age;
};

class Person
{
public:
  int age = 27;
  virtual ~Person() {}
  virtual std::string getName() const { return "?"; }
};

class NamedPerson : public Person
{
  std::string getName() const override { return "Joe"; }
};

} // namespace

BINLOG_MAKE_LOGGABLE(Person, age, getName)
BINLOG_MAKE_LOGGABLE(SimplePerson, name, age)

BOOST_AUTO_TEST_SUITE(Serialize)

BOOST_AUTO_TEST_CASE(int_)
{
  int a = 1;
  BOOST_TEST(sizeof(a) == binlog::detail::argumentsSerializedSize(a));
}

BOOST_AUTO_TEST_CASE(unsigned_)
{
  unsigned a = 1;
  BOOST_TEST(sizeof(a) == binlog::detail::argumentsSerializedSize(a));
}

BOOST_AUTO_TEST_CASE(char_)
{
  char a = 1;
  BOOST_TEST(sizeof(a) == binlog::detail::argumentsSerializedSize(a));
}

BOOST_AUTO_TEST_CASE(constcharstar)
{
  const char* a = "123456";
  BOOST_TEST(7u == binlog::detail::argumentsSerializedSize(a));
}

BOOST_AUTO_TEST_CASE(chararray)
{
  char a[] = "612345";
  BOOST_TEST(7u == binlog::detail::argumentsSerializedSize(a));
}

BOOST_AUTO_TEST_CASE(constchararray)
{
  const char a[] = "612354";
  BOOST_TEST(7u == binlog::detail::argumentsSerializedSize(a));
}

BOOST_AUTO_TEST_CASE(volatileconstcharstar)
{
  volatile const char* a = "volatile_charp";
  BOOST_TEST(15u == binlog::detail::argumentsSerializedSize(a));
}

BOOST_AUTO_TEST_CASE(stdstring)
{
  std::string a("561234");
  BOOST_TEST(7u == binlog::detail::argumentsSerializedSize(a));
}

BOOST_AUTO_TEST_CASE(sumSizeOfStruct)
{
  SimplePerson p{"foo", 123};
  BOOST_TEST(16u == binlog::detail::argumentsSerializedSize(p));
}

BOOST_AUTO_TEST_CASE(sumSizeOfStructWithGetter)
{
  NamedPerson joe;
  Person& person = joe;
  BOOST_TEST(16u == binlog::detail::argumentsSerializedSize(person));
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/BufferTest.C
#include <string>
#include <cstring>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/reader/detail/Buffer.H>

using binlog::reader::detail::Buffer;
using binlog::reader::detail::ReadBuffer;
using binlog::reader::detail::WriteBuffer;

BOOST_AUTO_TEST_SUITE(Buffers)

BOOST_AUTO_TEST_CASE(Basics)
{
  Buffer buffer(10);

  BOOST_TEST(buffer.size() == 10);

  buffer.reset(5);

  BOOST_TEST(buffer.size() == 5);
}

BOOST_AUTO_TEST_CASE(ReadBufferBasics)
{
  ReadBuffer reader("foobar\nbarbaz");

  std::string foobar;
  BOOST_TEST(reader.readline(foobar, '\n'));
  BOOST_TEST(foobar == "foobar");

  char barbaz[] = "123456";
  BOOST_TEST(reader.read(barbaz, 6));
  BOOST_TEST(strcmp(barbaz, "barbaz") == 0);
}

BOOST_AUTO_TEST_CASE(ReadBufferTypedRead)
{
  int value = 5;
  ReadBuffer reader(reinterpret_cast<const char*>(&value), sizeof(int));

  int actual;
  BOOST_TEST(reader.read(actual));

  BOOST_TEST(value == actual);
}

BOOST_AUTO_TEST_CASE(WriteBufferBasics)
{
  WriteBuffer ba;
  const std::size_t zero = 0;
  ba.write(zero);
  ba.write("abcdefgh", 8);

  WriteBuffer bb;
  const std::size_t size = 173;
  const std::size_t tag = -7lu;
  bb.write(size);
  bb.write(tag);
  bb.write(ba.get(), ba.size());

  const std::size_t actualSize = *reinterpret_cast<const std::size_t*>(bb.get());

  BOOST_TEST(size == actualSize);
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/Unittest.C
#define BOOST_TEST_MODULE Binlog Unittest
#define BOOST_TEST_DYN_LINK
#include <boost/test/unit_test.hpp>

// Since no BOOST_TEST_NO_MAIN is defined,
// main function will be generated by Boost.Test
Attention:  ./test/unit/PreambleTest.C
#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/detail/Preamble.H>
#include <binlog/detail/ThisThreadContext.H>

namespace binlog {
namespace detail {
namespace test   {

struct PreambleFactory
{
  static Preamble& create()
  {
    static std::unique_ptr<Preamble> ptr;
    ptr.reset(new Preamble());
    return *ptr;
  }
};

} // namespace test
} // namespace detail
} // namespace binlog

using binlog::detail::test::PreambleFactory;

BOOST_AUTO_TEST_SUITE(Preamble)

BOOST_AUTO_TEST_CASE(addReadAdd)
{
  using binlog::detail::ThisThreadContext;

  auto&& queue = ThisThreadContext::get().getEntryQueue();

  // empty TL queue
  std::size_t batchSize = 0;
  while (queue.checkout(batchSize))
  {
    queue.dispose(batchSize);
  }

  auto&& preamble = PreambleFactory::create();

  char buf[] = "abcd";
  preamble.addBuffer(buf, 4);

  // preamble is not yet consumed, no forwarding was done
  BOOST_TEST(! queue.checkout(batchSize));

  preamble.readPreamble([](const char*, std::size_t size)
  {
    BOOST_TEST(size >= 4); // at least we have the buffer sent before
  });

  // add something again
  preamble.addBuffer(buf, 4);

  // forwarding was enabled by the readPreamble
  batchSize = 0;
  queue.checkout(batchSize);
  BOOST_TEST(batchSize >= 4);

  // cleanup
  queue.dispose(batchSize);
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/PatternTest.C
#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/detail/Pattern.H>

using binlog::detail::Pattern;

BOOST_AUTO_TEST_SUITE(PatternSuite)

BOOST_AUTO_TEST_CASE(matchesBasic)
{
  Pattern p("foo/bar/baz");
  BOOST_TEST(p.matches("foo/bar/baz"));
  BOOST_TEST(p.matches("foo/bar/baz/qux"));

  BOOST_TEST(! p.matches("foo/xyz/baz"));
  BOOST_TEST(! p.matches(""));
}

BOOST_AUTO_TEST_CASE(matchesWildcard)
{
  Pattern p("foo/*/baz");
  BOOST_TEST(p.matches("foo/bar/baz"));
  BOOST_TEST(p.matches("foo/bar/baz/qux"));
  BOOST_TEST(p.matches("foo/xyz/baz/qux"));

  BOOST_TEST(! p.matches("foo/xyz/wrong"));
}

BOOST_AUTO_TEST_CASE(matchesDoubleWildcard)
{
  Pattern p("*/foo/*");
  BOOST_TEST(p.matches("foo/foo/baz"));
  BOOST_TEST(p.matches("foo/foo/baz/qux"));
  BOOST_TEST(p.matches("baz/foo/baz/qux"));

  BOOST_TEST(! p.matches("foo/xyz/wrong"));
}

BOOST_AUTO_TEST_CASE(matchesWildcardAnySep)
{
  Pattern p("foo*bar*");
  BOOST_TEST(p.matches("foo/foo/bar"));
  BOOST_TEST(p.matches("foo/foo/bar_any"));

  BOOST_TEST(! p.matches("foo/foo"));
  BOOST_TEST(! p.matches("foo/foo/baz/qux"));
  BOOST_TEST(! p.matches("foo/xyz/wrong"));
}

BOOST_AUTO_TEST_CASE(matchesSingleWildcard)
{
  Pattern p("*");

  BOOST_TEST(p.matches("foobar"));
  BOOST_TEST(p.matches(""));
  BOOST_TEST(p.matches("*"));
}

BOOST_AUTO_TEST_CASE(replaceBasic)
{
  Pattern nonmatching("foo/baz");
  Pattern matching("bar/b");

  std::string input("foo/bar/baz");
  std::string original = input;

  BOOST_TEST(! nonmatching.replace(input, "nope"));
  BOOST_TEST(input == original);

  BOOST_TEST(matching.replace(input, "baz/q"));
  BOOST_TEST("foo/baz/qaz" == input);
}

BOOST_AUTO_TEST_CASE(replaceWildcard)
{
  Pattern nonmatching("foo/*/baz");
  Pattern matching("foo/*/bar");

  std::string input("foo/baz/bar/qux");

  BOOST_TEST(! nonmatching.replace(input, "xyz"));

  BOOST_TEST(matching.replace(input, "foo/rep/bar"));
  BOOST_TEST("foo/rep/bar/qux" == input);
}

BOOST_AUTO_TEST_CASE(replaceWildcardBegin)
{
  Pattern nonmatching("*/xyz");
  Pattern matching("*bar");

  std::string input("foo/laz/bar/qux");

  BOOST_TEST(! nonmatching.replace(input, "qwe"));
  BOOST_TEST(matching.replace(input, "rep/bar"));
  BOOST_TEST("rep/bar/qux" == input);
}

BOOST_AUTO_TEST_CASE(replaceWildcardEnd)
{
  Pattern matching("baz/*");

  std::string input("foo/baz/bar/qux");

  BOOST_TEST(matching.replace(input, "baz/rep"));
  BOOST_TEST("foo/baz/rep" == input);
}

BOOST_AUTO_TEST_CASE(replaceSingleWildcard)
{
  Pattern matching("*");

  std::string input("foobar");
  BOOST_TEST(matching.replace(input, "barbaz"));
  BOOST_TEST("barbaz" == input);

  std::string input2("");
  BOOST_TEST(matching.replace(input2, "not-empty"));
  BOOST_TEST("not-empty" == input2);
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/ThisThreadContextTest.C
#include <thread>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/detail/ThisThreadContext.H>

using binlog::detail::ThisThreadContext;

void changeThreadName()
{
  auto& otherTc = ThisThreadContext::get();
  otherTc.setName("otherThread");
}

BOOST_AUTO_TEST_SUITE(ThisThreadContextSuite)

BOOST_AUTO_TEST_CASE(contextIsThreadLocal)
{
  {
    auto& tc = ThisThreadContext::get();
    tc.setName("myThread");
  }

  {
    auto& sameTc = ThisThreadContext::get();
    BOOST_TEST(std::string(sameTc.getThreadName().data()) == "myThread");
  }

  std::thread t(changeThreadName);
  t.join();

  {
    auto& sameTc = ThisThreadContext::get();
    BOOST_TEST(std::string(sameTc.getThreadName().data()) == "myThread");
  }
}

BOOST_AUTO_TEST_CASE(queueIsElastic)
{
  // new queue is allocated when needed, but lwp and thread name are kept
  // new queue should accomodate excess request

  auto& tc = ThisThreadContext::get();

  const std::string name("Ariadne's thread");
  tc.setName(name);
  int lwp = tc.getLwp();

 const std::size_t bigReqSize = tc.getEntryQueue().maxRequestSize() * 2;
  ThisThreadContext::resetQueue(bigReqSize);

  auto& newTc = ThisThreadContext::get();
  BOOST_TEST(lwp == newTc.getLwp());
  BOOST_TEST(name == std::string(newTc.getThreadName().data()));
  BOOST_TEST(newTc.getEntryQueue().maxRequestSize() >= bigReqSize);
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/MultiSinkTest.C
#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/sink/MultiSink.H>

namespace {

struct DummySink : binlog::sink::Sink
{
  void operator()(const char*, std::size_t) {}
};

} // namespace

using binlog::sink::MultiSink;

BOOST_AUTO_TEST_SUITE(MultiSinkSuite)

BOOST_AUTO_TEST_CASE(toggleSink)
{
  MultiSink multiSink;

  DummySink dummySink1;
  DummySink dummySink2;

  auto all     = [](const MultiSink::EventSource&) { return true;  };
  auto nothing = [](const MultiSink::EventSource&) { return false; };

  multiSink.addSink(dummySink1, all);
  multiSink.addSink(dummySink2, nothing);

  BOOST_TEST(multiSink.toggleSink(dummySink1, true));
  BOOST_TEST(multiSink.toggleSink(dummySink2, false));

  DummySink unregisteredSink;

  BOOST_TEST(! multiSink.toggleSink(unregisteredSink, false));
}

BOOST_AUTO_TEST_CASE(addRemoveSink)
{
  MultiSink multiSink;

  DummySink dummySink1;

  auto all = [](const MultiSink::EventSource&) { return true; };

  multiSink.addSink(dummySink1, all);

  BOOST_TEST(multiSink.toggleSink(dummySink1, true));
  BOOST_TEST(multiSink.removeSink(dummySink1));
  BOOST_TEST(! multiSink.removeSink(dummySink1));
  BOOST_TEST(! multiSink.toggleSink(dummySink1, true));
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/ConfigurationTest.C
#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#define BINLOG_USER_RELEASE "unittest"

#include <binlog/Binlog.H>
#include <binlog/Configuration.H>

BINLOG_INIT

BOOST_AUTO_TEST_SUITE(Configuration)

BOOST_AUTO_TEST_CASE(initFromConfigError)
{
  binlog::Configuration config;

  std::error_code ec;
  bool ok = config.initFromConfig("/root/invalid-foobar.json", ec);
  BOOST_TEST(! ok);
  BOOST_TEST(! !ec);

  BOOST_CHECK_THROW(config.initFromConfig("/root/invalid-foobar.json"), std::runtime_error);
}

__attribute__((visibility("default")))
void dummy()
{
  BINLOG_INFO("Let's have a message source");
  BINLOG_INFO("Let's have an other");
}

// must be a global object mapped from file, not on the heap or stack
binlog::detail::ElfConfig elfConf __attribute__((section(".data")));

BOOST_AUTO_TEST_CASE(elfConfigTestBit)
{
  BOOST_TEST(elfConf.getSourceCount() > 1);

  BOOST_TEST(elfConf.isSourceEnabled(0));

  elfConf.disableSource(1);

  BOOST_TEST(elfConf.isSourceEnabled(0));

  elfConf.disableSource(0);

  BOOST_TEST(! elfConf.isSourceEnabled(0));

  elfConf.enableSource(0);

  BOOST_TEST(elfConf.isSourceEnabled(0));
}

BOOST_AUTO_TEST_CASE(categoryConfig)
{
  binlog::CategoryConfig c1;
  binlog::CategoryConfig c2;
  binlog::CategoryConfig c3;
  binlog::CategoryConfig c4;
  binlog::CategoryConfig c5;

  binlog::Configuration config;

  config.registerCategory("foo/bar/cat1", c1);
  config.registerCategory("foo/bar/cat1", c2);
  config.registerCategory("foo/bar/cat1/subcat", c3);
  config.registerCategory("foo/baz/cat2", c4);
  config.registerCategory("3rd/baz/cat1", c5);

  BOOST_TEST(c1.minSeverity == binlog::debug);
  BOOST_TEST(c2.minSeverity == binlog::debug);
  BOOST_TEST(c3.minSeverity == binlog::debug);
  BOOST_TEST(c4.minSeverity == binlog::debug);
  BOOST_TEST(c5.minSeverity == binlog::debug);

  config.setCategoryConfig("foo/bar/cat1/subcat", {binlog::info});

  BOOST_TEST(c1.minSeverity == binlog::debug);
  BOOST_TEST(c2.minSeverity == binlog::debug);
  BOOST_TEST(c3.minSeverity == binlog::info);
  BOOST_TEST(c4.minSeverity == binlog::debug);
  BOOST_TEST(c5.minSeverity == binlog::debug);

  config.setCategoryConfig("foo/bar/cat1", {binlog::warning});

  BOOST_TEST(c1.minSeverity == binlog::warning);
  BOOST_TEST(c2.minSeverity == binlog::warning);
  BOOST_TEST(c3.minSeverity == binlog::warning);
  BOOST_TEST(c4.minSeverity == binlog::debug);
  BOOST_TEST(c5.minSeverity == binlog::debug);

  config.setCategoryConfig("foo/*/*", {binlog::error});

  BOOST_TEST(c1.minSeverity == binlog::error);
  BOOST_TEST(c2.minSeverity == binlog::error);
  BOOST_TEST(c3.minSeverity == binlog::error);
  BOOST_TEST(c4.minSeverity == binlog::error);
  BOOST_TEST(c5.minSeverity == binlog::debug);

  config.setCategoryConfig("*", {binlog::critical});

  BOOST_TEST(c1.minSeverity == binlog::critical);
  BOOST_TEST(c2.minSeverity == binlog::critical);
  BOOST_TEST(c3.minSeverity == binlog::critical);
  BOOST_TEST(c4.minSeverity == binlog::critical);
  BOOST_TEST(c5.minSeverity == binlog::critical);

  config.setCategoryConfig("*/*/cat1", {binlog::debug});

  BOOST_TEST(c1.minSeverity == binlog::debug);
  BOOST_TEST(c2.minSeverity == binlog::debug);
  BOOST_TEST(c3.minSeverity == binlog::debug);
  BOOST_TEST(c4.minSeverity == binlog::critical);
  BOOST_TEST(c5.minSeverity == binlog::debug);
}

BOOST_AUTO_TEST_CASE(categoryConfigPreset)
{
  binlog::CategoryConfig c1;

  binlog::Configuration config;

  config.setCategoryConfig("foo/*/bar", {binlog::critical});
  config.registerCategory("foo/baz/bar", c1);

  BOOST_TEST(c1.minSeverity == binlog::critical);
}

BOOST_AUTO_TEST_CASE(categoryConfigPresetBatch)
{
  binlog::CategoryConfig c1;
  binlog::CategoryConfig c2;
  binlog::CategoryConfig c3;
  binlog::CategoryConfig c4;

  binlog::Configuration config;

  config.setCategoryConfigs({
    {"foo/bar/cat1", {binlog::info}}
  });

  config.registerCategory("foo/bar/cat1", c1);
  config.registerCategory("foo/bar/cat2", c2);
  config.registerCategory("foo/baz/xyzN", c3);
  config.registerCategory("bar/baz/xyzN", c4);

  BOOST_TEST(c1.minSeverity == binlog::info);
  BOOST_TEST(c2.minSeverity == binlog::debug);
  BOOST_TEST(c3.minSeverity == binlog::debug);
  BOOST_TEST(c4.minSeverity == binlog::debug);

  config.setCategoryConfigs({
    {"foo/bar/cat1", {binlog::info}},
    {"foo/bar/",     {binlog::warning}}
  });

  BOOST_TEST(c1.minSeverity == binlog::info);
  BOOST_TEST(c2.minSeverity == binlog::warning);
  BOOST_TEST(c3.minSeverity == binlog::debug);
  BOOST_TEST(c4.minSeverity == binlog::debug);

  config.setCategoryConfigs({
    {"foo/bar/cat1", {binlog::info}},
    {"foo/bar/",     {binlog::warning}},
    {"foo/*/",       {binlog::error}}
  });

  BOOST_TEST(c1.minSeverity == binlog::info);
  BOOST_TEST(c2.minSeverity == binlog::warning);
  BOOST_TEST(c3.minSeverity == binlog::error);
  BOOST_TEST(c4.minSeverity == binlog::debug);

  config.setCategoryConfigs({
    {"foo/bar/cat1", {binlog::info}},
    {"foo/bar/",     {binlog::warning}},
    {"foo/*/",       {binlog::error}},
    {"*",            {binlog::critical}}
  });

  BOOST_TEST(c1.minSeverity == binlog::info);
  BOOST_TEST(c2.minSeverity == binlog::warning);
  BOOST_TEST(c3.minSeverity == binlog::error);
  BOOST_TEST(c4.minSeverity == binlog::critical);

  config.setCategoryConfigs({
    {"*", {binlog::critical}}
  });

  BOOST_TEST(c1.minSeverity == binlog::critical);
  BOOST_TEST(c2.minSeverity == binlog::critical);
  BOOST_TEST(c3.minSeverity == binlog::critical);
  BOOST_TEST(c4.minSeverity == binlog::critical);
}

BOOST_AUTO_TEST_CASE(categoryRegisterUnregister)
{
  binlog::CategoryConfig c1;
  binlog::CategoryConfig c2;

  binlog::Configuration config;

  config.registerCategory("foo/bar/cat", c1);
  config.registerCategory("foo/bar/cat", c2);

  config.setCategoryConfig("foo/bar/cat", {binlog::critical});
  config.setCategoryConfig("foo/bar/cat", {binlog::critical});

  BOOST_TEST(c1.minSeverity == binlog::critical);
  BOOST_TEST(c2.minSeverity == binlog::critical);

  config.unregisterCategory(c1);

  config.setCategoryConfig("foo/bar/cat", {binlog::debug});

  BOOST_TEST(c1.minSeverity == binlog::critical);
  BOOST_TEST(c2.minSeverity == binlog::debug);
}

BOOST_AUTO_TEST_CASE(getCategories)
{
  binlog::CategoryConfig c1;
  binlog::CategoryConfig c2;
  binlog::CategoryConfig c3;

  binlog::Configuration config;

  config.registerCategory("foo/bar/cat", c1);
 config.registerCategory("foo/bar/cat", c2);
  config.registerCategory("foo/abc/cat", c3);

  auto list = config.getCategories();

  // do not depend on the order of results
  bool c1found = false;
  for (auto&& c : list)
  {
    if (c.first == "foo/bar/cat" && c.second == &c1)
    {
      c1found = true;
    }
  }

  bool c2found = false;
  for (auto&& c : list)
  {
    if (c.first == "foo/bar/cat" && c.second == &c2)
    {
      c2found = true;
    }
  }

  bool c3found = false;
  for (auto&& c : list)
  {
    if (c.first == "foo/abc/cat" && c.second == &c3)
    {
      c3found = true;
    }
  }

  BOOST_TEST(c1found);
  BOOST_TEST(c2found);
  BOOST_TEST(c3found);
}

BOOST_AUTO_TEST_CASE(adaptiveSeverityControlling)
{
  binlog::Configuration config;

  // Adaptive Severity Controlling is omnipotent by default
  BOOST_TEST(config.getAdaptiveSeverityCeiling() == binlog::none);

  config.setAdaptiveSeverityCeiling(binlog::warning);
  BOOST_TEST(config.getAdaptiveSeverityCeiling() == binlog::warning);

  binlog::CategoryConfig c1;
  binlog::CategoryConfig c2;
  binlog::CategoryConfig c3;
  binlog::CategoryConfig c4;
  binlog::CategoryConfig c5;

  config.registerCategory("a", c1);
  config.registerCategory("b", c2);
  config.registerCategory("c", c3);
  config.registerCategory("d", c4);
  config.registerCategory("e", c5);

  c1.minSeverity = binlog::trace;
  c2.minSeverity = binlog::debug;
  c3.minSeverity = binlog::warning;
  c4.minSeverity = binlog::error;
  c5.minSeverity = binlog::none;

  config.incrementCategoryThresholds();

  BOOST_TEST(c1.minSeverity == binlog::debug);
  BOOST_TEST(c2.minSeverity == binlog::debug);
  BOOST_TEST(c3.minSeverity == binlog::warning);
  BOOST_TEST(c4.minSeverity == binlog::error);
  BOOST_TEST(c5.minSeverity == binlog::none);

  config.incrementCategoryThresholds();

  BOOST_TEST(c1.minSeverity == binlog::info);
  BOOST_TEST(c2.minSeverity == binlog::info);
  BOOST_TEST(c3.minSeverity == binlog::warning);
  BOOST_TEST(c4.minSeverity == binlog::error);
  BOOST_TEST(c5.minSeverity == binlog::none);

  config.incrementCategoryThresholds();

  BOOST_TEST(c1.minSeverity == binlog::warning);
  BOOST_TEST(c2.minSeverity == binlog::warning);
  BOOST_TEST(c3.minSeverity == binlog::warning);
 BOOST_TEST(c4.minSeverity == binlog::error);
  BOOST_TEST(c5.minSeverity == binlog::none);

  config.setAdaptiveSeverityCeiling(binlog::none);

  config.incrementCategoryThresholds();

  BOOST_TEST(c1.minSeverity == binlog::error);
  BOOST_TEST(c2.minSeverity == binlog::error);
  BOOST_TEST(c3.minSeverity == binlog::error);
  BOOST_TEST(c4.minSeverity == binlog::error);
  BOOST_TEST(c5.minSeverity == binlog::none);
}

BOOST_AUTO_TEST_CASE(toggleSource)
{
  auto&& config = binlog::getConfiguration();

  unsigned marker = __LINE__ + 1;
  BINLOG_INFO("Known event source");

  BOOST_TEST(config.toggleSource("ConfigurationTest.C", 0, false));
  BOOST_TEST(config.toggleSource("ConfigurationTest.C", 0, true));

  BOOST_TEST(config.toggleSource("ConfigurationTest.C", marker, false));
  BOOST_TEST(config.toggleSource("ConfigurationTest.C", marker, true));
}

BOOST_AUTO_TEST_SUITE_END()

Attention:  ./test/unit/ConfigParserTest.C
#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <boost/property_tree/ptree.hpp>

#include "Testfile.H"

#include <binlog/Configuration.H>
#include <binlog/detail/ConfigParser.H>

using binlog::detail::ConfigParser;
using binlog::test::Testfile;
using binlog::reader::entry::EventSource;

void configHasParserError(const Testfile& configFilePath)
{
  ConfigParser parser;

  std::error_code ec;
  parser.readConfigFile(configFilePath.getPath(), ec);

  BOOST_TEST(!!ec);
}

BOOST_AUTO_TEST_SUITE(ConfigParserSuite)

BOOST_AUTO_TEST_CASE(parseWrongConfigFile)
{
  // empty config
  Testfile emptyConfigFile("{\"foo\": {}}");
  configHasParserError(emptyConfigFile);

  // invalid JSON
  Testfile invalidConfigFile("\"foo\": {}");
  configHasParserError(invalidConfigFile);
}

void configHasCategoryError(const Testfile& configFilePath)
{
  ConfigParser parser;

  std::error_code ec;
  parser.readConfigFile(configFilePath.getPath(), ec);

  BOOST_TEST(!ec); // not a parser error

  parser.getCategoryConfig(ec);

  BOOST_TEST(!!ec);
}

BOOST_AUTO_TEST_CASE(parseWrongCategoryConfigFile)
{
  // invalid severity
  Testfile invalidSeverity(R"hereconfig(
{"binlog":{
    "categories": { "m/p/r": "invalid-severity-foobar" }
}}
)hereconfig"
  );
  configHasCategoryError(invalidSeverity);
}

void configHasSinkError(const Testfile& configFilePath)
{
  ConfigParser parser;

  std::error_code ec;
  parser.readConfigFile(configFilePath.getPath(), ec);

  BOOST_TEST(!ec); // not a parser error

  parser.setPredicateFactory(
    [](const std::string&)
    {
      return std::function<bool(const binlog::sink::MultiSink::EventSource&)>{};
    }
  );

  parser.getConfiguredSinks(ec);

  BOOST_TEST(!!ec);
}

BOOST_AUTO_TEST_CASE(parseWrongSinkConfigFile)
{
  // no target for file
  Testfile missingFileTarget(R"hereconfig(
{"binlog":{
    "sinks": { "File": {} }
}}
)hereconfig"
  );
  configHasSinkError(missingFileTarget);

  // invalid target for file
  Testfile invalidFileTarget(R"hereconfig(
{"binlog":{
    "sinks": { "File": { "target" : "/root/cannot-open.log" } }
}}
)hereconfig"
  );
  configHasSinkError(invalidFileTarget);


  // invalid rotateBySize
  Testfile invalidRotateSize(R"hereconfig(
{"binlog":{
    "sinks": { "File": {
      "target": "/tmp/binlog-unittest-confparse-wrong.log",
      "rotateBySize" : "string!"
    }}
}}
)hereconfig"
  );
  configHasSinkError(invalidRotateSize);

  // invalid rotateByTime
  Testfile invalidRotateTime(R"hereconfig(
{"binlog":{
    "sinks": { "File": {
      "target": "/tmp/binlog-unittest-confparse-wrong.log",
      "rotateByTime" : "string!"
    }}
}}
)hereconfig"
  );
  configHasSinkError(invalidRotateTime);

  // invalid compression
  Testfile invalidCompression(R"hereconfig(
{"binlog":{
    "sinks": { "File": {
      "target": "/tmp/binlog-unittest-confparse-wrong.log",
      "compression" : "not-bool"
    }}
}}
)hereconfig"
  );
  configHasSinkError(invalidCompression);

  // no target for stream
  Testfile missingStreamTarget(R"hereconfig(
{"binlog":{
    "sinks": { "Stream": {} }
}}
)hereconfig"
  );
  configHasSinkError(missingStreamTarget);

  // invalid target for stream
  Testfile invalidStreamTarget(R"hereconfig(
{"binlog":{
    "sinks": { "Stream": { "target" : "std-cout"} }
}}
)hereconfig"
  );
  configHasSinkError(invalidStreamTarget);

  // unknown sink type
  Testfile unknownSink(R"hereconfig(
{"binlog":{
    "sinks": { "RightToLeft": {} }
}}
)hereconfig"
  );
  configHasSinkError(unknownSink);

  // unknown predicate
  Testfile unknownPredicate(R"hereconfig(
{"binlog":{
    "sinks": { "Stream": { "target" : "cout", "predicate" : "foo" } }
}}
)hereconfig"
  );
  configHasSinkError(unknownPredicate);

  // invalid cat predicate
  Testfile invalidCatPredicate(R"hereconfig(
{"binlog":{
  "sinks": { "Syslog": { "predicate": [1,2,3] } }
}}
)hereconfig"
  );
  configHasSinkError(invalidCatPredicate);

  // unknown cat predicate
  Testfile unknownCatPredicate(R"hereconfig(
{"binlog":{
  "sinks": { "Syslog": { "predicate": { "foo/bar/baz" : 123 } } }
}}
)hereconfig"
  );
  configHasSinkError(unknownCatPredicate);
}

void configHasProducerError(const Testfile& configFilePath)
{
  ConfigParser parser;

  std::error_code ec;
  parser.readConfigFile(configFilePath.getPath(), ec);

  BOOST_TEST(!ec); // not a parser error

  parser.getProducerConfig(ec);

  BOOST_TEST(!!ec);
}

BOOST_AUTO_TEST_CASE(parseWrongProducerConfigFile)
{
  // unknown severity
  Testfile unknownSeverity(R"hereconfig(
{"binlog":{
    "producers": { "adaptive_severity_ceiling" : "sewer" }
}}
)hereconfig"
  );
  configHasProducerError(unknownSeverity);

  // invalid severity
  Testfile invalidSeverity(R"hereconfig(
{"binlog":{
    "producers": { "adaptive_severity_ceiling" : {"a":"b"} }
}}
)hereconfig"
  );
  configHasProducerError(invalidSeverity);

  // invalid queue size
  Testfile invalidQueueSize(R"hereconfig(
{"binlog":{
    "producers": { "min_queue_size" : "1024ux" }
}}
)hereconfig"
  );
  configHasProducerError(invalidQueueSize);
}

struct DummySink : binlog::sink::Sink
{
  void operator()(const char*, std::size_t) {}
};

BOOST_AUTO_TEST_CASE(readConfigFile)
{
  // Create config

  ConfigParser parser;

  Testfile configFile(R"hereconfig(
{
  "binlog":
  {
    "categories":
    {
      "m/p/r": "warning",
      "a/b/c": "info",
      "x/y/z": "trace",
      "x/*/z": "debug",
      "*"    : "critical"
    },
    "sinks":
    {
      "File" : { "target" : "/tmp/binlog-unittest-confparse-1.log", "predicate" : "trace" },
      "File" : { "target" : "/tmp/binlog-unittest-confparse-2.log", "predicate" : "critical" },
      "File" : { "target" : "/tmp/binlog-unittest-confparse-3.log", "compression": "true" },
      "File" : { "target" : "/tmp/binlog-unittest-confparse-4.log", "rotateBySize": 1048576 },
      "File" : { "target" : "/tmp/binlog-unittest-confparse-5.log", "rotateByTime": 86400 },
      "Stream" : { "target" : "cout" },
      "Stream" : { "target" : "cerr" },
      "Stream" : { "target" : "clog" },
      "Syslog" : { "predicate" : { "m/*/r" : "warning", "*" : "error" } },
      "Custom" : { "arg" : "${FOO} and ${BAR}", "arg2" : ".${GitS_9}.", "predicate" : "custom_pred"}
    },
    "producers":
    {
      "adaptive_severity_ceiling" : "warning",
      "min_queue_size" : 1048576
    }
  }
}
)hereconfig"
  );

  // Variable factory
  parser.setVariableFactory([](const std::string& name)
  {
    if (name == "FOO") { return "my_foo"; }
    if (name == "BAR") { return "my_bar"; }
    if (name == "GitS_9") { return "2501"; }
    BOOST_TEST(false);
    return "???";
  });

  // Read config

  std::error_code ec;
  parser.readConfigFile(configFile.getPath(), ec);
  BOOST_TEST(! ec);

  // Check category settings

  auto&& cc = parser.getCategoryConfig(ec);
  BOOST_TEST(! ec);
  BOOST_TEST(cc.size() == 5);

  BOOST_TEST(cc[0].first == "m/p/r");
  BOOST_TEST(cc[1].first == "a/b/c");
  BOOST_TEST(cc[2].first == "x/y/z");
  BOOST_TEST(cc[3].first == "x/*/z");
  BOOST_TEST(cc[4].first == "*");

  // Check sinks

  auto sinkFactory = [](const std::string& name, const ConfigParser::Config& config)
  {
    BOOST_TEST(name == "Custom");

    BOOST_TEST(config.get<std::string>("arg") == "my_foo and my_bar");
    BOOST_TEST(config.get<std::string>("arg2") == ".2501.");

    return std::unique_ptr<binlog::sink::Sink>(new DummySink());
  };

  auto predicateFactory = [](const std::string& name)
  {
    BOOST_TEST(name == "custom_pred");
    ConfigParser::EventSourcePredicate pred
      = [](const binlog::sink::MultiSink::EventSource&) { return true; };
    return pred;
  };

  parser.setSinkFactory(sinkFactory);
  parser.setPredicateFactory(predicateFactory);

  auto&& sinks = parser.getConfiguredSinks(ec);
  BOOST_TEST(! ec);

  BOOST_TEST(sinks.size() == 10);

  auto&& catSpecPred = sinks[8].predicate;
  EventSource m1({}, {}, "m/p/r", binlog::warning, {}, {}, {"","",0});
  EventSource m2({}, {}, "m/x/r", binlog::warning, {}, {}, {"","",0});
  EventSource n1({}, {}, "a/p/r", binlog::warning, {}, {}, {"","",0});
  EventSource n2({}, {}, "m/p/r", binlog::info, {}, {}, {"","",0});

  BOOST_TEST(catSpecPred(m1));
  BOOST_TEST(catSpecPred(m2));
  BOOST_TEST(! catSpecPred(n1));
  BOOST_TEST(! catSpecPred(n2));

  // Check producer config

  auto&& pc = parser.getProducerConfig(ec);
  BOOST_TEST(! ec);

  BOOST_TEST(*pc.adaptiveSeverityCeiling == binlog::warning);
  BOOST_TEST(*pc.minQueueSize == 1048576);
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/ConsumerTest.C
#include <stdexcept>
#include <iostream>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/detail/Core.H>

#include <binlog/sink/MultiConsumer.H>
#include <binlog/sink/SingleConsumer.H>

#include <binlog/sink/FileSink.H>
#include <binlog/sink/StreamSink.H>
#include <binlog/sink/SyslogSink.H>

using binlog::detail::Core;
using binlog::sink::MultiConsumer;
using binlog::sink::SingleConsumer;

namespace {

struct DummySink : binlog::sink::Sink
{
  DummySink(int,int) {}

  void operator()(const char* buffer, std::size_t size)
  {
    (void)buffer;
    (void)size;
  }
};

} // namespace

BOOST_AUTO_TEST_SUITE(MultiConsumerSuite)

BOOST_AUTO_TEST_CASE(notExclusiveExistence)
{
  {
    MultiConsumer mc;
    (void)mc;
  }

  {
    SingleConsumer sc;
    (void)sc;
  }

  BOOST_TEST(true);
}

BOOST_AUTO_TEST_CASE(exclusiveLifetime)
{
  auto&& mc = MultiConsumer::getInstance();
  BOOST_CHECK_THROW(SingleConsumer::getInstance(), std::runtime_error);

  // cleanup
  Core::getInstance().tryRelease(&mc);
}

BOOST_AUTO_TEST_CASE(addSinkTemplate)
{
  MultiConsumer mc;

  auto tr = mc.threshold(binlog::debug);
  MultiConsumer::SinkDescription desc;

  BOOST_CHECK_NO_THROW(mc.addSink<DummySink>(1,2));
  BOOST_CHECK_NO_THROW(mc.addSink<DummySink>(tr, desc, 1, 2));
}

BOOST_AUTO_TEST_CASE(addSink)
{
  MultiConsumer mc;

  BOOST_CHECK_NO_THROW(mc.addFileSink("/tmp/binlog-unittest-consumer-00.log"));
  BOOST_CHECK_NO_THROW(mc.addStreamSink(std::cout, "%C"));
  BOOST_CHECK_NO_THROW(mc.addSyslogSink());

  auto tr = mc.threshold(binlog::debug);
  MultiConsumer::SinkDescription desc;

  BOOST_CHECK_NO_THROW(mc.addFileSink("/tmp/binlog-unittest-consumer-01.log", tr, desc));
  BOOST_CHECK_NO_THROW(mc.addStreamSink(std::cout, "%C", tr, desc));
  BOOST_CHECK_NO_THROW(mc.addSyslogSink(tr, desc));
}

template <typename Container>
bool contains(const Container& c, const typename Container::value_type& v)
{
  return std::find(c.begin(), c.end(), v) != c.end();
}

BOOST_AUTO_TEST_CASE(listSinks)
{
  MultiConsumer mc;

  auto list1 = mc.listSinks();
  BOOST_TEST(list1.size() == 0);

  auto& pS1 = mc.addSink<DummySink>(1,2);
  auto& pS2 = mc.addSink<DummySink>(1,2);

  auto list2 = mc.listSinks();
  BOOST_TEST(list2.size() == 2);

  BOOST_TEST(contains(list2, &pS1));
  BOOST_TEST(contains(list2, &pS2));
}

BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE(SingleConsumerSuite)

BOOST_AUTO_TEST_CASE(addSinkTemplate)
{
  SingleConsumer sc;
  BOOST_CHECK_NO_THROW(sc.setSink<DummySink>(1, 2));
}

BOOST_AUTO_TEST_CASE(addSink)
{
  SingleConsumer sc;

  BOOST_CHECK_NO_THROW(sc.setFileSink("/tmp/binlog-unittest-consumer-02.log"));
  BOOST_CHECK_NO_THROW(sc.setStreamSink(std::cout, "%C"));
  BOOST_CHECK_NO_THROW(sc.setSyslogSink());
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/QueueTest.C
#include <thread>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/detail/Queue.H>

class Entity
{
public:
  Entity(int id)
    :_id(id)
  {
    for (int i = 0; i < 5; ++i)
    {
      _data[i] = id + 1 + i;
    }
  }

  bool check()
  {
    for (int i = 0; i < 5; ++i)
    {
      assert(_data[i] == _id + 1 + i);
    }

    return true;
  }

  int id() const
  {
    return _id;
  }

private:
  int _id;
  int _data[5];
};

enum { queueSize = 1024};
typedef binlog::detail::Queue Q;

void prod(Q& q)
{
  for (int i = 0; i < 5000; ++i)
  {
    char* pArena = nullptr;
    do {
      pArena = q.reserve(sizeof(Entity));
    } while (pArena == nullptr);

    new (pArena) Entity(i);

    q.commit(sizeof(Entity));
  }
}

void cons(Q& q)
{
  int recv = 0;
  while (recv < 5000)
  {
    char* pBatch = nullptr;
    std::size_t batchSize = 0;

    do {
      pBatch = q.checkout(batchSize);
    } while (pBatch == nullptr);

    for (std::size_t offset = 0; offset < batchSize; offset += sizeof(Entity))
    {
      auto pEntity = reinterpret_cast<Entity*>(pBatch+offset);
      BOOST_TEST(pEntity->id() == recv);
      pEntity->check();
      ++recv;
    }

    q.dispose(batchSize);
  }
}

BOOST_AUTO_TEST_SUITE(Queue)

BOOST_AUTO_TEST_CASE(produceConsume)
{
  Q q(queueSize);

  std::thread c(cons, std::ref(q));
  std::thread p(prod, std::ref(q));

  p.join();
  c.join();
}

BOOST_AUTO_TEST_CASE(fillQueue)
{
  Q q(queueSize);
  char* pArena = nullptr;

  for (int i = 0; i < 4; ++i)
  {
    pArena = q.reserve(255);
    BOOST_TEST(pArena);
    q.commit(255);
  }

  std::size_t batchSize = 0;
  char* pBatch = nullptr;
  pBatch = q.checkout(batchSize);

  BOOST_TEST(pBatch);
  BOOST_TEST(batchSize == 1020);
}

BOOST_AUTO_TEST_CASE(singleFillQueue)
{
  Q q(queueSize);

  auto pArena = q.reserve(q.maxRequestSize());
  BOOST_TEST(pArena);
  q.commit(q.maxRequestSize());

  std::size_t batchSize = 0;
  auto pBatch = q.checkout(batchSize);

  BOOST_TEST(pBatch);
  BOOST_TEST(batchSize == q.maxRequestSize());
}

BOOST_AUTO_TEST_CASE(writeAvailable)
{
  Q q(queueSize);

  BOOST_TEST(q.writeAvailable() == queueSize);

  q.reserve(750);
  q.commit(750);

  BOOST_TEST(q.writeAvailable() == queueSize - 750);

  std::size_t size = 0;
  q.checkout(size);
  q.dispose(size);

  BOOST_TEST(q.writeAvailable() == queueSize);

  q.reserve(300);
  q.commit(300);

  BOOST_TEST(q.writeAvailable() == 750 - 300);
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/PrettyPrinterTest.C
#include <sstream>
#include <chrono>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/detail/EntryDefs.H>
#include <binlog/detail/Arguments.H> // type_*
#include <binlog/reader/entry/Entry.H>
#include <binlog/reader/entry/EventSource.H>
#include <binlog/reader/entry/Event.H>
#include <binlog/reader/detail/Buffer.H>
#include <binlog/reader/detail/MemoryInputStream.H>
#include <binlog/reader/detail/ArgumentParseContext.H>

#include <binlog/reader/PrettyPrinter.H>

namespace bd  = binlog::detail;
namespace br  = binlog::reader;
namespace bre = binlog::reader::entry;
namespace brd = binlog::reader::detail;

struct TestEntry : public bre::Entry
{
  TestEntry(bre::Entry::tag_t tag, const std::string& payload)
  {
    _tag = tag;
    _buffer.reset(payload.size());
    std::copy(payload.begin(), payload.end(), _buffer.get());
    _reader.assign(_buffer);
  }
};

BOOST_AUTO_TEST_SUITE(PrettyPrinter)

BOOST_AUTO_TEST_CASE(printFormat)
{
  TestEntry a(123, "ABCDEFG");

  br::PrettyPrinter pp;
  pp.setEntryFormat("%%% %X %");

  std::stringstream actual;

  pp.print(a, actual);
  BOOST_TEST("%%% %X %" == actual.str());
}

BOOST_AUTO_TEST_CASE(printEntry)
{
  using namespace binlog::detail::EntryTag;

  const std::string nonprintable{0x0, 0x1, 0x2, 0x3, 'A', 'B', 'C'};

  TestEntry a(tscSync, "ABCDEFG");
  TestEntry b(threadProp, "ABCDEFG");
  TestEntry c(eventSource, "ABCDEFG");
  TestEntry d(structDef, "ABCDEFG");
  TestEntry e(hostProp, "ABCDEFG");
  TestEntry f(123, nonprintable);

  br::PrettyPrinter pp;
  pp.setEntryFormat("%T %S %P\n");

  std::stringstream actual;

  pp.print(a, actual);
  pp.print(b, actual);
  pp.print(c, actual);
  pp.print(d, actual);
  pp.print(e, actual);
  pp.print(f, actual);

  const std::string expected = R"herestr(     TSCSync         7 ABCDEFG
  ThreadProp         7 ABCDEFG
EventSource         7 ABCDEFG
   StructDef         7 ABCDEFG
    HostProp         7 ABCDEFG
00000000007b         7 0x00 0x01 0x02 0x03 ABC
)herestr";

  BOOST_TEST(expected == actual.str());
}

struct TestEventSource : public bre::EventSource
{
  TestEventSource()
    :bre::EventSource(
      123u,
      reinterpret_cast<void*>(456),
      "foo_cat",
      binlog::info,
      "%foo %bar {0} {1} {2}",
      {bd::type_u32, bd::type_u32, bd::type_string},
      brd::SourceLocation{"func<void()>(V<T>, int)", "file", 123}
    )
  {}
};

BOOST_AUTO_TEST_CASE(printEventSource)
{
  TestEventSource a;

  br::PrettyPrinter pp;
  pp.setEventSourceFormat("%I %C %S %F %M %N %L %% %");

  std::stringstream actual;

  pp.print(a, actual);
  BOOST_TEST("123 foo_cat INFO %foo %bar {0} {1} {2} func<void()>(V<T>, int) func file:123 %% %" == actual.str());
}

bre::Entry constructEntry(brd::WriteBuffer& writer, std::error_code& ec)
{
  bre::Entry::entry_size_t size = 0;
  bre::Entry::tag_t sourceId = 123;
  bre::Event::tsc_t tsc = 135890367369000; // 0135888000000000 + 1234;
  uint32_t a = 456;
  uint32_t b = 789;
  std::string c = "foobar";

  writer.write(size);
  writer.write(sourceId);
  writer.write(tsc);
  writer.write(a);
  writer.write(b);
  writer.write(c.data(), c.size() + 1);
  writer.overwrite(0, bre::Entry::entry_size_t(writer.size()));

  brd::MemoryInputStream stream;
  stream.reset(writer.get(), writer.size());

  brd::InputStream& istream = stream;
  bre::Entry result(istream, ec);
  return result;
}

bre::TscSynchronization constructTscSync(std::error_code& ec)
{
  bre::Event::tsc_t tsc = 0;
  bre::TscSynchronization::time_point time(std::chrono::seconds{0});
  int64_t tzoffset = 0;
  int cpufreq = 3000000;

  brd::WriteBuffer writer(64);
  writer.write(tsc);
  writer.write(time);
  writer.write(tzoffset);
  writer.write(cpufreq);

  bre::TscSynchronization result;
  brd::ReadBuffer reader(writer.get(), writer.size());
  result.serialize(reader, ec);
  return result;
}

bre::ThreadProp constructThreadProp(std::error_code& ec)
{
  bre::ThreadProp::LWP lwp = 1212;
  std::string threadname = "golden";

  brd::WriteBuffer writer(64);
  writer.write(lwp);
  writer.write(threadname.data(), threadname.size() + 1);

  bre::ThreadProp result;
  brd::ReadBuffer reader(writer.get(), writer.size());
  result.serialize(reader, ec);
  return result;
}

bre::HostProp constructHostProp(std::error_code& ec)
{
  std::string hostname = "denethor";
  brd::WriteBuffer writer(64);
  writer.write(hostname.data(), hostname.size() + 1);

  bre::HostProp result;
  brd::ReadBuffer reader(writer.get(), writer.size());
  result.serialize(reader, ec);
  return result;
}

BOOST_AUTO_TEST_CASE(printEvent)
{
  std::error_code ec;
  brd::WriteBuffer writer(64);
  auto entry = constructEntry(writer, ec); // entry is valid as long writer is valid
  BOOST_TEST(!ec);
  auto tscSync = constructTscSync(ec);
  BOOST_TEST(!ec);
  auto threadProp = constructThreadProp(ec);
  BOOST_TEST(!ec);
  auto hostProp = constructHostProp(ec);
  BOOST_TEST(!ec);

  TestEventSource source;
  brd::ArgumentParseContext apc;
  bre::ThreadActivity activity(std::move(entry), tscSync, threadProp, hostProp, ec);
  bre::Event event(source, apc, std::move(activity));
  BOOST_TEST(!ec);

  br::PrettyPrinter pp;
  pp.setEventFormat("[%d] [%h] [%t] [%a] [%m]");
  pp.setDateFormat("%Y %y/%m/%d %H:%M:%S %U %q %r");

  std::stringstream actual;
  pp.print(event, actual);

  BOOST_TEST(
    "[1970 70/01/01 12:34:56 789123 135890367369000 135890367369000]"
    " [denethor] [golden] [(456|789|foobar|)] [%foo %bar 456 789 foobar]"
    == actual.str()
  );
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/FileSinkTest.C
#include <algorithm>
#include <fstream>
#include <thread> // sleep_for
#include <cstdlib> // mkdtemp
#include <unistd.h> // unlink

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/sink/FileSink.H>

bool fileExists(const std::string& path)
{
  std::ifstream file(path);
  return file.is_open();
}

void remove(const std::string& path)
{
  unlink(path.c_str());
}

struct Tempdir
{
  std::string path;

  Tempdir()
  {
    char path_template[] = "/tmp/binlog_unittest_XXXXXX";
    if (! mkdtemp(path_template))
    {
      throw std::runtime_error(std::string("Failed to create tempdir: ") + strerror(errno));
    }
    path = path_template;
  }

  ~Tempdir() { rmdir(path.c_str()); }
};

BOOST_AUTO_TEST_SUITE(FileSink)

BOOST_AUTO_TEST_CASE(rotate)
{
  Tempdir dir;
  const std::string logbase = dir.path + "/filesink.log";

  binlog::sink::FileSink fs(logbase);

  fs.rotateBySize(100);

  char buffer[100];
  std::fill(buffer, buffer+100, 'A');

  fs(buffer, 100);
  fs.afterConsume();

  fs(buffer, 100);
  fs.afterConsume();

  fs(buffer, 100);
  fs.afterConsume();

  BOOST_TEST(fileExists(logbase));
  BOOST_TEST(fileExists(logbase + ".0"));
  BOOST_TEST(fileExists(logbase + ".1"));
  BOOST_TEST(fileExists(logbase + ".2"));

  remove(logbase);
  remove(logbase + ".0");
  remove(logbase + ".1");
  remove(logbase + ".2");
}

BOOST_AUTO_TEST_CASE(rotateCompress)
{
  Tempdir dir;
  const std::string logbase = dir.path + "/filesink-comp.log";

  binlog::sink::FileSink fs(logbase);

  fs.rotateBySize(100);
  fs.compression(true);

  char buffer[100];
  std::fill(buffer, buffer+100, 'A');

  fs(buffer, 100);
  fs.afterConsume();

  fs(buffer, 100);
  fs.afterConsume();

  fs(buffer, 100);
  fs.afterConsume();

  BOOST_TEST(fileExists(logbase));

  BOOST_TEST(fileExists(logbase + ".0.gz"));
  BOOST_TEST(fileExists(logbase + ".1.gz"));
  BOOST_TEST(fileExists(logbase + ".2.gz"));

  BOOST_TEST(! fileExists(logbase + ".0"));
  BOOST_TEST(! fileExists(logbase + ".1"));
  BOOST_TEST(! fileExists(logbase + ".2"));

  remove(logbase);
  remove(logbase + ".0.gz");
  remove(logbase + ".1.gz");
  remove(logbase + ".2.gz");
}

BOOST_AUTO_TEST_CASE(rotateTime)
{
  Tempdir dir;
  const std::string logbase = dir.path + "/filesink-time.log";

  binlog::sink::FileSink fs(logbase);

  fs.rotateByTime(std::chrono::seconds(2));

  fs.afterConsume();
  fs.afterConsume();
  fs.afterConsume();

  BOOST_TEST(! fileExists(logbase + ".0"));

  std::this_thread::sleep_for(std::chrono::seconds(2));

  fs.afterConsume();

  BOOST_TEST(fileExists(logbase + ".0"));

  remove(logbase);
  remove(logbase + ".0");
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/BufferSerializeTest.C
#include <string>
#include <system_error>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/reader/detail/Buffer.H>

struct Entity
{
  enum E { x, y };

  struct SubEntity
  {
    std::string f;
    int g;

    template <typename Archive>
    void serialize(Archive& ar, std::error_code& ec)
    {
      binlog::reader::detail::serialize(ar, f, ec, std::errc::invalid_argument);
      binlog::reader::detail::serialize(ar, g, ec, std::errc::invalid_argument);
    }

    bool operator==(const SubEntity& rhs) const
    {
      return f == rhs.f && g == rhs.g;
    }
  };

  void* a;
  std::size_t b;
  std::string c;
  E d;
  std::vector<SubEntity> e;

  template <typename Archive>
  void serialize(Archive& ar, std::error_code& ec)
  {
    binlog::reader::detail::serialize(ar, a, ec, std::errc::invalid_argument);
    binlog::reader::detail::serialize(ar, b, ec, std::errc::invalid_argument);
    binlog::reader::detail::serialize(ar, c, ec, std::errc::invalid_argument);
    binlog::reader::detail::serialize(ar, d, ec, std::errc::invalid_argument);
    binlog::reader::detail::serialize(ar, e, ec, std::errc::invalid_argument);
  }

  bool operator==(const Entity& rhs) const
  {
    return
       a == rhs.a
    && b == rhs.b
    && c == rhs.c
    && d == rhs.d
    && e == rhs.e;
  }

  friend std::ostream& operator<<(std::ostream& out, const Entity& e)
  {
    out << e.a << " " << e.b << " " << e.c << " " << e.d;
    return out;
  }
};

using binlog::reader::detail::ReadBuffer;
using binlog::reader::detail::WriteBuffer;

BOOST_AUTO_TEST_SUITE(Serialize)

BOOST_AUTO_TEST_CASE(inout)
{
  void* p = reinterpret_cast<void*>(0x123);
  Entity out{p, 456, "abcdefgh", Entity::y,
    {{"foo", 1}, {"bar", 2}, {"baz", 3}}
  };
  Entity in;

  std::error_code ec;

  WriteBuffer wb;
  out.serialize(wb, ec);

  ReadBuffer rb(wb.get(), wb.size());
  in.serialize(rb, ec);

  BOOST_TEST(!ec);
  BOOST_TEST(&out.c != &in.c);
  BOOST_TEST(out == in);
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/FormatStringTest.C
#include <iostream>
#include <sstream>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/reader/detail/FormatString.H>
#include <binlog/reader/detail/Argument.H>

using binlog::reader::detail::ParsedFormat;
using binlog::reader::detail::Argument;

std::string toString(const ParsedFormat& parsed, const std::vector<Argument>& args)
{
  std::stringstream stream;
  parsed.substituePlaceholders(args, stream);
  return stream.str();
}

BOOST_AUTO_TEST_SUITE(FormatString)

BOOST_AUTO_TEST_CASE(parsing)
{
 std::vector<Argument> args{1, 2, 3};

  std::string format = "foobar {0}, barbaz {2}, {{123}}, {{ hello this is legit: {{{1}}} and the end: { unbalanced";
  ParsedFormat parsed(format);

  BOOST_TEST(
    "foobar 1, barbaz 3, {123}, { hello this is legit: {2} and the end: { unbalanced"
    == toString(parsed, args)
  );
}

BOOST_AUTO_TEST_CASE(parseWithNamedPlaceholders)
{
  std::vector<Argument> args{1, 2, 3};

  std::string format = "foobar {0}, barbaz {2:name1}, {{123}}, {{ hello this is legit: {{{1:name2}}} and the end: { unbalanced";
  ParsedFormat parsed(format);

  BOOST_TEST(
    "foobar 1, barbaz 3, {123}, { hello this is legit: {2} and the end: { unbalanced"
    == toString(parsed, args)
  );
}

BOOST_AUTO_TEST_CASE(getNamedPlaceholders)
{
  std::string format = "foobar {0:trId}, barbaz {2}, xyz {1}{3:fiberId}";
  ParsedFormat parsed(format);

  auto namedArgs = parsed.getNamedPlaceholders();

  BOOST_TEST(2 == namedArgs.size());

  auto argIt = namedArgs.find(0);
  BOOST_TEST((argIt != namedArgs.end()));
  BOOST_TEST(argIt->second == "trId");

  argIt = namedArgs.find(3);
  BOOST_TEST((argIt != namedArgs.end()));
  BOOST_TEST(argIt->second == "fiberId");
}

BOOST_AUTO_TEST_CASE(invalidPlaceholder)
{
  std::vector<Argument> args{1, 2, 3};

  std::string format = "foobar {0}, {ouch}, {1}, {2}, {1foo}";
  ParsedFormat parsed(format);

  BOOST_TEST("foobar 1, {ouch}, 2, 3, {1foo}" == toString(parsed, args));
}

BOOST_AUTO_TEST_CASE(invalidNamedPlaceholder)
{
  std::vector<Argument> args{1, 2, 3};

  std::string format = "foobar {2}, {hmm12:qux} {1}, {12oops:foo}, {0}";
  ParsedFormat parsed(format);

  BOOST_TEST("foobar 3, {hmm12:qux} 2, {12oops:foo}, 1" == toString(parsed, args));
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/ThreadContextTest.C
#include <array>
#include <algorithm>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/detail/ThreadContext.H>

using binlog::detail::ThreadContext;

BOOST_AUTO_TEST_SUITE(ThreadContextSuite)

BOOST_AUTO_TEST_CASE(constructors)
{
  ThreadContext::setMinQueueSize(1024);
  ThreadContext a;
  BOOST_TEST(a.getEntryQueue().maxRequestSize() >= 1023);

  ThreadContext::ThreadName name;
  name.fill('t');

  ThreadContext b(2048, 1212, name);
  BOOST_TEST(b.getEntryQueue().maxRequestSize() >= 2047);
  BOOST_TEST(b.getLwp() == 1212);
  BOOST_TEST(b.getThreadName() == name);
}

BOOST_AUTO_TEST_CASE(threadPropBuf)
{
  // The contents of the prop buffer is impl defined,
  // but it should reflect the LWP and thread name values

  ThreadContext::ThreadName name;
  name.fill('t');

  ThreadContext a(1024, 123, name);
  ThreadContext b(1024, 456, name);

  BOOST_TEST(a.getThreadPropBuffer() != b.getThreadPropBuffer());

  auto bOld = b.getThreadPropBuffer();
  b.setName("foobar");
  BOOST_TEST(b.getThreadPropBuffer() != bOld);
}

BOOST_AUTO_TEST_CASE(minQueueSize)
{
  // min queue size should affect default constructed
  // context queue size

  ThreadContext::setMinQueueSize(1024);
  BOOST_TEST(1024 == ThreadContext::getMinQueueSize());

  ThreadContext a;
  BOOST_TEST(a.getEntryQueue().size() >= 1024);
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/unit/EventSourceTest.C
#include <vector>
#include <utility>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <binlog/reader/entry/EventSource.H>

BOOST_AUTO_TEST_SUITE(EventSource)

BOOST_AUTO_TEST_CASE(shortFunction)
{
  std::vector<std::pair<std::string, std::string>> funcs {
    {"foobar", "foobar"},
    {"fooBar(int, int)", "fooBar"},
    {"barbaz<int>(long)", "barbaz"},
    {"Class::eleven", "Class::eleven"},
    {"Class<int, x>::eleven", "Class::eleven"},
    {"func<void()>(V<T>, int)", "func"},
    {"Foo<int, long, 3>::bar<std::string>()", "Foo::bar"},
    {"Voice<20, Recognition<a<b>, b>>::Elevator<i, j>(k, l)", "Voice::Elevator"},
    {"Voice<20, Recognition<a<b>, b>>::Elevator<i, j>(int(), l(*)(A<B>,C))", "Voice::Elevator"},
    {"Voice<20, Recognition<a<b>, b>>::Elevator<i, j>(int(), l(*)(A<B>,C))", "Voice::Elevator"},
    {"Voice<20, Recognition<a<b>, b>>::Elevator<i, j>(int(), l(*)(A<B>,C))", "Voice::Elevator"},
    {"foo() const", "foo"},
    {"foo() volatile", "foo"},
    {"foo() const volatile", "foo"},
    {"foo() const &", "foo"},
    {"foo() volatile &", "foo"},
    {"foo() const volatile &", "foo"},
    {"foo() const&&", "foo"},
    {"foo() volatile&&", "foo"},
    {"foo() const volatile&&", "foo"},
    {"foo::bar::baz::qux(int) const", "baz::qux"},
    {"foo::bar<X>::baz::qux(int) volatile", "baz::qux"},
    {"foo::bar<X>::baz::qux<Y>(int) const", "baz::qux"},
  };

  for (auto&& func : funcs)
  {
    binlog::reader::entry::EventSource eventSource(
      0, nullptr, "category", binlog::debug, "format", "typeCodes",
      {func.first, "file", 0}
    );

    BOOST_TEST(func.second == eventSource.shortFunction());
  }
}

BOOST_AUTO_TEST_SUITE_END()
Attention:  ./test/integration/Categories.C
#define BINLOG_USER_META "foo"
#define BINLOG_USER_PROJECT "bar"
#define BINLOG_USER_RELEASE "baz"

#include <binlog/Binlog.H>

BINLOG_INIT

#define CUSTOM_CATEGORY custom
BINLOG_DEFINE_SUBCATEGORY(CUSTOM_CATEGORY)

#define OTHER_CATEGORY other
BINLOG_DEFINE_SUBCATEGORY(OTHER_CATEGORY)

#define CUSTOM_INFO(...) BINLOG_CATEGORIZED_INFO(CUSTOM_CATEGORY, __VA_ARGS__)
#define OTHER_INFO(...)  BINLOG_CATEGORIZED_INFO(OTHER_CATEGORY,  __VA_ARGS__)

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::openLogFile(logfile);

  BINLOG_INFO("Use default category");
  // Outputs: foo/bar/baz Use default category

  BINLOG_CATEGORIZED_INFO(CUSTOM_CATEGORY, "Custom category with arg: {0}", 123);
  // Outputs: foo/bar/baz/custom Custom category with arg: 123
  CUSTOM_INFO("Custom category shortcut, with arg: {0}", 456);
  // Outputs: foo/bar/baz/custom Custom category shortcut, with arg: 456

  BINLOG_CATEGORIZED_INFO(OTHER_CATEGORY, "Other category with arg: {0}", 123);
  // Outputs: foo/bar/baz/other Other category with arg: 123
  OTHER_INFO("Other category shortcut, with arg: {0}", 789);
  // Outputs: foo/bar/baz/other Other category shortcut, with arg: 789

  return 0;
}
Attention:  ./test/integration/ElasticQueues.C
#include <memory>
#include <thread>

#define BINLOG_USER_RELEASE "inttest"

#include <binlog/Binlog.H>
#include <binlog/Configuration.H>

BINLOG_INIT

std::size_t getQueueSize()
{
  return binlog::detail::ThisThreadContext::get().getEntryQueue().size();
}

void checkQueueSize(std::size_t expectedQueueSize)
{
  if (getQueueSize() != expectedQueueSize) { std::terminate(); }
}

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  constexpr std::size_t buffSize = 128;
  constexpr std::size_t initialQueueSize = buffSize * 8;

  std::unique_ptr<char[]> buff(new char[buffSize]());

  binlog::getConfiguration().setMinQueueSize(initialQueueSize);
  binlog::getConfiguration().setAdaptiveSeverityCeiling(binlog::trace);
  binlog::setThreadName("main");

  // We do not start a consumer here, but start filling the internal buffers

  for (int i = 0; i < 16; ++i)
  {
    BINLOG_INFO("Fill all the buffers with zeros: {0}", binlog::array(buff.get(), buffSize));
  }

  // at least one new queue had to be allocated, not smaller than before
  if (getQueueSize() < initialQueueSize) { std::terminate(); }

  // A big request should create an even larger queue,
  // even if buffer size > total queue size

  std::size_t queueSize = getQueueSize();
  const auto largeBuffSize = unsigned(queueSize * 2);
  std::unique_ptr<char[]> largeBuff(new char[largeBuffSize]());

  BINLOG_INFO("Get a bigger queue: {0}", binlog::array(largeBuff.get(), largeBuffSize));

  queueSize = getQueueSize();
  if (queueSize < largeBuffSize) { std::terminate(); }

  // other threads shouldn't be affected.
  std::thread t(checkQueueSize, initialQueueSize);
  t.join();

  // Confg change doesn't affect already allocated queues:
  //[change_size
  binlog::getConfiguration().setMinQueueSize(1 << 21); // New threads will have 2 MB queues
  //]

  checkQueueSize(queueSize);

  // Now flush the buffers
  // The resulting file should have 16+1 lines (no event swallowed)
  binlog::openLogFile(logfile);

  return 0;
}
Attention:  ./test/integration/ConfigurationFileReference.C
#include <iostream>
#include <exception> // std::terminate
#include <cstdlib> // setenv

#include <binlog/Binlog.H>
#include <binlog/Configuration.H>
#include <binlog/sink/MultiConsumer.H>

BINLOG_INIT

struct CustomSink : binlog::sink::Sink
{
  void operator()(const char*, std::size_t) {}
};

int main(int argc, char* argv[])
{
  if (argc < 2)
  {
    std::cerr << "Usage: " << argv[0] << " config.json\n";
    return 1;
  }

  const char* path_to_config = argv[1];

  const char* varname = "MYAPP";
  const char* varval = "binlog-inttest-configfileref";
  setenv(varname, varval, 1);

  // Define some to have matching sources
  BINLOG_INFO("Foo");
  BINLOG_WARNING("Bar");
  BINLOG_CRITICAL("Foobar");

  // Read config, check results

  //[init_from_config
  binlog::getConfiguration().initFromConfig(path_to_config); // throws std::runtime_error
  //]

  auto&& mc = binlog::sink::MultiConsumer::getInstance();
  mc.describeSinks(std::cout);

  return 0;
}
Attention:  ./test/integration/Logging.C
#include <string>

#include <binlog/Binlog.H>

BINLOG_INIT

bool errorCondition(const std::string& msg)
{
  BINLOG_ERROR("Error: {0}", msg);
  return true;
}

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::openLogFile(logfile);

  // enable all severities
  binlog::setCategoryConfigs({{"*", {binlog::trace}}});

  // Severity levels
  BINLOG_TRACE("Trace level");
  // Outputs: Trace level
  BINLOG_DEBUG("Debug level");
  // Outputs: Debug level
  BINLOG_INFO("Info level");
  // Outputs: Info level
  BINLOG_WARNING("Warning level");
  // Outputs: Warning level
  BINLOG_ERROR("Error level");
  // Outputs: Error level
  BINLOG_CRITICAL("Critical level");
  // Outputs: Critical level

  int a = 0;
  int b = 1;

  //[IndexedPlaceholders
  BINLOG_INFO("First argument: {0}, second argument: {1}", a, b);
  //]
  // Outputs: First argument: 0, second argument: 1

  // curly braces must be escaped
  BINLOG_INFO("Open curly: {{ closing curly: }}, arg like curly {{0}}");
  // Outputs: Open curly: { closing curly: }, arg like curly {0}

  //[Reordering
  BINLOG_INFO("Second argument: {1}, first argument: {0}", 1, 2);
  // Outputs: Second argument: 2, first argument: 1
  //]

  //[SingleCapture
  BINLOG_INFO("Log the same argument: {0}, twice: {0}", a);
  // `a` will be saved only once
  //]
  // Outputs: Log the same argument: 0, twice: 0

  // increase severity threshold
  binlog::setCategoryConfigs({{"*", {binlog::warning}}});

  // If severity is disabled, arguments shouldn't be evaluated
  // Unless BINLOG_ALWAYS_LOG is defined
  BINLOG_INFO(
    "You can't see mee, for sure. But can you see my arg: {0}?",
    errorCondition(std::string("Argument evaluated for disabled source"))
  );

  // Implementation must properly concat multi string format
  BINLOG_WARNING("Multi" " string literal " "{0}" " the win", 4);
  // Outputs: Multi string literal 4 the win

  return 0;
}
Attention:  ./test/integration/LoadSo.C
#include <dlfcn.h> // dlopen, dlerror, dlsym
#include <cstdio>  // fprintf
#include <libgen.h> // dirname

#include <sstream>

#ifndef LOAD_SO_COMPILE_SO
  #define BINLOG_USER_RELEASE "inttest"
#else
  #define BINLOG_USER_RELEASE "inttest_dso"
#endif
#include <binlog/Binlog.H>

BINLOG_INIT

extern "C" {

void doLog()
{
  BINLOG_INFO("Inception here");
  BINLOG_WARNING("Exception there");
}

} // extern C

#ifndef LOAD_SO_COMPILE_SO

bool doLogSo(const std::string& dsoPath)
{
  void* dso = dlopen(dsoPath.c_str(), RTLD_LAZY);
  if (!dso)
  {
    fprintf(stderr, "dlopen: %s\n", dlerror());
    return false;
  }

  void* func = dlsym(dso, "doLog");
  if (!func)
  {
    fprintf(stderr, "dlsym: %s\n", dlerror());
    return false;
  }

  auto logger = reinterpret_cast<void(*)()>(func);

  logger();

  if(dlclose(dso))
  {
    fprintf(stderr, "dlclose: %s\n", dlerror());
    return false;
  }

  return true;
}

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test-dso.log";
  binlog::openLogFile(logfile);
  binlog::setThreadName("main");

  const auto pathBufferSize = strlen(argv[0]) + 1;
  std::unique_ptr<char[]> pathBuffer(new char[pathBufferSize]);
  strncpy(pathBuffer.get(), argv[0], pathBufferSize);

  std::stringstream dsoPathStr;
  dsoPathStr << dirname(pathBuffer.get()) << "/libLoadSo";
#ifndef NDEBUG
  dsoPathStr << "-g";
#endif
  dsoPathStr << ".so";

  auto dsoPath = dsoPathStr.str();

  doLog();

  doLogSo(dsoPath);
  doLogSo(dsoPath);

  // it would be great to find a way to
  // load it to a different address the second time

  return 0;
}

#endif // LOAD_SO_COMPILE_SO
Attention:  ./test/integration/Severities.C
#include <binlog/Binlog.H>

BINLOG_INIT

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::openLogFile(logfile);

  BINLOG_TRACE("Trace 0, disabled");

  // trace is disabled by default
  binlog::setCategoryConfigs({{"*", {binlog::trace}}});

  BINLOG_TRACE("Trace 1");
  BINLOG_DEBUG("Debug 1");
  BINLOG_INFO("Info 1");
  BINLOG_WARNING("Warning 1");
  BINLOG_ERROR("Error 1");
  BINLOG_CRITICAL("Critical 1");
  BINLOG_BEGIN_FLOW("{0:foo}", 1);
  BINLOG_END_FLOW("{0:foo}", 1);

  return 0;
}

Attention:  ./test/integration/LoggingEnums.C
#include <binlog/Binlog.H>

BINLOG_INIT

//[enum
enum Tristate { YES, NO, MAYBE };

BINLOG_MAKE_ENUM_LOGGABLE(Tristate, YES, NO, MAYBE)
//]

void logEnum()
{
  //[enum

  BINLOG_INFO("Ever heard about the slow yes? {0}", MAYBE);
  // Outputs: Ever heard about the slow yes? MAYBE
  //]
}

enum Boolean { TRUE = 0, FALSE = 1, INVALID };
BINLOG_MAKE_ENUM_LOGGABLE(Boolean, TRUE, FALSE)

void logInvalid()
{
  Boolean invalid = INVALID;
  BINLOG_INFO("What is this: {0}?", invalid);
  // Outputs: What is this: N/A?
}

enum TypedEnum : char { A = 'A', B = 'B' };
BINLOG_MAKE_ENUM_LOGGABLE(TypedEnum, A, B)

void logTyped()
{
  BINLOG_INFO("Typed enum: {0}", TypedEnum::A);
  // Outputs: Typed enum: A
}

enum class Either { Pass, Fail };
BINLOG_MAKE_ENUM_LOGGABLE(Either, Either::Pass, Either::Fail)

void logEnumClass()
{
  BINLOG_INFO("Enum class: {0}", Either::Pass);
  // Outputs: Enum class: Either::Pass
}

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::openLogFile(logfile);

  logEnum();
  logInvalid();
  logTyped();
  logEnumClass();

  return 0;
}
Attention:  ./test/integration/LogRotation.C
#include <binlog/Binlog.H>
#include <binlog/sink/Consumer.H>
#include <binlog/sink/FileSink.H>

BINLOG_INIT

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::sink::Consumer<binlog::sink::FileSink> consumer(logfile);

  auto&& fileSink = consumer.getSink();
  fileSink.rotateBySize(128);
  fileSink.compression(true);

  BINLOG_INFO("1");
  // Outputs: 1
  BINLOG_INFO("2");
  // Outputs: 2
  BINLOG_INFO("3");
  // Outputs: 3
  BINLOG_INFO("4");
  // Outputs: 4

  consumer.consume();

  BINLOG_INFO("5");
  // Outputs: 5
  BINLOG_INFO("6");
  // Outputs: 6
  BINLOG_INFO("7");
  // Outputs: 7
  BINLOG_INFO("8");
  // Outputs: 8

  consumer.consume();

  BINLOG_INFO("9");
  // Outputs: 9
  BINLOG_INFO("A");
  // Outputs: A
  BINLOG_INFO("B");
  // Outputs: B
  BINLOG_INFO("C");
  // Outputs: C

  consumer.consume();

  return 0;
}
Attention:  ./test/integration/LoggingStructures.C
#include <mutex>
#include <algorithm>

#include <binlog/Binlog.H>

BINLOG_INIT

//[DefineStructure
struct CustomLoggableType
{
  int alpha;
  std::string bravo;
  std::size_t charlie;
  std::mutex mutex; // transient field
};
//]

//[MakeLoggable
BINLOG_MAKE_LOGGABLE(CustomLoggableType, alpha, bravo, charlie)
//]

void logStructure()
{
  //[LogStructure
  CustomLoggableType clt{13, "foo", 37, {}};
  BINLOG_INFO("Look at this: {0}", clt);
  // Outputs: Look at this: CustomLoggableType{ alpha: 13, bravo: foo, charlie: 37 }
  //]
}

//[FriendAccessor
class MyPrivate
{
  int secret = 2471;
  friend class binlog::detail::LoggableDescriptor<MyPrivate>;
};
//]

BINLOG_MAKE_LOGGABLE(MyPrivate, secret)

void logWithPrivate()
{
  MyPrivate plt;
  BINLOG_INFO("Private field accessible: {0}", plt);
  // Outputs: Private field accessible: MyPrivate{ secret: 2471 }
}

//[WithGetter
struct LotteryResults
{
  std::vector<short> numbers;

  // This is a getter, const and takes no arguments.
  // Important: Logging is not allowed in getters.
  int sum() const
  {
    return std::accumulate(numbers.begin(), numbers.end(), 0);
  }
};

BINLOG_MAKE_LOGGABLE(LotteryResults, numbers, sum)
//]

void logWithGetter()
{
  LotteryResults res;
  res.numbers = {4 ,8, 15, 16, 23, 42};

  //[WithGetter

  BINLOG_INFO("The numbers: {0}", res);
  // Outputs: The numbers: LotteryResults{ numbers: [4, 8, 15, 16, 23, 42], sum: 108 }
  //]
}

struct TrickyGetter
{
  // disambiguate proper getter - the const qualified nullary
  std::string name() { return "nc name"; }
  std::string name() const { return "name"; }
  int name(int) { return 42; }

  bool ageThrows = false;

  int age() const
  {
    if (ageThrows) { throw std::runtime_error("Test throwing getter"); }
    return 33;
  }

  int price() const
  {
    // Currently, logging in getters is not supported
    // BINLOG_CRITICAL("You can't put a price on me");
    return 0;
  }

  mutable int allowedTagCalls = 100;

  std::string tag() const
  {
    --allowedTagCalls;
    if (! allowedTagCalls) { throw std::runtime_error("No more tag here"); }
    return "pag";
  }
};

BINLOG_MAKE_LOGGABLE(TrickyGetter, name, age, price, tag)

void logWithTrickyGetter()
{
  TrickyGetter t;

  BINLOG_INFO("TG: {0}", t);
  // Outputs: TG: TrickyGetter{ name: name, age: 33, price: 0, tag: pag }

  t.ageThrows = true;

  try
  {
    BINLOG_INFO("TG age throws: {0}", t);
  }
  catch (const std::runtime_error&) {}

  t.allowedTagCalls = 1;

  try
  {
    // getter called twice: first, to get required buffer size,
    // second, to copy value to the allocated buffer.
    // If this changes later, just remove the `tag` related test code
    BINLOG_INFO("TG tag throws: {0}", t);
  }
  catch (const std::runtime_error&) {}
}

//[Template
template <typename T0, typename T1, typename T2>
struct CustomTemplate { T0 t0; T1 t1; T2 t2; };

namespace binlog { namespace detail {

template <typename A, typename B>
BINLOG_UNQUALIFIED_MAKE_LOGGABLE((CustomTemplate<A,B,int>), t0, t1, t2)

}} // namespace binlog::detail
//]

void logTemplate()
{
  CustomTemplate<char, short, int> triplet{'H', 4, 77};
  BINLOG_INFO("Logging a custom template: {0}", triplet);
  // Outputs: Logging a custom template: CustomTemplate<A,B,int>{ t0: 72, t1: 4, t2: 77 }
}

struct Nested
{
  std::string name;
};

struct Nest
{
  int count;
  Nested n;
};

BINLOG_MAKE_LOGGABLE(Nested, name);
BINLOG_MAKE_LOGGABLE(Nest, count, n);

void logNested()
{
  Nest nest{10, Nested{"bird"}};
  BINLOG_INFO("Nest: {0}", nest);
  // Outputs: Nest: Nest{ count: 10, n: Nested{ name: bird } }
}

struct Nocopymove
{
  Nocopymove(int v) : value(v) {}

  Nocopymove(const Nocopymove&) = delete;
  void operator=(const Nocopymove&) = delete;
  Nocopymove(Nocopymove&&) = delete;
  void operator=(Nocopymove&&) = delete;

  int value;
};

BINLOG_MAKE_LOGGABLE(Nocopymove, value);

void logNocopymove()
{
  Nocopymove n{123};
  BINLOG_INFO("Arg is not copied or moved: {0}", n);
  // Outputs: Arg is not copied or moved: Nocopymove{ value: 123 }
}

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::openLogFile(logfile);

  logStructure();
  logWithPrivate();
  logWithGetter();
  logWithTrickyGetter();
  logTemplate();
  logNested();
  logNocopymove();

  return 0;
}
Attention:  ./test/integration/Writer.C
#define __STDC_LIMIT_MACROS

#include <string>
#include <vector>
#include <set>
#include <list>
#include <map>
#include <array>
#include <iostream>
#include <cstdint>

#define BINLOG_USER_RELEASE "inttest"

#include <binlog/Binlog.H>
#include <binlog/Configuration.H>

#include <binlog/sink/Consumer.H>
#include <binlog/sink/FileSink.H>
#include <binlog/detail/WaitStrategy.H>

BINLOG_INIT

template <typename Arg>
void logArg(Arg arg)
{
  static int count = 0;
  ++count; // Prevent inlining to keep the function name
  BINLOG_INFO("[{0}]", arg);
}

struct CustomType {}; // not loggable

struct NestedStruct
{
  char foxtrot;
  int golf;
};

struct CustomLoggableType
{
  long alpha;
  int bravo;
  std::string charlie;
  NestedStruct delta;
  float echo;
};

struct MyPrivType
{
  MyPrivType(short s, long m) : secret(s), mistery(m) {}
  virtual ~MyPrivType() {}

private:
  short secret;
  long mistery;

  friend class binlog::detail::LoggableDescriptor<MyPrivType>;

public:
  int notStandardLayout = 0;
  virtual void notABitOfStdLayout() {}
};

class Person
{
public:
  int age = 27;
  const std::string _id;

  Person() : _id("pid") {}
  virtual ~Person() {}
  virtual std::string getName() const = 0;
  virtual std::string getName(int) const { return "Wrong"; } // overload taking parameter
  virtual std::string getName() { return "Wrong"; } // non-const overload
  inline const std::string& id() const { return _id; }
};

class NamedPerson : public Person
{
  std::string getName() const { return "Joe"; }
};

struct Nocopy
{
  Nocopy(int v) : value(v) {}
  Nocopy(const Nocopy&) = delete;
  void operator=(const Nocopy&) = delete;

  int value;
};

struct NocopyWrapper
{
  int id;
  Nocopy nocopy;
};

template <typename T0, typename T1, typename T2>
struct CustomTemplate
{
  T0 t0;
  T1 t1;
  T2 t2;
};

BINLOG_MAKE_LOGGABLE(NestedStruct, foxtrot, golf)
BINLOG_MAKE_LOGGABLE(CustomLoggableType, alpha, bravo, charlie, delta, echo)
BINLOG_MAKE_LOGGABLE(MyPrivType, secret, mistery)
BINLOG_MAKE_LOGGABLE(Person, id, age, getName)
BINLOG_MAKE_LOGGABLE(Nocopy, value)
BINLOG_MAKE_LOGGABLE(NocopyWrapper, id, nocopy)

namespace binlog { namespace detail {

template <typename A, typename B>
BINLOG_UNQUALIFIED_MAKE_LOGGABLE((CustomTemplate<A,B,int>), t0, t1, t2)

}} // namespace binlog::detail

unsigned g_knownEventSourceLine;

void logIfEnabled()
{
  g_knownEventSourceLine = __LINE__ + 1;
  BINLOG_INFO("(X) Event source triggered at known position");
}

void testSourceSpecificConfig()
{
  BINLOG_WARNING("(X) should appear:");
  logIfEnabled();

  binlog::getConfiguration().toggleSource("Writer.C", g_knownEventSourceLine, false);

  BINLOG_WARNING("No (X) should appear now, source is disabled.");
  logIfEnabled();

  binlog::getConfiguration().toggleSource("Writer.C", g_knownEventSourceLine, true);

  BINLOG_WARNING("(X) should appear again:");
  logIfEnabled();
}

enum Tristate { YES, NO, MAYBE, STATE_WE_FORGET_ABOUT };

BINLOG_MAKE_ENUM_LOGGABLE(Tristate, YES, NO, MAYBE)

using binlog::sink::FileSink;

template <typename WS>
FileSink* createFileSink(const char* logfile)
{
  try
  {
    static WS waitStrategy;
    static binlog::sink::Consumer<FileSink> consumer(logfile);

    consumer.start(waitStrategy);
    return &consumer.getSink();
  }
  catch(const std::runtime_error& ex)
  {
    return nullptr;
  }
}

FileSink* createFileSinkBlockingWait(const char* logfile)
{
  return createFileSink<binlog::detail::BlockWaitStrategy>(logfile);
}

FileSink* createFileSinkPipeWait(const char* logfile)
{
  return createFileSink<binlog::detail::PipeWaitStrategy>(logfile);
}

FileSink* createFileSinkSleepWait(const char* logfile)
{
  return createFileSink<binlog::detail::SleepWaitStrategy>(logfile);
}

void managedFunction(int a, int b)
{
  binlog::FunctionGuard guard;
  binlog::FunctionGuard guardArgs(a, b);
  binlog::EnterFunctionGuard enterGuard(a, b);
  binlog::LeaveFunctionGuard leaveGuard;

  BINLOG_INFO("Do work in managed function: a+b = {0}", a+b);

  // guards emit exit events here
}

void sleepIfRotate(const std::string& rotateStrategy)
{
  if (rotateStrategy != "none")
  {
    std::this_thread::sleep_for(std::chrono::milliseconds{20});
  }
}

bool errorCondition(const std::string& msg)
{
  BINLOG_ERROR("Error: {0}", msg);
  return true;
}

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";
  const std::string waitStrategyName = (argc >= 3) ? argv[2] : "sleep";
  const std::string rotateStrategy = (argc >= 4) ? argv[3] : "none";
  const std::string compression = (argc >= 5) ? argv[4] : "none";

  binlog::setCategoryConfigs({
    {"mstk/binlog/inttest", {binlog::trace}},
    {"*",                   {binlog::none}}
  });

  // Set thread name
  binlog::setThreadName("This is a very long name. Don't worry, I'll change it");
  binlog::setThreadName("wr_thread");

  BINLOG_CRITICAL("Log entry before opening log file");

  FileSink* pFileSink = nullptr;
  bool fileOpened = false;

  if (waitStrategyName == "block")
  {
    pFileSink = createFileSinkBlockingWait(logfile);
    fileOpened = (pFileSink != nullptr);
  }
  else if (waitStrategyName == "pipe")
  {
    pFileSink = createFileSinkPipeWait(logfile);
    fileOpened = (pFileSink != nullptr);
  }
  else
  {
    pFileSink = createFileSinkSleepWait(logfile);
    fileOpened = (pFileSink != nullptr);
  }

  if (!fileOpened)
  {
    std::cerr << "Failed to open logfile: '" << logfile << "'" << std::endl;
    return 1;
  }

  if (pFileSink && rotateStrategy == "size")
  {
    pFileSink->rotateBySize(128);
  }
  else if (pFileSink && rotateStrategy == "time")
  {
    pFileSink->rotateByTime(std::chrono::seconds{1});
  }

  if (pFileSink && compression == "compression")
  {
    pFileSink->compression(true);
  }

  // BINLOG_* macros
  BINLOG_TRACE("Trace");
  BINLOG_DEBUG("Debug");
  BINLOG_INFO("Info");
  BINLOG_WARNING("Warning");
  BINLOG_ERROR("Error");
  BINLOG_CRITICAL("Critical");

  // Argument types
  logArg<bool>(true);
  logArg<bool>(false);
  logArg<char>('A');
  logArg<short>(123);
  logArg<int>(123);
  logArg<long>(123);
  logArg<long long>(123);
  logArg<float>(123.456f);
  logArg<double>(123.456);
  logArg<unsigned>(123);
  logArg<std::size_t>(123);
  logArg<const char*>("123");
  logArg<std::string>("123");

  logArg<const char>('A');
  logArg<const short>(123);
  logArg<const int>(123);
  logArg<const long>(123);
  logArg<const long long>(123);
  logArg<const float>(123.456f);
  logArg<const double>(123.456);
  logArg<const unsigned>(123);
  logArg<const std::size_t>(123);
  logArg<const char * const>("123");
  logArg<const std::string>("123");

  logArg<volatile char>('A');
  logArg<volatile short>(123);
  logArg<volatile int>(123);
  logArg<volatile long>(123);
  logArg<volatile long long>(123);
  logArg<volatile float>(123.456f);
  logArg<volatile double>(123.456);
  logArg<volatile unsigned>(123);
  logArg<volatile std::size_t>(123);
  logArg<volatile const char*>("123");
  logArg<volatile std::string>("123");

  logArg<volatile const char>('A');
  logArg<volatile const short>(123);
  logArg<volatile const int>(123);
  logArg<volatile const long>(123);
  logArg<volatile const long long>(123);
  logArg<volatile const float>(123.456f);
  logArg<volatile const double>(123.456);
  logArg<volatile const unsigned>(123);
  logArg<volatile const std::size_t>(123);
  logArg<volatile const char * const>("123");
  logArg<volatile const std::string>("123");

  // cstdint types
  BINLOG_INFO("Small negative numbers follow:");
  logArg<int8_t>(INT8_MIN);
  logArg<int16_t>(INT16_MIN);
  logArg<int32_t>(INT32_MIN);
  logArg<int64_t>(INT64_MIN);

  logArg<int_fast8_t>(INT_FAST8_MIN);
  logArg<int_fast16_t>(INT_FAST16_MIN);
  logArg<int_fast32_t>(INT_FAST32_MIN);
  logArg<int_fast64_t>(INT_FAST64_MIN);

  logArg<int_least8_t>(INT_LEAST8_MIN);
  logArg<int_least16_t>(INT_LEAST16_MIN);
  logArg<int_least32_t>(INT_LEAST32_MIN);
  logArg<int_least64_t>(INT_LEAST64_MIN);

  logArg<intmax_t>(INTMAX_MIN);
  logArg<intptr_t>(INTPTR_MIN);

  BINLOG_INFO("Huge positive numbers follow:");
  logArg<uint8_t>(UINT8_MAX);
  logArg<uint16_t>(UINT16_MAX);
  logArg<uint32_t>(UINT32_MAX);
  logArg<uint64_t>(UINT64_MAX);

  logArg<uint_fast8_t>(UINT_FAST8_MAX);
  logArg<uint_fast16_t>(UINT_FAST16_MAX);
  logArg<uint_fast32_t>(UINT_FAST32_MAX);
  logArg<uint_fast64_t>(UINT_FAST64_MAX);

  logArg<uint_least8_t>(UINT_LEAST8_MAX);
  logArg<uint_least16_t>(UINT_LEAST16_MAX);
  logArg<uint_least32_t>(UINT_LEAST32_MAX);
  logArg<uint_least64_t>(UINT_LEAST64_MAX);

  logArg<uintmax_t>(UINTMAX_MAX);
  logArg<uintptr_t>(UINTPTR_MAX);

  logArg<char16_t>(123);
  logArg<char32_t>(123);
  logArg<wchar_t>(123);

  sleepIfRotate(rotateStrategy);

  BINLOG_INFO("[{0}]", "123");

 // Single capture
  BINLOG_INFO("Write the same argument: {0} twice: {0}", 123);

  // Argument reordering
  BINLOG_INFO("Write arguments in arbitrary order: {3} then {0}, {2} and {1}", 2, 4, 3, 1);

  // Argument spec. like entries (escaping)
  BINLOG_INFO("Curly braces: {{ and }}, also: {{0}}"); // no argument required

  sleepIfRotate(rotateStrategy);

  // The following should static assert:
//  CustomType custom;
//  BINLOG_INFO("Unsupported type: {0}", custom);

  // Test structure logging
  CustomLoggableType clt{1, 2, "abcdefg", {'a', 23}, 6.53f};
  BINLOG_WARNING("Look at these compounds: {0}", clt);

  MyPrivType priv(123, 456);
  BINLOG_WARNING("Private fields? Friend me: {0}", priv);

  const CustomLoggableType& constClt = clt;
  BINLOG_WARNING("Logging const struct: {0}", constClt);

  CustomTemplate<char, long, int> cltempl{'a', 123, 456};
  BINLOG_WARNING("Class template? At your service: {0}", cltempl);

  // increase severity threshold
  binlog::setCategoryConfigs({
    {"mstk/binlog/inttest", {binlog::warning}},
    {"*",                   {binlog::none}}
  });

  // Test always log
  BINLOG_INFO("I'm sure it's a -DBINLOG_ALWAYS_LOG build, yes?");

  // If severity is disabled, arguments shouldn't be evaluated
#ifndef BINLOG_ALWAYS_LOG
  BINLOG_INFO(
    "You can't see mee, for sure. But can you see my arg: {0}?",
    errorCondition(std::string("Argument evaluated for disabled source"))
  );
#endif

  // change threshold back to all
  binlog::setCategoryConfigs({
    {"mstk/binlog/inttest", {binlog::debug}},
    {"*",                   {binlog::debug}}
  });

  // no control events by default
  BINLOG_BEGIN_FLOW("Hello {0:flowName}", 123u);
  BINLOG_END_FLOW("Bye {0:flowName}", 123u);

  // Test array logging
  int iarray[] = {1, 2, 3};
  BINLOG_INFO("Let's see an array: {0}", binlog::array(iarray, 3));

  MyPrivType sarray[] = {{1,2}, {3,4}};
  BINLOG_INFO(
    "And let's see something totally different. An array: {0}",
    binlog::array(sarray, 2)
  );

  const char* asciiData = "larch";
  const char rawData[]  = {0, 1, 2, 3, 'a'};
  BINLOG_INFO("Raw data ascii: {0}", binlog::array(asciiData, 5));
  BINLOG_INFO("Raw data hex: {0}", binlog::array(rawData, 5));

  // std types and containers
  {
    // Test std::pair logging
    auto pair = std::make_pair(257, "foobar");
    BINLOG_INFO("A larch. Or rather, a pair: {0}, whatever", pair);

    // Test std::tuple logging
    auto tuple = std::make_tuple(257, "foobar", 1.5f);
    BINLOG_INFO("A product of types, i.e: a tuple: {0}", tuple);

    std::vector<int> vec{1, 2, 3};
    std::array<int, 3> arr{1, 2, 3};
    std::set<int> set{1, 2, 3};
    std::list<int> list{1, 2, 3};

    BINLOG_INFO("Variation of the same seq: {0}", vec);
    BINLOG_INFO("Variation of the same seq: {0}", arr);
    BINLOG_INFO("Variation of the same seq: {0}", set);
    BINLOG_INFO("Variation of the same seq: {0}", list);

    std::map<int, std::string> map{
      {0, "Arpad"},
      {1, "Elod"},
      {2, "Ond"},
      {3, "Kond"},
    };

    BINLOG_INFO("And the all time leader, the map: {0}", map);

    // map with struct key
    std::vector<int> key{13, 37};
    std::map<std::vector<int>, double> map2{{key, 9.9}};
    BINLOG_INFO("Map with struct key: {0}", map2);
  }

  // Derived fields by getters
  NamedPerson joe;
  Person& p = joe;
  BINLOG_INFO("Derived fields? Not an issue: {0}", p);

  // enum logging
  Tristate yes = YES;
  BINLOG_INFO("This is an enum: {0}", yes);
  BINLOG_INFO("This is an enum: {0}", NO);
  BINLOG_INFO("This is an enum: {0}", STATE_WE_FORGET_ABOUT);

  // test function guard
  managedFunction(13, 37);

  // Test if optimizer behaves (missing .cfi_endproc)
  if (argc > 30)
  {
    BINLOG_INFO("String A");
  }
  else
  {
    BINLOG_INFO("String B");
  }

  // Test serialization of Non-copiable structures
  {
    Nocopy nc{1};
    NocopyWrapper ncw{1, {2}};

    BINLOG_INFO("Nocopy: {0}, NocopyWrapper: {1}", nc, ncw);
  }

  // Test transform
  {
    Nocopy a(1);
    Nocopy b(2);
    Nocopy c(3);

    Nocopy* pa = &a;

    auto deref = [](Nocopy* const& p) -> Nocopy& { return *p; };

    BINLOG_INFO("Wading through pointers with transform: {0}",
      binlog::transform(pa, deref));

    auto derefRef = [](Nocopy* const& p) -> Nocopy& { return *p; };

    std::vector<Nocopy*> pv = {&a, &b, &c};
    BINLOG_INFO("Transform works for containers: {0}",
      binlog::transform(pv, derefRef));
  }

  // Multi string constant macro
  BINLOG_WARNING("Foo" "Bar" "{0}" "Baz", 4);

  testSourceSpecificConfig();

  // Test (smart) pointers
  {
    int i = 123;
    int* pI = &i;
    BINLOG_INFO("Pointer to int: {0}", pI);

    pI = nullptr;
    BINLOG_INFO("nullptr: {0}", pI);

    std::weak_ptr<int> weakIntPtr;

    {
      auto intPtr = std::make_shared<int>(123);
      BINLOG_INFO("Shared pointer: {0}", intPtr);

      std::shared_ptr<int> emptyIntPtr;
      BINLOG_INFO("Empty shared pointer: {0}", emptyIntPtr);

      weakIntPtr = intPtr;
      BINLOG_INFO("Weak pointer: {0}", weakIntPtr);
    }

    BINLOG_INFO("Empty weak pointer: {0}", weakIntPtr);

    std::unique_ptr<int> uniquePtr(new int(123));
    BINLOG_INFO("Unique pointer: {0}", uniquePtr);

    uniquePtr.reset(nullptr);
    BINLOG_INFO("Empty unique pointer: {0}", uniquePtr);
  }

  BINLOG_CRITICAL("This is the end");

  return 0;
}
Attention:  ./test/integration/GroupMe.C
#include <atomic>
#include <thread>

#include <boost/lockfree/queue.hpp>

#include <binlog/Binlog.H>
#include <binlog/Configuration.H>

BINLOG_INIT

struct Entity
{
  std::size_t id;
};

typedef boost::lockfree::queue<
  Entity,
  boost::lockfree::capacity<1 << 12>
> Queue;

Queue g_producerQueue;
Queue g_consumerQueue;

std::atomic<std::size_t> g_producerCount;
std::atomic<std::size_t> g_processorCount;

void sleep()
{
  std::this_thread::sleep_for(std::chrono::milliseconds{1});
}

void producer(const std::size_t count)
{
  for (std::size_t i = 0; i < count; ++i)
  {
    Entity entity{i};
    BINLOG_INFO("Producer: {0:entityId}", i);

    while( ! g_producerQueue.push(entity))
    {
      sleep();
    }

    BINLOG_END_FLOW("{0:entityId}", entity.id);
  }

  g_producerCount.fetch_sub(1);
}

void processor()
{
  while (g_producerCount.load() > 0 || g_producerQueue.empty() == false)
  {
    Entity entity;
    while (! g_producerQueue.pop(entity))
    {
      sleep();
    }

    BINLOG_INFO("Processor: {0:entityId}", entity.id);

    while (! g_consumerQueue.push(entity))
    {
      sleep();
    }
  }

  g_processorCount.fetch_sub(1);
}

void consumer()
{
 while (g_processorCount.load() > 0 || g_consumerQueue.empty() == false)
  {
    Entity entity;
    while (! g_consumerQueue.pop(entity))
    {
      sleep();
    }
    BINLOG_INFO("Consumer: {0:entityId}", entity.id);
  }

  BINLOG_INFO("Consumer exits");
}

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";
  const std::size_t entityCount = 100;

  binlog::openLogFile(logfile);
  binlog::getConfiguration().setAdaptiveSeverityCeiling(binlog::trace); // disable ASC

  BINLOG_INFO("Start program");

  g_producerCount.fetch_add(1);
  g_processorCount.fetch_add(1);

  std::thread prod(producer, entityCount);
  std::thread proc(processor);
  std::thread cons(consumer);

  prod.join();
  proc.join();
  cons.join();

  BINLOG_INFO("End program");

  return 0;
}
Attention:  ./test/integration/ControlFlowTracking.C
#include <binlog/Binlog.H>

BINLOG_INIT

//[FunctionGuard
int sum_int(int a, int b)
{
  binlog::FunctionGuard guard(a, b);
  return a + b;
}

int calc()
{
  binlog::FunctionGuard guard;
  return sum_int(123, 456);
}
//]

void explicit_enter_leave()
{
  binlog::EnterFunctionGuard g1;
  binlog::EnterFunctionGuard g2(123, "foo");
  binlog::LeaveFunctionGuard g3;
}

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::openLogFile(logfile);

  calc();
  // Outputs: Enter function
  // Outputs: Enter function, arguments: (123, 456)
  // Outputs: Leave function
  // Outputs: Leave function

  explicit_enter_leave();
  // Outputs: Enter function
  // Outputs: Enter function, arguments: (123, foo)
  // Outputs: Leave function

  return 0;
}
Attention:  ./test/integration/FlowMarkerFiltering.C
/*
* When MultiSink is used, empty flow begin/end pairs
* shouldn't be sent to the sinks. A flow marker pair
* is considered empty if there isn't any regular entry
* between them.
*/

#include <thread>
#include <pthread.h>

#include <binlog/Binlog.H>

#include <binlog/sink/MultiConsumer.H>

BINLOG_INIT

binlog::sink::MultiConsumer mc;

pthread_barrier_t consumeBarrier;

void consume()
{
  if (pthread_barrier_wait(&consumeBarrier) == PTHREAD_BARRIER_SERIAL_THREAD)
  {
    mc.consume();
  }
}

void logger(const char* threadName)
{
  int i = 1;

  binlog::setThreadName(threadName);

  // Empty flow markers should be ignored
  BINLOG_BEGIN_FLOW("IGNORED {0:foo}", i);
  BINLOG_END_FLOW("IGNORED {0:foo}", i);

  consume(); ++i;

  // Even if some nested ignored stuff is interleaved
  BINLOG_BEGIN_FLOW("IGNORED {0:foo}", i);
  BINLOG_BEGIN_FLOW("IGNORED {0:bar}", i);
  BINLOG_END_FLOW("IGNORED {0:bar}", i);
  BINLOG_END_FLOW("IGNORED {0:foo}", i);

  consume(); ++i;

  // Even if the closing order is funny
  BINLOG_BEGIN_FLOW("IGNORED {0:foo}", i);
  BINLOG_BEGIN_FLOW("IGNORED {0:bar}", i);
  BINLOG_END_FLOW("IGNORED {0:foo}", i);
  BINLOG_END_FLOW("IGNORED {0:bar}", i);

  consume(); ++i;

  // However, if there is something between, the markers should appear
  BINLOG_BEGIN_FLOW("{0:foo}", i);
  BINLOG_INFO("Flow event");
  BINLOG_END_FLOW("{0:foo}", i);

  consume(); ++i;

  // Similar, with some extra nesting
  BINLOG_BEGIN_FLOW("{0:foo}", i);
  BINLOG_BEGIN_FLOW("IGNORED {0:baz}", i);
  BINLOG_END_FLOW("IGNORED {0:baz}", i);
  BINLOG_INFO("Flow event");
  BINLOG_END_FLOW("{0:foo}", i);

  consume(); ++i;

  // Same begins should overwrite themselves
  BINLOG_BEGIN_FLOW("IGNORED {0:foo}", i);
  BINLOG_BEGIN_FLOW("IGNORED {0:foo}", i);
  BINLOG_BEGIN_FLOW("IGNORED {0:foo}", i);
  BINLOG_BEGIN_FLOW("{0:foo}", i); // only this is needed
  BINLOG_INFO("Flow event");
  BINLOG_END_FLOW("{0:foo}", i);

  consume(); ++i;

  // Repeated ends should be dismissed
  BINLOG_END_FLOW("IGNORED {0:qux}", i);
  BINLOG_END_FLOW("IGNORED {0:qux}", i);
  BINLOG_END_FLOW("IGNORED {0:qux}", i);

  consume(); ++i;

  // Regular ES can start flow with named placeholder
  BINLOG_INFO("Flow event with arg: {0:mom}", i);
  BINLOG_END_FLOW("{0:mom}", i);

  consume(); ++i;

  // Entries are ignored properly, even at batch end
  BINLOG_BEGIN_FLOW("IGNORED {0:foo}", i);
  consume();
  BINLOG_END_FLOW("IGNORED {0:foo}", i);

  consume(); ++i;

  // And overwritten if needed, at batch end
  BINLOG_BEGIN_FLOW("IGNORED {0:mom}", i);
  consume();
  BINLOG_BEGIN_FLOW("{0:mom}", i);
  BINLOG_INFO("Flow event");
  BINLOG_END_FLOW("{0:mom}", i);

  consume(); ++i;

  // And kept properly under similar conditions
  BINLOG_BEGIN_FLOW("{0:foo}", i);
  consume();
  BINLOG_INFO("Flow event");
  BINLOG_END_FLOW("{0:foo}", i);

  consume(); ++i;

  // Even the active state is persisted between batches
  BINLOG_BEGIN_FLOW("{0:foo}", i);
  BINLOG_INFO("Flow event");
  consume();
  BINLOG_END_FLOW("{0:foo}", i);

  consume(); ++i;
}

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  mc.addFileSink(logfile);

  pthread_barrier_init(&consumeBarrier, nullptr, 1);

  logger("main");
  // Outputs: main Flow event
  // Outputs: main Flow event
  // Outputs: main Flow event
  // Outputs: main Flow event
  // Outputs: main Flow event
  // Outputs: main Flow event
  // Outputs: main Flow event with arg: 8

  pthread_barrier_destroy(&consumeBarrier);

  pthread_barrier_init(&consumeBarrier, nullptr, 2);

  std::thread t1(logger, "t1");
  // Outputs: t1 Flow event
  // Outputs: t1 Flow event
  // Outputs: t1 Flow event
  // Outputs: t1 Flow event
  // Outputs: t1 Flow event
  // Outputs: t1 Flow event
  // Outputs: t1 Flow event with arg: 8

  std::thread t2(logger, "t2");
  // Outputs: t2 Flow event
  // Outputs: t2 Flow event
  // Outputs: t2 Flow event
  // Outputs: t2 Flow event
  // Outputs: t2 Flow event
  // Outputs: t2 Flow event
  // Outputs: t2 Flow event with arg: 8

  t2.join();
  t1.join();

  pthread_barrier_destroy(&consumeBarrier);

  return 0;
}
Attention:  ./test/integration/ProducersNotifyConsumer.C
#include <exception>

#define BINLOG_PRODUCERS_NOTIFY_CONSUMER
#define BINLOG_CRIT_LOAD_FACTOR 10

#include <binlog/Binlog.H>
#include <binlog/Configuration.H>
#include <binlog/detail/WaitStrategy.H>
#include <binlog/detail/Core.H>

BINLOG_INIT

// Drains entry queue to prevent the allocation of a new queue
class DrainWaitStrategy : public binlog::detail::WaitStrategy
{
public:
  void reset() override {}
  void wait() override {}
  void notify() override
  {
    auto&& queue = binlog::detail::ThisThreadContext::get().getEntryQueue();

    std::size_t batchSize = 0;
    queue.checkout(batchSize);
    queue.dispose(batchSize);

    batchSize = 0;
    queue.checkout(batchSize);
    queue.dispose(batchSize);
  }
};

int main()
{
  binlog::getConfiguration().setMinQueueSize(2048);
  binlog::getConfiguration().setAdaptiveSeverityCeiling(binlog::trace);

  auto* oldQueue = & binlog::detail::ThisThreadContext::get().getEntryQueue();

  for (std::size_t i = 0; i < 2048; ++i)
  {
    BINLOG_INFO("I wont be drained: {0}", i);
  }

  auto* newQueue = & binlog::detail::ThisThreadContext::get().getEntryQueue();

  if (oldQueue == newQueue)
  {
    throw std::runtime_error("test bug: a new queue should have been allocated");
  }

  DrainWaitStrategy drainer;
  binlog::detail::Core::getInstance().setConsumerWaitStrategy(& drainer);

  for (std::size_t i = 0; i < 2048; ++i)
  {
    BINLOG_INFO("I will be drained: {0}", i);
  }

  auto* sameQueue = & binlog::detail::ThisThreadContext::get().getEntryQueue();

  if (sameQueue != newQueue)
  {
    throw std::runtime_error("the drainer was not notified or failed to clean the queue");
  }

  return 0;
}
Attention:  ./test/integration/NamedThreads.C
#include <thread>

#include <binlog/Binlog.H>

BINLOG_INIT

void threadMain(const char* name)
{
  binlog::setThreadName(name);
  BINLOG_INFO("This is the Thread of Ariadne");
}

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::openLogFile(logfile);

  //[name
  binlog::setThreadName("main");
  //]

  std::thread t1(threadMain, "producer");
  t1.join();
  // Outputs: producer This is the Thread of Ariadne

  std::thread t2(threadMain, "processor");
  t2.join();
  // Outputs: processor This is the Thread of Ariadne

  std::thread t3(threadMain, "consumer but with a very long name, excess over 31 should be discarded");
  t3.join();
  // Outputs: consumer but with a very long n This is the Thread of Ariadne

  return 0;
}
Attention:  ./test/integration/SortMeOut.C
#include <thread>

#include <binlog/Binlog.H>
#include <binlog/sink/Consumer.H>
#include <binlog/sink/FileSink.H>

BINLOG_INIT

void t2()
{
  binlog::setThreadName("t2");

  BINLOG_INFO("Enlist me");

  BINLOG_INFO("One");
  BINLOG_INFO("Two");
  BINLOG_INFO("Three");
}

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";
  binlog::sink::Consumer<binlog::sink::FileSink> consumer(logfile);

  binlog::setThreadName("t1");

  BINLOG_INFO("Enlist me");
  // Outputs: t1 Enlist me

  std::thread t(t2);
  // Outputs: t2 Enlist me
  // Outputs: t2 One
  // Outputs: t2 Two
  // Outputs: t2 Three
  t.join();

  BINLOG_INFO("One");
  BINLOG_INFO("Two");
  BINLOG_INFO("Three");
  // Outputs: t1 One
  // Outputs: t1 Two
  // Outputs: t1 Three

  // The consumer will pick up t1 threads buffer first,
  // consume all its events, then t2 threads buffer, thus
  // producing unsorted input.
  consumer.consume();
  return 0;
}
Attention:  ./test/integration/AdaptiveSeverityControl.C
#include <memory>
#include <exception> // terminate

#define BINLOG_USER_RELEASE "inttest"

#include <binlog/Binlog.H>
#include <binlog/Configuration.H>

BINLOG_INIT

void assertSeverityLevelIs(binlog::Severity expectedSeverity)
{
  auto&& categories = binlog::getConfiguration().getCategories();

  for (auto&& category : categories)
  {
    if (category.second->minSeverity != expectedSeverity)
    {
      std::terminate();
    }
  }
}

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  constexpr std::size_t buffSize = 2048;
  std::unique_ptr<char[]> buff(new char[buffSize]());

  binlog::getConfiguration().setMinQueueSize(buffSize * 8);
  binlog::getConfiguration().setAdaptiveSeverityCeiling(binlog::control);
  binlog::getConfiguration().setCategoryConfig("*", {binlog::trace});

  // We do not start a consumer here, but start filling the internal buffers

  // No more than 8 entries should be produced here
  // After the buffer is full, trace severity should be disabled
  for (int i = 0; i < 32; ++i)
  {
    BINLOG_TRACE("Swarm trace event with huge arg: {0}", binlog::array(buff.get(), buffSize));
  }

  assertSeverityLevelIs(binlog::debug);

  for (int i = 0; i < 32; ++i)
  {
    BINLOG_DEBUG("Swarm debug event with huge arg: {0}", binlog::array(buff.get(), buffSize));
  }

  assertSeverityLevelIs(binlog::info);

  for (int i = 0; i < 32; ++i)
  {
    BINLOG_INFO("Swarm info event with huge arg: {0}", binlog::array(buff.get(), buffSize));
  }

  assertSeverityLevelIs(binlog::warning);

  for (int i = 0; i < 32; ++i)
  {
    BINLOG_WARNING("Swarm warning event with huge arg: {0}", binlog::array(buff.get(), buffSize));
  }

  assertSeverityLevelIs(binlog::error);

  for (int i = 0; i < 32; ++i)
  {
    BINLOG_ERROR("Swarm error event with huge arg: {0}", binlog::array(buff.get(), buffSize));
  }

  assertSeverityLevelIs(binlog::critical);

  for (int i = 0; i < 32; ++i)
  {
    BINLOG_CRITICAL("Swarm critical event with huge arg: {0}", binlog::array(buff.get(), buffSize));
  }

  assertSeverityLevelIs(binlog::control);

  // reset config
  binlog::getConfiguration().setCategoryConfig("*", {binlog::trace});

  //[disable
  binlog::getConfiguration().setAdaptiveSeverityCeiling(binlog::trace); // disable Adaptive Severity Control
  //]

  // Swarm again, but no threshold change should happen, ASC is disabled
  for (int i = 0; i < 32; ++i)
  {
    BINLOG_TRACE("Trace event with huge arg, ASC disabled: {0}", binlog::array(buff.get(), buffSize));
  }

  // Now flush the buffers
  // The resulting file shouldn't have more than 8*6 + 32 = 80 lines
  binlog::openLogFile(logfile);

  return 0;
}
Attention:  ./test/integration/ExtraWriter.C
#define BINLOG_USER_RELEASE "inttest"
#include <binlog/Binlog.H>

BINLOG_INIT

#include <binlog/make_loggable/BoostOptional.H>
#include <binlog/make_loggable/BoostPointers.H>
#include <binlog/make_loggable/BoostVariant.H>
#include <binlog/make_loggable/BoostFilesystem.H>

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::setThreadName("wr_thread");
  binlog::openLogFile(logfile);

  BINLOG_INFO("If you need something extra");

  // Test boost smart pointers
  {
    boost::weak_ptr<int> weakIntPtr;

    {
      auto intPtr = boost::make_shared<int>(123);
      BINLOG_INFO("Boost Shared pointer: {0}", intPtr);

      weakIntPtr = intPtr;
      BINLOG_INFO("Boost Weak pointer: {0}", weakIntPtr);
    }

    BINLOG_INFO("Empty Boost Weak pointer: {0}", weakIntPtr);

    boost::scoped_ptr<int> scopedPtr(new int(123));
    BINLOG_INFO("Boost scoped pointer: {0}", scopedPtr);
  }

  // Test boost optional
  {
    boost::optional<int> optInt;
    BINLOG_INFO("Empty boost optional: {0}", optInt);

    optInt.emplace(123);

    BINLOG_INFO("Boost optional: {0}", optInt);
  }

  // Test boost variant
  {
    boost::variant<int, std::string> intOrString(123);
    BINLOG_INFO("Int from boost variant: {0}", intOrString);

    intOrString = std::string("Maybe foobar");
    BINLOG_INFO("String from boost variant: {0}", intOrString);
  }

  // Test boost filesystem
  {
    boost::filesystem::path p("to/the/other/side");
    BINLOG_INFO("Look for the path leading {0}", p);
  }

  return 0;
}
Attention:  ./test/integration/BasicWriter.C
/*
* The goal of this test writer to produces all the possible
* special entry tags
*/

#define BINLOG_USER_RELEASE "inttest"

#include <binlog/Binlog.H>
#include <binlog/Configuration.H>

BINLOG_INIT

struct Person { int eyeCount; };

BINLOG_MAKE_LOGGABLE(Person, eyeCount);

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  // elfReg is sent with the preamble
  // tscSync is sent with the preamble
  // hostProp is sent with the preamble

  // threadProp is sent with the event:
  BINLOG_INFO("Send thread prop");

  BINLOG_INFO("Behold the beholder: {0}", Person{1});

  // Send all the stuff in one batch
  binlog::openLogFile(logfile);

  return 0;
}
Attention:  ./test/integration/DataFlowTracking.C
#include <thread>

#include <binlog/Binlog.H>

BINLOG_INIT

struct Order { int id; };

Order g_order;

void produceOrder()
{
  binlog::setThreadName("producer");

  Order order = Order{g_order.id + 1};
  int port = 123;

  //[basics
  BINLOG_INFO("Order received, id: {0:order} on port {1}", order.id, port);
  //                                  ^^^^^ Flow name      ^^^^^^^^ Flow instance id
  //]

  g_order = order;
}

void consumeOrder()
{
  binlog::setThreadName("consumer");

  Order order = g_order;

  //[explicit
  BINLOG_BEGIN_FLOW("{0:order}", order.id); // Provided only for the sake of symmetry
  //]

  BINLOG_DEBUG("Order consumed");

  //[explicit
  BINLOG_END_FLOW("{0:order}", order.id);
  //]

  BINLOG_INFO("Some statistics, not part of the regular data flow");
}

void executeOrder()
{
  std::thread t1(produceOrder);
  t1.join();
  std::thread t2(consumeOrder);
  t2.join();
}

void executeAdmin()
{
  BINLOG_INFO("Admin request received, id: {0:admin}", 1);
  BINLOG_DEBUG("Command: {0}", "help");
}

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";
  binlog::openLogFile(logfile);

  g_order.id = 65;

  std::thread t1(executeOrder);
  std::thread t2(executeAdmin);

  t1.join();
  t2.join();

  std::thread t3(executeOrder);
  t3.join();

  return 0;
}
Attention:  ./test/integration/LoggingPods.C
#define __STDC_LIMIT_MACROS

#include <string>
#include <cstdint>

#include <binlog/Binlog.H>

BINLOG_INIT

#define LOG_TYPE(type, value) do { type v(value); BINLOG_INFO(#type ": {0}", v); } while (false)

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::openLogFile(logfile);

  LOG_TYPE(bool, true);
  LOG_TYPE(bool, false);

  LOG_TYPE(char, 'A');
  LOG_TYPE(short, 123);
  LOG_TYPE(int, 123);
  LOG_TYPE(long, 123);
  LOG_TYPE(long long, 123);
  LOG_TYPE(float, 123.456f);
  LOG_TYPE(double, 123.456);
  LOG_TYPE(unsigned, 123);
  LOG_TYPE(std::size_t, 123);
  LOG_TYPE(const char*, "123");
  LOG_TYPE(std::string, "123");

  LOG_TYPE(const char, 'A');
  LOG_TYPE(const short, 123);
  LOG_TYPE(const int, 123);
  LOG_TYPE(const long, 123);
  LOG_TYPE(const long long, 123);
  LOG_TYPE(const float, 123.456f);
  LOG_TYPE(const double, 123.456);
  LOG_TYPE(const unsigned, 123);
  LOG_TYPE(const std::size_t, 123);
  LOG_TYPE(const char* const, "123");
  LOG_TYPE(const std::string, "123");

  LOG_TYPE(volatile char, 'A');
  LOG_TYPE(volatile short, 123);
  LOG_TYPE(volatile int, 123);
  LOG_TYPE(volatile long, 123);
  LOG_TYPE(volatile long long, 123);
  LOG_TYPE(volatile float, 123.456f);
  LOG_TYPE(volatile double, 123.456);
  LOG_TYPE(volatile unsigned, 123);
  LOG_TYPE(volatile std::size_t, 123);
  LOG_TYPE(volatile const char*, "123");
  LOG_TYPE(volatile std::string, "123");

  LOG_TYPE(volatile const char, 'A');
  LOG_TYPE(volatile const short, 123);
  LOG_TYPE(volatile const int, 123);
  LOG_TYPE(volatile const long, 123);
 LOG_TYPE(volatile const long long, 123);
  LOG_TYPE(volatile const float, 123.456f);
  LOG_TYPE(volatile const double, 123.456);
  LOG_TYPE(volatile const unsigned, 123);
  LOG_TYPE(volatile const std::size_t, 123);
  LOG_TYPE(volatile const char* const, "123");
  LOG_TYPE(volatile const std::string, "123");

  // cstdint types
  LOG_TYPE(int8_t, INT8_MIN);
  LOG_TYPE(int16_t, INT16_MIN);
  LOG_TYPE(int32_t, INT32_MIN);
  LOG_TYPE(int64_t, INT64_MIN);

  LOG_TYPE(int_fast8_t, INT_FAST8_MIN);
  LOG_TYPE(int_fast16_t, INT_FAST16_MIN);
  LOG_TYPE(int_fast32_t, INT_FAST32_MIN);
  LOG_TYPE(int_fast64_t, INT_FAST64_MIN);

  LOG_TYPE(int_least8_t, INT_LEAST8_MIN);
  LOG_TYPE(int_least16_t, INT_LEAST16_MIN);
  LOG_TYPE(int_least32_t, INT_LEAST32_MIN);
  LOG_TYPE(int_least64_t, INT_LEAST64_MIN);

  LOG_TYPE(intmax_t, INTMAX_MIN);
  LOG_TYPE(intptr_t, INTPTR_MIN);

  LOG_TYPE(uint8_t, UINT8_MAX);
  LOG_TYPE(uint16_t, UINT16_MAX);
  LOG_TYPE(uint32_t, UINT32_MAX);
  LOG_TYPE(uint64_t, UINT64_MAX);

  LOG_TYPE(uint_fast8_t, UINT_FAST8_MAX);
  LOG_TYPE(uint_fast16_t, UINT_FAST16_MAX);
  LOG_TYPE(uint_fast32_t, UINT_FAST32_MAX);
  LOG_TYPE(uint_fast64_t, UINT_FAST64_MAX);

  LOG_TYPE(uint_least8_t, UINT_LEAST8_MAX);
  LOG_TYPE(uint_least16_t, UINT_LEAST16_MAX);
  LOG_TYPE(uint_least32_t, UINT_LEAST32_MAX);
  LOG_TYPE(uint_least64_t, UINT_LEAST64_MAX);

  LOG_TYPE(uintmax_t, UINTMAX_MAX);
  LOG_TYPE(uintptr_t, UINTPTR_MAX);

  LOG_TYPE(char16_t, 123);
  LOG_TYPE(char32_t, 123);
  LOG_TYPE(wchar_t, 123);

  return 0;
}
Attention:  ./test/integration/ReaderAPI.C
#include <iostream>

#include <binlog/reader/FileInputStream.H>
#include <binlog/reader/EntryStream.H>
#include <binlog/reader/EventStream.H>
#include <binlog/reader/SortedEventStream.H>

using binlog::reader::FileInputStream;
using binlog::reader::EntryStream;
using binlog::reader::EventStream;
using binlog::reader::SortedEventStream;
using binlog::reader::entry::Event;

void processEvent(Event& event)
{
  std::cout << event.message() << std::endl;
}

int main(int argc, const char* argv[])
{
  if (argc < 2)
  {
    std::cerr << "Usage: " << argv[0] << " logfile.log\n";
    return 0;
  }

  const std::string path_to_logfile = argv[1];

  //[basics
  FileInputStream logfile(path_to_logfile, false);
  EntryStream entries(logfile);
  EventStream events(entries);
  SortedEventStream sortedEvents(events);

  sortedEvents.consume([&](Event& event)
  {
    processEvent(event);
  });
  //]
}
Attention:  ./test/integration/GetterWithLogging.C
#include <string>

#include <binlog/Binlog.H>
#include <binlog/sink/MultiConsumer.H>

BINLOG_INIT

struct Verbose
{
  std::string field() const
  {
    std::string f = "foo";
    BINLOG_INFO("Getting field: {0}", "bar");
    return f;
  }
};

BINLOG_MAKE_LOGGABLE(Verbose, field);

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  auto&& mc = binlog::sink::MultiConsumer::getInstance();
  mc.addFileSink(logfile);

  BINLOG_INFO("Logging works");
  // Outputs: Logging works

  mc.consume();

  Verbose v;
  BINLOG_WARNING("Grok this: {0}", v);
  // this produces a corrupt buffer, because the getter logs,
  // but the corrupt buffer shall be dropped

  mc.consume();

  BINLOG_INFO("Logging still works");
  // Outputs: Logging still works

  mc.consume();

  return 0;
}
Attention:  ./test/integration/modules/BadExec.C
#include <unistd.h> // execvp
#include <cstring> // strerror
#include <iostream>

int main(int argc, char* argv[])
{
  if (argc < 2)
  {
    std::cerr << "Usage: this_program program_to_run [args...]\n";
    return 1;
  }

  // Intentionally exec program unconventionally:
  // Do not pass program name in argv[0].
  // This makes its life a bit harder.

  char* program = argv[1];
  char trap[] = "garbage";
  argv[1] = &trap[0];

  execvp(program, argv + 1);

  std::cerr << "execvp failed: " << strerror(errno) << "\n";
  return 2;
}
Attention:  ./test/integration/modules/Application.C
#include <dlfcn.h> // dlopen, dlsym

#define BINLOG_USER_META "m"
#define BINLOG_USER_PROJECT "p"
#define BINLOG_USER_RELEASE "app"

#include <binlog/Binlog.H>

BINLOG_INIT

void shared_hook(); // defined in Shared.C
void static_hook(); // defined in Static.C

#include "HeaderLog.H"   // from Log.H
#include "HeaderLog.HPP" // from Log.C
#include "Header.H"

void call_dso(const char* path)
{
  if (!path)
  {
    BINLOG_WARNING("No dso path specified, skip it");
    return;
  }

  void* dso = dlopen(path, RTLD_LAZY);
  if (!dso)
  {
    BINLOG_ERROR("Failed to load dso: {0}", dlerror());
    return;
  }

  void* dynamic_hook_p = dlsym(dso, "dynamic_hook");
  if (!dynamic_hook_p)
  {
    BINLOG_ERROR("Failed to get hook from dso: {0}", dlerror());
    return;
  }

  void (*dynamic_hook)() = nullptr;
  std::memcpy(&dynamic_hook, &dynamic_hook_p, sizeof(dynamic_hook_p));

  dynamic_hook();

  dlclose(dso);
}

int main(int argc, const char* argv[])
{
  const char* dsoPath = (argc >= 2) ? argv[1] : nullptr;

  const char* logfile = (argc >= 3) ? argv[2] : "/tmp/binlog-integration-test.log";
  binlog::openLogFile(logfile);

  BINLOG_INFO("Application starts");
  // Outputs: m/p/app Application starts

  BINLOG_INFO("Application calls shared object");
  // Outputs: m/p/app Application calls shared object
  shared_hook();
  // Outputs: m/p/shared Shared hook called

  BINLOG_INFO("Application calls statically linked object");
  // Outputs: m/p/app Application calls statically linked object
  static_hook();
  // Outputs: m/p/app/stat Static hook called

  BINLOG_INFO("Application calls header only library");
  // Outputs: m/p/app Application calls header only library
  header_hook();
  // Outputs: m/p/header Header hook called

  BINLOG_INFO("Application dynamically loads and calls object");
  // Outputs: m/p/app Application dynamically loads and calls object
  call_dso(dsoPath);
  // Outputs: m/p/dynamic Dynamic hook called

  BINLOG_INFO("Application dynamically loads and calls object, again");
  // Outputs: m/p/app Application dynamically loads and calls object, again
  call_dso(dsoPath);
  // Outputs: m/p/dynamic Dynamic hook called

  BINLOG_INFO("Application ends");
  // Outputs: m/p/app Application ends

  return 0;
}
Attention:  ./test/integration/modules/Shared.C
#define BINLOG_USER_META "m"
#define BINLOG_USER_PROJECT "p"
#define BINLOG_USER_RELEASE "shared"

#include <binlog/Binlog.H>

BINLOG_INIT

void shared_hook()
{
  BINLOG_INFO("Shared hook called");
}
Attention:  ./test/integration/modules/Dynamic.C
#define BINLOG_USER_META "m"
#define BINLOG_USER_PROJECT "p"
#define BINLOG_USER_RELEASE "dynamic"

#include <binlog/Binlog.H>

BINLOG_INIT

extern "C" {

__attribute__((visibility("default")))
void dynamic_hook()
{
  BINLOG_INFO("Dynamic hook called");
}

}
Attention:  ./test/integration/modules/Static.C
#define BINLOG_USER_META "m"
#define BINLOG_USER_PROJECT "p"
#define BINLOG_USER_RELEASE "app"

#include <binlog/Binlog.H>

BINLOG_DEFINE_SUBCATEGORY(stat)

void static_hook()
{
  BINLOG_CATEGORIZED_INFO(stat, "Static hook called");
}
Attention:  ./test/integration/FirstGlance.C
//[FirstGlance
#include <binlog/Binlog.H>

BINLOG_INIT

int main()
{
  binlog::openLogFile("/tmp/binlog.log");
  BINLOG_CRITICAL("This is the {0}st log entry", 1);
}
//]
Attention:  ./test/integration/LoggingThirdPartyStructures.C
#include <binlog/Binlog.H>

BINLOG_INIT

#include <binlog/make_loggable/BoostOptional.H>
#include <binlog/make_loggable/BoostPointers.H>
#include <binlog/make_loggable/BoostVariant.H>
#include <binlog/make_loggable/BoostFilesystem.H>

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::openLogFile(logfile);

  // Test boost smart pointers
  {
    boost::weak_ptr<int> weakIntPtr;

    {
      auto intPtr = boost::make_shared<int>(123);
      BINLOG_INFO("Boost Shared pointer: {0}", intPtr);
      // Outputs: Boost Shared pointer: 123

      weakIntPtr = intPtr;
      BINLOG_INFO("Boost Weak pointer: {0}", weakIntPtr);
      // Outputs: Boost Weak pointer: 123
    }

    BINLOG_INFO("Empty Boost Weak pointer: {0}", weakIntPtr);
    // Outputs: Empty Boost Weak pointer: {null}

    boost::scoped_ptr<int> scopedPtr(new int(123));
    BINLOG_INFO("Boost scoped pointer: {0}", scopedPtr);
    // Outputs: Boost scoped pointer: 123
  }

  // Test boost optional
  {
    boost::optional<int> optInt;
    BINLOG_INFO("Empty boost optional: {0}", optInt);
    // Outputs: Empty boost optional: {null}

    optInt.emplace(123);

    BINLOG_INFO("Boost optional: {0}", optInt);
    // Outputs: Boost optional: 123
  }

  // Test boost variant
  {
    boost::variant<int, std::string> intOrString(123);
    BINLOG_INFO("Int from boost variant: {0}", intOrString);
    // Outputs: Int from boost variant: 123

    intOrString = std::string("Maybe foobar");
    BINLOG_INFO("String from boost variant: {0}", intOrString);
    // Outputs: String from boost variant: Maybe foobar
  }

  // Test boost filesystem
  {
    boost::filesystem::path p("to/the/other/side");
    BINLOG_INFO("Look for the path leading {0}", p);
    // Outputs: Look for the path leading to/the/other/side
  }

  return 0;
}
Attention:  ./test/integration/LoggingPointers.C
#include <memory>

#include <binlog/Binlog.H>

BINLOG_INIT

void logEmptyPointers()
{
  int* p = nullptr;
  std::shared_ptr<int> shared;
  std::unique_ptr<int> unique;
  std::weak_ptr<int> weak;

  BINLOG_INFO("Pointers: {0} {1} {2} {3}", p, shared, unique, weak);
  // Outputs: Pointers: {null} {null} {null} {null}
}

void logValidPointers()
{
  //[LoggingPointers
  int* pointer = nullptr;
  std::shared_ptr<int> shared = std::make_shared<int>(123);
  std::unique_ptr<int> unique(new int(123));
  std::weak_ptr<int> weak(shared);
  BINLOG_INFO("Pointers: {0} {1} {2} {3}", pointer, shared, unique, weak);
  // Outputs: Pointers: {null} 123 123 123
  //]
}

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::openLogFile(logfile);

  logEmptyPointers();
  logValidPointers();

  return 0;
}
Attention:  ./test/integration/LoggingContainers.C
#include <vector>
#include <array>
#include <set>
#include <list>
#include <map>
#include <tuple>

#include <boost/container/vector.hpp>
#include <boost/container/set.hpp>
#include <boost/container/list.hpp>
#include <boost/container/map.hpp>
#include <boost/container/flat_map.hpp>

#include <binlog/Binlog.H>

BINLOG_INIT

void logContainers()
{
  //[containers
  std::vector<int>   vec{1, 2, 3};
  std::array<int, 3> arr{1, 2, 3};
  std::set<int>      set{1, 2, 3};
  std::list<int>    list{1, 2, 3};
  BINLOG_INFO("Containers: {0} {1} {2} {3}", vec, arr, set, list);
  // Outputs: Containers: [1, 2, 3] [1, 2, 3] [1, 2, 3] [1, 2, 3]

  std::map<int, std::string> map{{13, "foo"}, {37, "bar"}};
  BINLOG_INFO("Map: {0}", map);
  // Outputs: Map: [(13, foo), (37, bar)]
  //]
}

void logThirdpartyContainers()
{
  boost::container::vector<int>   vec{1, 2, 3};
  boost::container::set<int>      set{1, 2, 3};
  boost::container::list<int>    list{1, 2, 3};
  BINLOG_INFO("Containers: {0} {1} {2}", vec, set, list);
  // Outputs: Containers: [1, 2, 3] [1, 2, 3] [1, 2, 3]

  boost::container::map<int, std::string> map{{13, "foo"}, {37, "bar"}};
  boost::container::map<int, std::string> flat_map{{13, "foo"}, {37, "bar"}};
  BINLOG_INFO("Maps: {0} {1}", map, flat_map);
 // Outputs: Maps: [(13, foo), (37, bar)] [(13, foo), (37, bar)]
}

void logSums()
{
  //[sums
  auto pair  = std::make_pair (257, "foobar");
  auto tuple = std::make_tuple(257, "foobar", 1.5f);
  BINLOG_INFO("pair: {0}, tuple: {1}", pair, tuple);
  // Outputs: pair: (257, foobar), tuple: (257, foobar, 1.5)
  //]
}

void logArray()
{
  //[array
  int iarray[] = {1, 2, 3};
  BINLOG_INFO("Let's see an array: {0}", binlog::array(iarray, 3));
  //]
  // Outputs: Let's see an array: [1, 2, 3]
}

void transformAndLog()
{
  //[transform
  std::vector<int> data{1, 2, 3};

  auto plus_one = [](const int& i) { return i + 1; };
  BINLOG_INFO("Incremented data: {0}", binlog::transform(data, plus_one));
  // Outputs: Incremented data: [2, 3, 4]
  (void)plus_one; // avoid -Wunused-variable if INFO is disabled compile time
  //]

  BINLOG_INFO("Incremented data: {0}", binlog::transform(123, plus_one));
  // Outputs: Incremented data: 124
}

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::openLogFile(logfile);

  logContainers();
  logThirdpartyContainers();
  logSums();
  logArray();
  transformAndLog();

  return 0;
}
Attention:  ./test/integration/FunctionNames.C
#include <binlog/Binlog.H>

BINLOG_INIT

void fa()
{
  BINLOG_INFO("fa");
}

static void fb()
{
  BINLOG_INFO("fb");
}

struct Class
{
  void a() const
  {
    BINLOG_INFO("a");
  }

  void b() volatile
  {
    BINLOG_INFO("b");
  }

  void c() const volatile
  {
    BINLOG_INFO("c");
  }

  void d() const&
  {
    BINLOG_INFO("d");
  }

  void e() volatile&
  {
    BINLOG_INFO("e");
  }

  void f() const volatile&
  {
    BINLOG_INFO("f");
  }

  void g() const&&
  {
    BINLOG_INFO("g");
  }

  void h() volatile&&
  {
    BINLOG_INFO("h");
  }

  void i() const volatile&&
  {
    BINLOG_INFO("i");
  }

  void j()
  {
    auto callable = [](){ BINLOG_INFO("j"); };
    callable();
  }

  void k()
  {
    auto callable = []() mutable { BINLOG_INFO("k"); };
    callable();
  }
};

namespace wrap {

struct Wrapper
{
  struct Inner
  {
    void wa() { BINLOG_INFO("wa"); }
  };

  template <typename>
  struct InnerT
  {
    template <typename>
    void wb() { BINLOG_INFO("wb"); }
  };
};

} // namespace wrap

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";
  binlog::openLogFile(logfile);

  fa();
  // Outputs: fa
  fb();
  // Outputs: fb

  Class c;
  c.a();
  // Outputs: Class::a
  c.b();
  // Outputs: Class::b
  c.c();
  // Outputs: Class::c
  c.d();
  // Outputs: Class::d
  c.e();
  // Outputs: Class::e
  c.f();
  // Outputs: Class::f
  std::move(c).g();
  // Outputs: Class::g
  std::move(c).h();
  // Outputs: Class::h
  std::move(c).i();
  // Outputs: Class::i
  c.j();
  // Outputs: Class::j
  c.k();
  // Outputs: Class::k

  wrap::Wrapper::Inner wwa;
  wwa.wa();
  // Outputs: Inner::wa

  wrap::Wrapper::InnerT<int> wwb;
  wwb.wb<long>();
  // Outputs: InnerT::wb

  return 0;
}
Attention:  ./test/integration/AlwaysLog.C
#include <binlog/Binlog.H>
#include <binlog/Configuration.H>

BINLOG_INIT

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::openLogFile(logfile);

  // disable all severities
  binlog::setCategoryConfigs({{"*", {binlog::none}}});

  // disable all event sources
  binlog::getConfiguration().toggleSource("", 0, false);

  BINLOG_CRITICAL("This should appear only if BINLOG_ALWAYS_LOG is #defined");
  // Outputs: This should appear only if BINLOG_ALWAYS_LOG is #defined

  return 0;
}
Attention:  ./test/integration/UseTheSource.C
/**
* The compiled program must have exactly this much event sources, no more.
* The produced logfile should contain precisely one event source definition for each source here.
*/

#include <binlog/Binlog.H>

BINLOG_INIT

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";
  binlog::openLogFile(logfile);

  BINLOG_INFO("SCOOPING THE LOOP SNOOPER");
  BINLOG_INFO("A proof that the Halting Problem is undecidable");
  BINLOG_INFO("Geoffrey K. Pullum");

  BINLOG_INFO("No general procedure for bug checks will do.");
  BINLOG_INFO("Now, I won't just assert that, I'll prove it to you.");
  BINLOG_INFO("I will prove that although you might work till you drop,");
  BINLOG_INFO("you cannot tell if computation will stop.");

  BINLOG_INFO("For imagine we have a procedure called P");
  BINLOG_INFO("that for specified input permits you to see");
  BINLOG_INFO("whether specified source code, with all of its faults,");
  BINLOG_INFO("defines a routine that eventually halts.");

  BINLOG_INFO("You feed in your program, with suitable data,");
  BINLOG_INFO("and P gets to work, and a little while later");
  BINLOG_INFO("(in finite compute time) correctly infers");
  BINLOG_INFO("whether infinite looping behavior occurs.");

  BINLOG_INFO("If there will be no looping, then P prints out 'Good.'");
  BINLOG_INFO("That means work on this input will halt, as it should.");
  BINLOG_INFO("But if it detects an unstoppable loop,");
 BINLOG_INFO("then P reports 'Bad!' -- which means you're in the soup.");

  BINLOG_INFO("Well, the truth is that P cannot possibly be,");
  BINLOG_INFO("because if you wrote it and gave it to me,");
  BINLOG_INFO("I could use it to set up a logical bind");
  BINLOG_INFO("that would shatter your reason and scramble your mind.");

  BINLOG_INFO("Here's the trick that I'll use -- and it's simple to do.");
  BINLOG_INFO("I'll define a procedure, which I will call Q,");
  BINLOG_INFO("that will use P's predictions of halting success");
  BINLOG_INFO("to stir up a terrible logical mess.");

  BINLOG_INFO("For a specified program, say A, one supplies,");
  BINLOG_INFO("the first step of this program called Q I devise");
  BINLOG_INFO("is to find out from P what's the right thing to say");
  BINLOG_INFO("of the looping behavior of A run on A.");

  BINLOG_INFO("If P's answer is 'Bad!', Q will suddenly stop.");
  BINLOG_INFO("But otherwise, Q will go back to the top,");
  BINLOG_INFO("and start off again, looping endlessly back,");
  BINLOG_INFO("till the universe dies and turns frozen and black.");

  BINLOG_INFO("And this program called Q wouldn't stay on the shelf;");
  BINLOG_INFO("I would ask it to forecast its run on itself.");
  BINLOG_INFO("When it reads its own source code, just what will it do?");
  BINLOG_INFO("What's the looping behavior of Q run on Q?");

  BINLOG_INFO("If P warns of infinite loops, Q will quit;");
  BINLOG_INFO("yet P is supposed to speak truly of it!");
  BINLOG_INFO("And if Q's going to quit, then P should say 'Good.'");
  BINLOG_INFO("Which makes Q start to loop! (P denied that it would.)");

  BINLOG_INFO("No matter how P might perform, Q will scoop it:");
  BINLOG_INFO("Q uses P's output to make P look stupid.");
  BINLOG_INFO("Whatever P says, it cannot predict Q:");
  BINLOG_INFO("P is right when it's wrong, and is false when it's true!");

  BINLOG_INFO("I've created a paradox, neat as can be --");
  BINLOG_INFO("and simply by using your putative P.");
  BINLOG_INFO("When you posited P you stepped into a snare;");
  BINLOG_INFO("Your assumption has led you right into my lair.");

  BINLOG_INFO("So where can this argument possibly go?");
  BINLOG_INFO("I don't have to tell you; I'm sure you must know.");
  BINLOG_INFO("A reductio: There cannot possibly be");
  BINLOG_INFO("a procedure that acts like the mythical P.");

  BINLOG_INFO("You can never find general mechanical means");
  BINLOG_INFO("for predicting the acts of computing machines;");
  BINLOG_INFO("it's something that cannot be done. So we users");
  BINLOG_INFO("must find our own bugs. Our computers are losers!");

  // http://www.lel.ed.ac.uk/~gpullum/loopsnoop.html
  return 0;
}
Attention:  ./test/integration/SinksDoc.C
#include <iostream>

#include <binlog/Binlog.H>

#include <binlog/sink/MultiConsumer.H>
#include <binlog/sink/PlaintextSink.H>

BINLOG_INIT

using PlaintextSink = binlog::sink::PlaintextSink;

void processEvent(const PlaintextSink::Event&) {}

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  //[file_sink
  auto&& multiConsumer = binlog::sink::MultiConsumer::getInstance();

  auto& fileSink = multiConsumer.addFileSink(logfile); // throws on failure

  fileSink.rotateBySize(1 << 30); // rotate on every 1 GB
  fileSink.rotateByTime(std::chrono::hours(24)); // rotate every day
  fileSink.compression(true); // compress rotated logfiles
  //]

  //[stream_sink
  multiConsumer.addStreamSink(
    std::cout, "%S %C [%d] %t %N %m",
    multiConsumer.threshold(binlog::critical)
  );
  //]

  //[plaintext_sink
  multiConsumer.addSink<PlaintextSink>(
    [](PlaintextSink::Event& event) { processEvent(event); }
  );
  //]

  //[syslog_sink
  multiConsumer.addSyslogSink();
  //]

  BINLOG_DEBUG("Debug");
  // Outputs: Debug
  BINLOG_INFO("Info");
  // Outputs: Info
  BINLOG_WARNING("Warning");
  // Outputs: Warning
  BINLOG_ERROR("Error");
  // Outputs: Error
  BINLOG_CRITICAL("Critical");
  // Outputs: Critical

  multiConsumer.consume();

  return 0;
}
Attention:  ./test/integration/WrongWriter.C
/**
* This file is used to check Logchecker output.
*/

#define BINLOG_USER_RELEASE "inttest_wrongwriter"
#include <binlog/Binlog.H>

BINLOG_INIT

int getInt(const char*) { return 0; }

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-wrong-writer.log";

  binlog::openLogFile(logfile);

  /**
   * Correct usage
   */
  BINLOG_CRITICAL("Assume a number {0}", 1);
  BINLOG_CRITICAL("Assume a string {0}", "foobar");

  /**
   * Unused arguments
   */
  BINLOG_CRITICAL("Assume only one argument {0}"
  , 1
  , "but get an additional string also, and a function call:"
  , getInt("foobar \" ((,((")
  );

  /**
   * Invalid argument specifiers
   */
  BINLOG_CRITICAL("Assume several arguments {0} {1} {2} {3} and {4}", 1, 123);

  /**
   * Tricky format string
   */
  #define FORMAT_STRING "[log message]: "
  #define MSLOG_CRIT BINLOG_CRITICAL

  if (true) { MSLOG_CRIT(
    FORMAT_STRING
    "Format string first part"
    " Second part, and an invalid arg {0}"
    " to trigger diagnostics"
  ); }

  #define WRONG_LOGGER(...) \
    BINLOG_CRITICAL(__VA_ARGS__)

  WRONG_LOGGER("Foobar {0} {1} {0}", "abcdef");

  BINLOG_CRITICAL(
    "Format string first part"
    " Second part, and no arg"
    " to trigger diagnostics"
  , 123.0f
  );

  /**
   * Correct usage
   */
  BINLOG_CRITICAL("Assume a number {0} and the same again {0}", 1);
  BINLOG_CRITICAL("Assume a string {1} and an other arg {0}", "foobar", "barbaz");

  /*
   * Incorrect usage, argument is too long
   */
  const std::size_t bufSize = (1 << 21) + 128;
  std::unique_ptr<char[]> bufPtr(new char[bufSize]);
  std::fill(bufPtr.get(), bufPtr.get() + bufSize, 0);
  BINLOG_WARNING("Too large buffer: {0}", binlog::array(bufPtr.get(), bufSize));

  /*
   * Incorrect usage, flow markers must have exactly one named placeholder
   */
  BINLOG_BEGIN_FLOW("{0:flow}, {1:flow2}", 1, 2);
  BINLOG_END_FLOW("{0:flow}, {1:flow2}", 1, 2);

  BINLOG_BEGIN_FLOW("not named: {0}", 1);
  BINLOG_END_FLOW("not named: {0}", 1);

  return 0;
}
Attention:  ./test/integration/Crasher.C
#include <iostream>
#include <thread>
#include <array>

#include <binlog/Binlog.H>
#include <binlog/Configuration.H>

BINLOG_INIT

#include <binlog/sink/Consumer.H>
#include <binlog/sink/FileSink.H>

constexpr unsigned ItemSize = 32;
constexpr unsigned QueueSize = ItemSize * 8;
using Item = std::array<char, ItemSize>;

void atRingBoundary(const char* logfile)
{
  binlog::setThreadName("t1");

  Item item;
  item.fill('a');
  BINLOG_INFO("In the logs:   {0}", item);

  item[1] = 'b';
  BINLOG_INFO("Still there:   {0}", item);

  binlog::sink::Consumer<binlog::sink::FileSink> consumer(logfile);

  // Put the preamble in the logfile.
  // This makes crash recovery harder.
  // Also consume the beginning of the current queue.
  consumer.consume();

  for (unsigned i = 0; i < 7; ++i)
  {
    item[i+2] = char('c' + i);
    BINLOG_INFO("From the core: {0}", item);
  }
}

void moreBuffersPerThread()
{
  binlog::setThreadName("t2");

  Item item;
  item.fill('A');

  for (unsigned i = 0; i < 12; ++i)
  {
    item[i+1] = char('B' + i);
    BINLOG_INFO("From the core: {0}", item);
  }
}

int main(int argc, const char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-inttest-crash.log";

  binlog::setThreadName("main");

  BINLOG_INFO("This reaches the log file");

  binlog::getConfiguration().setAdaptiveSeverityCeiling(binlog::trace);
  binlog::getConfiguration().setMinQueueSize(QueueSize);

  // Make sure the recovery drains all buffers
  std::thread t1(atRingBoundary, logfile);
  t1.join();

  std::thread t2(moreBuffersPerThread);
  t2.join();

  BINLOG_INFO("One last more and crash");

  std::cout << "Core intentionally..." << std::endl;
  std::abort();
}
Attention:  ./test/integration/IntegrationTest.C
#include <map>
#include <string>
#include <fstream>
#include <sstream>
#include <stdexcept>
#include <cstring>  // strerror
#include <cstdlib>  // system
#include <thread>

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>

#include <boost/algorithm/string/trim.hpp>
#include <boost/program_options.hpp>
#include <boost/filesystem.hpp>
#include <boost/utility/string_ref.hpp>
#include <boost/preprocessor/stringize.hpp>
#include <boost/circular_buffer.hpp>

namespace fs = boost::filesystem;

class Executable
{
public:
  Executable() = default;

  Executable(const fs::path& path) : _path(path) {}

  int run() const
  {
    std::ostringstream command;

    command << _path;
    command << _positionals;

    for (auto&& sw : _switches)
    {
      command << " " << sw.first << sw.second;
    }

    if (! _stdin.empty())
    {
      command << " < " << _stdin;
      BOOST_TEST_INFO("STDIN : " << _stdin);
    }

    if (! _stderr.empty())
    {
      command << " 2> " << _stderr;
      BOOST_TEST_INFO("STDERR: " << _stderr);
    }

    if (! _pipe.empty())
    {
      command << " | " << _pipe;
      BOOST_TEST_INFO("PIPE: " << _pipe);
    }

    if (! _stdout.empty())
    {
      command << " > " << _stdout;
      BOOST_TEST_INFO("STDOUT: " << _stdout);
    }

    BOOST_TEST_INFO("Command: " << command.str());

    return system(command.str().c_str());
  }

  void checkedRun() const
  {
    const bool runOk = run() == 0;
    BOOST_TEST_REQUIRE(runOk);
  }

  void addSwitch(const std::string& key)
  {
    addSwitch(key, {});
  }

  void addSwitch(const std::string& key, const std::string& value)
  {
    //_switches[key] = " '" + value + "' ";
    const std::string quotedValue = (value.empty()) ? "" : " '" + value + "' ";
    for (auto&& sw : _switches)
    {
      if (sw.first == key) { sw.second = quotedValue; return; }
    }
    _switches.emplace_back(key, quotedValue);
  }

  void removeSwitch(const std::string& key)
  {
    _switches.erase(std::remove_if(
      _switches.begin(), _switches.end(),
      [&](const std::pair<std::string, std::string>& s)
      {
        return s.first == key;
      }), _switches.end()
    );
  }

  void addPositional(const std::string& value)
  {
    _positionals += " " + value;
  }

  void setStdin (const fs::path in ) { _stdin  = in ; }
  void setStdout(const fs::path out) { _stdout = out; }
  void setStderr(const fs::path err) { _stderr = err; }
  void setPipe(const std::string& pipe) { _pipe = pipe; }

private:
  fs::path _path;
  std::vector<std::pair<std::string, std::string>> _switches;
  std::string _positionals;
  fs::path _stdin;
  fs::path _stdout;
  fs::path _stderr;
  std::string _pipe;
};

class Command
{
public:
  Command() = default;

  Command& operator<<(const std::string& str) { _cmd << ' ' << str; return *this; }
  Command& operator<<(const char* str) { _cmd << ' ' << str; return *this; }
  Command& operator<<(const fs::path& path) { _cmd << ' ' << path; return *this; }

  int run() const
  {
    BOOST_TEST_INFO("Command: " << _cmd.str());
    return system(_cmd.str().c_str());
  }

  void checkedRun() const { BOOST_TEST_REQUIRE(run() == 0); }

private:
  std::ostringstream _cmd;
};

class DataProvider
{
public:
  DataProvider() = default;

  DataProvider(
    const std::vector<fs::path>& dataDirs,
    const std::vector<fs::path>& srcDirs,
    const fs::path& tmpDir
  )
    :_dataDirs(dataDirs),
     _srcDirs(srcDirs),
     _tmpDir(tmpDir)
  {}

  fs::path operator()(const std::string& name, const std::string& ext) const
  {
    for (auto&& dir : _dataDirs)
    {
      const fs::path dataPath = dir / (name + ext);
      std::ifstream dataFound(dataPath.string());
      if (dataFound) { return dataPath; }
    }

    for (auto&& dir : _srcDirs)
    {
      const fs::path srcPath = dir / (name + ".C");
      std::ifstream srcFound(srcPath.string());
      if (srcFound)
      {
        const std::string fileName = safeFileName(name);
        const fs::path dataPath = _tmpDir / (fileName + "-expected" + ext);
        grepSourceFile(srcFound, dataPath);
        return dataPath;
      }
    }

    throw std::runtime_error("No data found for: '" + name + "'");
  }

private:
  std::string safeFileName(std::string name) const
  {
    name.erase(
      std::remove_if(
        name.begin(), name.end(),
        [](char c)
        {
          return !(
             ('a' <= c && c <= 'z')
          || ('A' <= c && c <= 'Z')
          || ('0' <= c && c <= '9')
          || c == '.' || c == '_' || c == '-');
        }
      ),
      name.end()
    );
    return name;
  }

  void grepSourceFile(std::ifstream& sourceFile, const fs::path& outputPath) const
  {
    std::ofstream output(outputPath.string());
    const std::string marker("// Outputs: ");

    for (std::string line; std::getline(sourceFile, line); )
    {
      boost::algorithm::trim_left(line);
      boost::string_ref trimmedLine(line);

      if (trimmedLine.starts_with(marker))
      {
        trimmedLine.remove_prefix(marker.size());
        output << trimmedLine << "\n";
      }
    }

    if (!output)
    {
      throw std::runtime_error("Failed to write generated data file: '" + outputPath.string() + "'");
    }
  }

  std::vector<fs::path> _dataDirs;
  std::vector<fs::path> _srcDirs;
  fs::path _tmpDir;
};

class Context
{
public:
  Context() = default;

  Context(
    const std::string& platform,
    const fs::path& execDir,
    const fs::path& inttestDir,
    const fs::path& exampleDir,
    const fs::path& sourceDir,
    const fs::path& tempDir,
    const std::string& execSuffix
  )
   :_reader(execDir / ("Reader" + execSuffix)),
    _logchecker(execDir / ("Logchecker" + execSuffix)),
    _inttestDir(inttestDir),
    _exampleDir(exampleDir),
    _sourceDir(sourceDir),
    _tempDir(tempDir),
    _execSuffix(execSuffix),
    _expectedProvider(
      {
        sourceDir / "test" / "integration" / "data" / platform,
        sourceDir / "test" / "integration" / "data"
      },
      {
        sourceDir / "test" / "integration"
      },
      tempDir
    ),
    _dataProvider(
      {
        sourceDir / "test" / "integration" / "data" / platform,
        sourceDir / "test" / "integration" / "data"
      },
      {},
      tempDir
    )
  {}

  Executable  reader() const { return _reader; }
  Executable& readerRef() { return _reader; }

  Executable  logchecker() const { return _logchecker; }
  Executable& logcheckerRef() { return _logchecker; }

  fs::path tempfile(const std::string& name) const
  {
    return _tempDir / name;
  }

  fs::path expected(const std::string& name) const
  {
    return _expectedProvider(name, ".txt");
  }

  fs::path data(const std::string& name, const std::string& ext) const
  {
    return _dataProvider(name, ext);
  }

  bool cleanTemp(const fs::path& tempfile) const
  {
    if (_tempDir < tempfile)
    {
      fs::remove(tempfile);
      return true;
    }

    return false;
  }

  fs::path inttestPath(const std::string& name) const
  {
    return _inttestDir / addSuffix(name);
  }

  fs::path examplePath(const std::string& name) const
  {
    return _exampleDir / addSuffix(name);
  }

  fs::path sourceDir() const { return _sourceDir; }

private:
  fs::path addSuffix(const fs::path& path) const
  {
    fs::path suffixed = path.stem();
    suffixed += _execSuffix;
    suffixed += path.extension();
    return path.parent_path() / suffixed;
  }

  Executable _reader;
  Executable _logchecker;
  fs::path _inttestDir;
  fs::path _exampleDir;
  fs::path _sourceDir;
  fs::path _tempDir;
  std::string _execSuffix;
  DataProvider _expectedProvider;
  DataProvider _dataProvider;
};

Context g_context;

class RunReadDiff
{
public:
  RunReadDiff(const std::string& name, const Context& c = g_context)
    :_name(name),
     _context(c),
     _inttest(c.inttestPath(name)),
     _reader(c.reader())
  {}

  virtual ~RunReadDiff() = default;

  virtual void run()
  {
    runInttest();
    runReader();
    runDiff();
  }

  void cleanup()
  {
    for (const fs::path tempfile : _tempfiles)
    {
      context().cleanTemp(tempfile);
    }
  }

  Executable& inttest() { return _inttest; }
  Executable& reader() { return _reader; }

  void changeExpected(const std::string& name)
  {
    _expected = expected(name);
  }

  virtual fs::path tempfile(const std::string& name)
  {
    const fs::path file = _context.tempfile(name);
    _tempfiles.push_back(file);
    return file;
  }

protected:

  virtual void runInttest()
  {
    const fs::path logfile = inttestResultFile(_name);
    _inttest.addPositional(logfile.string());
    _inttest.checkedRun();
  }

  virtual fs::path inttestResultFile(const std::string& name)
  {
    if (_inttestOut.empty())
    {
      _inttestOut = tempfile(name + ".log");
    }
    return _inttestOut;
  }

  virtual void runReader()
  {
    const fs::path logfile = inttestResultFile(_name);
    _reader.addPositional(logfile.string());

    const fs::path outfile = readerResultFile(_name);
    _reader.setStdout(outfile);
    _reader.checkedRun();
  }

  virtual fs::path readerResultFile(const std::string& name)
  {
    if (_readerOut.empty())
    {
      _readerOut = tempfile(name + ".txt");
    }
    return _readerOut;
  }

  virtual void runDiff()
  {
    const fs::path a = expectedFile(_name);
    const fs::path b = readerResultFile(_name);

    Executable diff("diff");
    diff.addPositional("--text");
    diff.addPositional(a.string());
    diff.addPositional(b.string());
    diff.checkedRun();
  }

  virtual fs::path expectedFile(const std::string& name)
  {
    if (_expected.empty())
    {
      _expected = expected(name);
    }
    return _expected;
  }

  virtual Context& context() { return _context; }

  virtual fs::path expected(const std::string& name)
  {
    const fs::path file = _context.expected(name);
    _tempfiles.push_back(file);
    return file;
  }

  std::string _name;
  Context _context;
  Executable _inttest;
  Executable _reader;
  fs::path _inttestOut;
  fs::path _readerOut;
  fs::path _expected;

private:
  std::vector<fs::path> _tempfiles;
};

class RunDiff : private RunReadDiff
{
public:
  RunDiff(const std::string& name, const Context& c = g_context)
    :RunReadDiff(name, c)
  {
    _inttestOut = readerResultFile(name);
  }

  void run() override
  {
    runInttest();
    runDiff();
  }

  void runInttest() override
  {
    const fs::path outfile = inttestResultFile(_name);
    _inttest.setStdout(outfile);
    _inttest.checkedRun();
  }

  using RunReadDiff::inttest;
  using RunReadDiff::cleanup;
};

class ReadDiff : private RunReadDiff
{
public:
  ReadDiff(const std::string& name, const Context& c = g_context)
    :RunReadDiff(name, c)
  {
    _inttestOut = " "; // do not pass logfile to reader
  }

  void run() override
  {
    runReader();
    runDiff();
  }

  using RunReadDiff::reader;
  using RunReadDiff::changeExpected;
  using RunReadDiff::cleanup;
};

class RunFailRead : private RunReadDiff
{
public:
  RunFailRead(const std::string& name, const Context& c = g_context)
    :RunReadDiff(name, c)
  {}

  using RunReadDiff::reader;
  using RunReadDiff::cleanup;

  void run() override
  {
    runInttest();
    runReader();
  }

  void runReader() override
  {
    const fs::path logfile = inttestResultFile(_name);
    _reader.addPositional(logfile.string());

    _reader.setStdout("/dev/null");
    _reader.setStderr("/dev/null");
    BOOST_TEST_REQUIRE(_reader.run() != 0);
  }
};

void runReadDiff(const std::string& name, const Context& context = g_context)
{
  RunReadDiff runner(name, context);
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_SUITE(Logging)

BOOST_AUTO_TEST_CASE(Logging)             { runReadDiff("Logging"); }
BOOST_AUTO_TEST_CASE(LoggingPods)         { runReadDiff("LoggingPods"); }
BOOST_AUTO_TEST_CASE(LoggingPointers)     { runReadDiff("LoggingPointers"); }
BOOST_AUTO_TEST_CASE(LoggingContainers)   { runReadDiff("LoggingContainers"); }
BOOST_AUTO_TEST_CASE(LoggingEnums)        { runReadDiff("LoggingEnums"); }
BOOST_AUTO_TEST_CASE(LoggingStructures)   { runReadDiff("LoggingStructures"); }
BOOST_AUTO_TEST_CASE(LoggingThirdPartyStructures) { runReadDiff("LoggingThirdPartyStructures"); }
BOOST_AUTO_TEST_CASE(ControlFlowTracking) { runReadDiff("ControlFlowTracking"); }

BOOST_AUTO_TEST_CASE(NamedThreads)
{
  RunReadDiff runner("NamedThreads");
  runner.reader().addSwitch("--format", "%t %m");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(DataFlowTracking)
{
  const std::string name = "DataFlowTracking";

  // Test --flow
  {
    RunReadDiff runner(name);
    runner.reader().addSwitch("--flow");
    runner.reader().setStderr(runner.tempfile(name + ".err"));
    runner.reader().setPipe("sort"); // the order is implementation defined
    runner.changeExpected(name + "-flow");
    runner.run();
    runner.cleanup();
  }

  // Test --flow order
  {
    RunReadDiff runner(name);
    runner.reader().addSwitch("--flow", "order");
    runner.reader().setStderr(runner.tempfile(name + ".err"));
    runner.changeExpected(name + "-flow-order");
    runner.run();
    runner.cleanup();
  }

  // Test --flow order:66
  {
    RunReadDiff runner(name);
    runner.reader().addSwitch("--flow", "order:66");
    runner.reader().setStderr(runner.tempfile(name + ".err"));
    runner.changeExpected(name + "-flow-order-id");
    runner.run();
    runner.cleanup();
  }
}

BOOST_AUTO_TEST_CASE(Categories)
{
  RunReadDiff runner("Categories");
  runner.reader().addSwitch("--format", "%C %m");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(SinksDoc)
{
  RunReadDiff runner("SinksDoc");
  runner.inttest().setStdout("/dev/null");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(ConfigureSeverityThresholds) { runReadDiff("ConfigureSeverityThresholds"); }
BOOST_AUTO_TEST_CASE(SourceSpecificConfiguration) { runReadDiff("SourceSpecificConfiguration"); }

BOOST_AUTO_TEST_CASE(AdaptiveSeverityControl)
{
  RunReadDiff runner("AdaptiveSeverityControl");
  runner.inttest().setStderr("/dev/null");
  runner.reader().addSwitch("--format", "%F");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(ElasticQueues) { runReadDiff("ElasticQueues"); }

BOOST_AUTO_TEST_CASE(ConfigurationFileReference)
{
  const Context& c = g_context;
  const std::string name = "ConfigurationFileReference";
  RunDiff runner(name);
  runner.inttest().addPositional(c.data(name, ".json").string());
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(AlwaysLog) { runReadDiff("AlwaysLog"); }

BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE(Logchecker)

void logcheckInttest(const char* inttest)
{
  const Context& c = g_context;
  Executable logchecker = c.logchecker();
  auto toCheck = c.inttestPath(inttest);
  logchecker.addPositional(toCheck.string());
  logchecker.checkedRun();
}

BOOST_AUTO_TEST_CASE(ReaderAPI)                   { logcheckInttest("ReaderAPI"); }
BOOST_AUTO_TEST_CASE(Perftest)                    { logcheckInttest("Perftest"); }
BOOST_AUTO_TEST_CASE(Dumper)                      { logcheckInttest("Dumper"); }
BOOST_AUTO_TEST_CASE(FirstGlance)                 { logcheckInttest("FirstGlance"); }
BOOST_AUTO_TEST_CASE(Logging)                     { logcheckInttest("Logging"); }
BOOST_AUTO_TEST_CASE(LoggingPods)                 { logcheckInttest("LoggingPods"); }
BOOST_AUTO_TEST_CASE(LoggingPointers)             { logcheckInttest("LoggingPointers"); }
BOOST_AUTO_TEST_CASE(LoggingContainers)           { logcheckInttest("LoggingContainers"); }
BOOST_AUTO_TEST_CASE(LoggingEnums)                { logcheckInttest("LoggingEnums"); }
BOOST_AUTO_TEST_CASE(LoggingStructures)           { logcheckInttest("LoggingStructures"); }
BOOST_AUTO_TEST_CASE(LoggingThirdPartyStructures) { logcheckInttest("LoggingThirdPartyStructures"); }
BOOST_AUTO_TEST_CASE(ControlFlowTracking)         { logcheckInttest("ControlFlowTracking"); }
BOOST_AUTO_TEST_CASE(NamedThreads)                { logcheckInttest("NamedThreads"); }
BOOST_AUTO_TEST_CASE(DataFlowTracking)            { logcheckInttest("DataFlowTracking"); }
BOOST_AUTO_TEST_CASE(GroupMe)                     { logcheckInttest("GroupMe"); }
BOOST_AUTO_TEST_CASE(Categories)                  { logcheckInttest("Categories"); }
BOOST_AUTO_TEST_CASE(SinksDoc)                    { logcheckInttest("SinksDoc"); }
BOOST_AUTO_TEST_CASE(AdaptiveSeverityControl)     { logcheckInttest("AdaptiveSeverityControl"); }
BOOST_AUTO_TEST_CASE(ElasticQueues)               { logcheckInttest("ElasticQueues"); }
BOOST_AUTO_TEST_CASE(ConfigureSeverityThresholds) { logcheckInttest("ConfigureSeverityThresholds"); }
BOOST_AUTO_TEST_CASE(SourceSpecificConfiguration) { logcheckInttest("SourceSpecificConfiguration"); }
BOOST_AUTO_TEST_CASE(ConfigurationFileReference)  { logcheckInttest("ConfigurationFileReference"); }
BOOST_AUTO_TEST_CASE(AlwaysLog)                   { logcheckInttest("AlwaysLog"); }
BOOST_AUTO_TEST_CASE(Crasher)                     { logcheckInttest("Crasher"); }
BOOST_AUTO_TEST_CASE(Severities)                  { logcheckInttest("Severities"); }
BOOST_AUTO_TEST_CASE(LogRotation)                 { logcheckInttest("LogRotation"); }
BOOST_AUTO_TEST_CASE(SortMeOut)                   { logcheckInttest("SortMeOut"); }
BOOST_AUTO_TEST_CASE(UseTheSource)                { logcheckInttest("UseTheSource"); }
BOOST_AUTO_TEST_CASE(FlowMarkerFiltering)         { logcheckInttest("FlowMarkerFiltering"); }
BOOST_AUTO_TEST_CASE(ProducersNotifyConsumer)     { logcheckInttest("ProducersNotifyConsumer"); }
BOOST_AUTO_TEST_CASE(FunctionNames)               { logcheckInttest("FunctionNames"); }
BOOST_AUTO_TEST_CASE(GetterWithLogging)           { logcheckInttest("GetterWithLogging"); }

BOOST_AUTO_TEST_CASE(CheckIncorrectInttest)
{
  Context c = g_context;
  const fs::path wrongWriterPath = c.inttestPath("WrongWriter");
  c.logcheckerRef().setStdout("/dev/null");
  c.logcheckerRef().addPositional(wrongWriterPath.string());

  BOOST_TEST_REQUIRE((c.logcheckerRef().run() != 0));
}

void logcheckExample(const char* example)
{
  const Context& c = g_context;
  Executable logchecker = c.logchecker();
  auto toCheck = c.examplePath(example);
  logchecker.addPositional(toCheck.string());
  logchecker.checkedRun();
}

BOOST_AUTO_TEST_CASE(Basics)                { logcheckExample("01-Basics"); }
BOOST_AUTO_TEST_CASE(libexamplecalclibso)   { logcheckExample("libexample-calclib.so"); }
BOOST_AUTO_TEST_CASE(Configuration)         { logcheckExample("03-Configuration"); }
BOOST_AUTO_TEST_CASE(StructLogging)         { logcheckExample("04-StructLogging"); }
BOOST_AUTO_TEST_CASE(FlowTracking)          { logcheckExample("05-FlowTracking"); }
BOOST_AUTO_TEST_CASE(CrashRecovery)         { logcheckExample("06-CrashRecovery"); }
BOOST_AUTO_TEST_CASE(EpollConsumer)         { logcheckExample("07-EpollConsumer"); }
BOOST_AUTO_TEST_CASE(MultiConsumer)         { logcheckExample("08-MultiConsumer"); }
BOOST_AUTO_TEST_CASE(NetworkSinkClient)     { logcheckExample("10-NetworkSinkClient"); }
BOOST_AUTO_TEST_CASE(Libraries)             { logcheckExample("02-Libraries"); }
BOOST_AUTO_TEST_CASE(NetworkSinkServer)     { logcheckExample("10-NetworkSinkServer"); }
BOOST_AUTO_TEST_CASE(MultiSink)             { logcheckExample("09-MultiSink"); }
BOOST_AUTO_TEST_CASE(WatchtowerSink)        { logcheckExample("11-WatchtowerSink"); }

BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE(CrashRecovery)

#ifndef BINLOG_TOOLSET_DIR
  #define BINLOG_TOOLSET_DIR /usr
  // Required files in BINLOG_TOOLSET_DIR
  //  - bin/gdb : GDB executable
  //  - share/gdb : GDB data dir with python
#endif

BOOST_AUTO_TEST_CASE(Gdb)
{
  const Context& c = g_context;

  const fs::path crasherPath = c.inttestPath("Crasher");
  const fs::path logfilePath = c.tempfile("Crasher.log");
  Command crasher;
  crasher << "ulimit -S -c hard; {" << crasherPath << logfilePath << ";} &> /dev/null";

  // Getting the core file produced after crashing a program is not trivial,
  // especially in a host configuration agnostic way.
  // The target pattern is described by the `core_pattern` file.
  // The pattern is too complicated to fully resolve. Instead,
  // we try to get the directory, get a listing, crash the test program,
  // get a listing again, and assume, the difference will be out crash file.
  // A better solution is welcome.

  fs::path coreDir = fs::current_path();

  std::ifstream patternStream("/proc/sys/kernel/core_pattern");
  if (patternStream)
  {
    std::string pattern;
    patternStream >> pattern;
    const fs::path patternPath(pattern);
    const fs::path patternDir = patternPath.parent_path();
    if (! patternDir.empty() && is_directory(patternDir))
    {
      coreDir = patternDir;
    }
  }

  BOOST_TEST_INFO("Core file dir: " << coreDir);

  std::vector<fs::directory_entry> coreDirContents(
    fs::directory_iterator(coreDir),
    (fs::directory_iterator())
  );

  crasher.run();

  std::vector<fs::directory_entry> newCoreDirContents(
    fs::directory_iterator(coreDir),
    (fs::directory_iterator())
  );

  // {{newCoreDirContents} \ {coreDirContents}}[0]
  auto it = std::find_if(
    newCoreDirContents.begin(), newCoreDirContents.end(),
    [&](const fs::directory_entry& file)
    {
      return std::find(
        coreDirContents.begin(), coreDirContents.end(),
        file
      ) == coreDirContents.end();
    }
  );

  if (it == newCoreDirContents.end()) { BOOST_FAIL("No core file found"); }
  const fs::path corefilePath = it->path();

  const fs::path tsPath{BOOST_PP_STRINGIZE(BINLOG_TOOLSET_DIR)};

  Executable gdb(tsPath / "bin" / "gdb");
  gdb.addSwitch("--data-directory", (tsPath / "share" / "gdb").string());
  gdb.addSwitch("--batch-silent");
  gdb.addSwitch("-ex 'set python print-stack full'");
  gdb.addSwitch("-ex 'source " + (c.sourceDir() / "python" / "binlog" / "binlog.py").string() + "'");
  gdb.addSwitch("-ex 'binlog-recovery " + logfilePath.string() + "'");
  gdb.addSwitch("-n"); // do not read ~/.gdbinit
  gdb.addPositional(crasherPath.string());
  gdb.addPositional(corefilePath.string());

  RunReadDiff runner("Crasher");
  runner.inttest() = gdb;
  runner.reader().addSwitch("--format", "%t %m");
  runner.reader().addSwitch("--sort");
  runner.run();
  runner.cleanup();
  fs::remove(corefilePath);
}

BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE(Reader)

BOOST_AUTO_TEST_CASE(MinSeverity)
{
  RunReadDiff runner("Severities");
  runner.reader().addSwitch("--format", "%S %m");
  runner.reader().addSwitch("--min-severity", "info");
  runner.changeExpected("SeveritiesFromInfo");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(MaxSeverity)
{
  RunReadDiff runner("Severities");
  runner.reader().addSwitch("--format", "%S %m");
  runner.reader().addSwitch("--max-severity", "control");
  runner.changeExpected("SeveritiesToControl");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(MinMaxSeverity)
{
  RunReadDiff runner("Severities");
  runner.reader().addSwitch("--format", "%S %m");
  runner.reader().addSwitch("--min-severity", "debug");
  runner.reader().addSwitch("--max-severity", "warning");
  runner.changeExpected("SeveritiesFromDebugToWarning");
  runner.run();
  runner.cleanup();
}

  BOOST_AUTO_TEST_SUITE(Rcfile)
  // Tests in this suite are similar to the ones above
  // but switches are set from the rcfile

  BOOST_AUTO_TEST_CASE(TakeEffect)
  {
    const auto rcfile = g_context.data("rcfile-severity", ".json");
    RunReadDiff runner("Severities");
    runner.reader().addSwitch("--rcfile", rcfile.string());
    runner.reader().removeSwitch("--format");
    runner.changeExpected("SeveritiesFromDebugToWarning");
    runner.run();
    runner.cleanup();
  }

  BOOST_AUTO_TEST_CASE(OverrideByCmdLine)
  {
    const auto rcfile = g_context.data("rcfile-severity", ".json");
    RunReadDiff runner("Severities");
    runner.reader().addSwitch("--rcfile", rcfile.string());
    runner.reader().addSwitch("--min-severity", "trace");
    runner.reader().addSwitch("--max-severity", "control");
    runner.reader().removeSwitch("--format");
    runner.changeExpected("SeveritiesToControl");
    runner.run();
    runner.cleanup();
  }

  BOOST_AUTO_TEST_CASE(InvalidSyntax)
  {
    // get rcfile
    const Context& c = g_context;
    const auto rcfile = c.data("rcfile-severity", ".json");
    const auto invalidRcfile = c.tempfile("InvaidRcfile.json");
    fs::copy_file(rcfile, invalidRcfile, fs::copy_option::overwrite_if_exists);

    // make rcfile invalid
    {
      std::ofstream stream(invalidRcfile.string(), std::ios::app);
      stream << ';';
    }

    // run reader with otherwise valid input
    RunFailRead runner("Logging");
    runner.reader().addSwitch("--rcfile", invalidRcfile.string());
    runner.run();
    runner.cleanup();

    c.cleanTemp(invalidRcfile);
  }

  BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_CASE(Sort)
{
  RunReadDiff runner("SortMeOut");
  runner.reader().addSwitch("--format", "%t %m");
  runner.reader().addSwitch("--sort");
  runner.run();
  runner.cleanup();
}

// In --tail mode, the Reader doesn't exit on its own.
// To bump it, we poison the given logfile with an invalid entry,
// this makes it quit.
class TailGuard
{
public:
  TailGuard(std::thread& readerThread, const fs::path& logfile)
    :_readerThread(readerThread),
     _logfile(logfile),
     _released(false)
  {}

  void release()
  {
    {
      char poison[64] = {0};
      std::ofstream out(_logfile.string(), std::ios::app);
      out.write(poison, sizeof(poison));
    }

    if (_readerThread.joinable())
    {
      _readerThread.join();
    }

    _released = true;
  }

  ~TailGuard()
  {
    if (! _released) { release(); }
  }

private:
  std::thread& _readerThread;
  const fs::path _logfile;
  bool _released;
};

template <typename Callable>
bool backoffUntil(Callable condition)
{
  std::array<int, 3> durations = {1, 2, 4};

  for (int duration : durations)
  {
    if (condition()) { return true; }
    std::this_thread::sleep_for(std::chrono::seconds{duration});
  }

  return condition();
}

// Treat non-existent files as zero sized
std::size_t optFileSize(const fs::path& file)
{
  boost::system::error_code ec;
  const std::size_t size = fs::file_size(file, ec);
  return (!ec) ? size : 0;
}

BOOST_AUTO_TEST_CASE(Tail)
{
  // When the --tail switch is active, the Reader does not
  // quit at EOF, but waits for additional data/new file,
  // even if the file is not yet there

  Context c = g_context;

  const auto logfile = c.tempfile("Tail.log");
  const auto textfile = c.tempfile("Tail.txt");
  const auto expected = c.expected("Logging");
  const std::size_t expectedSize = fs::file_size(expected);
  boost::system::error_code ec;
  const auto dont_truncate = std::ios::in; // otherwise ofstream truncates
  auto rotatedLogfile = logfile;
  rotatedLogfile += ".0";

  // Avoid the Reader picking up an old file
  fs::remove(logfile, ec);

  std::thread reader([&]()
  {
    Executable r = c.reader();
    r.addSwitch("--tail");
    r.addPositional(logfile.string());
    r.setStdout(textfile);
    r.setStderr("/dev/null");
    r.run(); // blocks
  });

  TailGuard guard(reader, logfile);

  Executable logger = c.inttestPath("Logging");
  logger.addPositional(logfile.string());
  logger.checkedRun();

  // let it schedule the Reader
  backoffUntil([&](){ return optFileSize(textfile) >= expectedSize; });

  // simulate application writing the same file:
  // double the contents minus the #! line
  {
    std::stringstream content;

    {
      std::ifstream in(logfile.string());
      std::string shebang;
      std::getline(in, shebang);
      content << in.rdbuf();
    }

    std::ofstream out(logfile.string(), std::ios::ate | dont_truncate);
    out << content.rdbuf();
  }

  backoffUntil([&](){ return optFileSize(textfile) >= 2 * expectedSize; });

  // this will rotate the file
  logger.checkedRun();

  backoffUntil([&](){ return optFileSize(textfile) >= 3 * expectedSize; });

  guard.release();

  // the expected result is the original expected three times
  auto texpected = c.tempfile("Tail-expected.txt");

  {
    std::ifstream in(expected.string());
    std::ofstream out(texpected.string());
    out << in.rdbuf();
    in.seekg(0);
    out << in.rdbuf();
    in.seekg(0);
    out << in.rdbuf();
  }

  Executable diff("diff");
  diff.addPositional("--text");
  diff.addPositional(texpected.string());
  diff.addPositional(textfile.string());
  diff.checkedRun();

  c.cleanTemp(textfile);
  c.cleanTemp(expected);
  c.cleanTemp(logfile);
  c.cleanTemp(rotatedLogfile);
  c.cleanTemp(texpected);
}

BOOST_AUTO_TEST_CASE(Tail2)
{
  // When the --tail switch is active, the Reader displays the last `n`
  // events of the given logfile.

  Context c = g_context;

  const auto logfile = c.tempfile("Tail2.log");
  const auto textfile = c.tempfile("Tail2.txt");
  const auto expected = c.expected("Logging");

  // produce the logfile
  Executable logger = c.inttestPath("Logging");
  logger.addPositional(logfile.string());
  logger.checkedRun();

  // poison the end of the logfile
  std::thread unused;
  TailGuard guard(unused, logfile);
  guard.release();

  // run the reader with --tail
  Executable r = c.reader();
  r.addSwitch("--tail", "4");
  r.addPositional(logfile.string());
  r.setStdout(textfile);
  r.setStderr("/dev/null");
  r.run();

  // produce expected file, last `n` lines of the original expected
  auto texpected = c.tempfile("Tail2-expected.txt");

  {
    boost::circular_buffer<std::string> buf(4);
    std::string line;
    std::ifstream in(expected.string());
    while (std::getline(in, line))
    {
      buf.push_back(line);
    }

    std::ofstream out(texpected.string());
    for (auto&& l : buf)
    {
      out << l << "\n";
    }
  }

  Executable diff("diff");
  diff.addPositional("--text");
  diff.addPositional(texpected.string());
  diff.addPositional(textfile.string());
  diff.checkedRun();

  c.cleanTemp(logfile);
  c.cleanTemp(textfile);
  c.cleanTemp(expected);
  c.cleanTemp(texpected);
}

BOOST_AUTO_TEST_CASE(GroupMe)
{
  RunReadDiff runner("GroupMe");
  runner.reader().addSwitch("--groupby", "entityId");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(ReaderAPI)
{
  const Context& c = g_context;
  RunReadDiff runner("ReaderAPI");
  runner.inttest() = Executable{c.inttestPath("Logging")};
  runner.reader() = Executable{c.inttestPath("ReaderAPI")};
  runner.changeExpected("Logging");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(MultipleInput)
{
  // Reader file.log* invocation should consume
  // file.log, file.log.1.gz, file.log.0.gz and display
  // them in order of file `mtime`
  const std::string name = "LogRotation";

  RunReadDiff runner(name);

  auto f0n = name + ".log.0.gz";
 auto f1n = name + ".log.1.gz";
  auto f2n = name + ".log.2.gz";

  auto f0 = runner.tempfile(f0n);
  auto f1 = runner.tempfile(f1n);
  auto f2 = runner.tempfile(f2n);

  runner.reader().addPositional(f1.string());
  runner.reader().addPositional(f0.string());
  runner.reader().addPositional(f2.string());
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(Help)
{
  Executable reader = g_context.reader();
  reader.setStdout("/dev/null");
  reader.addSwitch("--help");
  reader.checkedRun();
}

  BOOST_AUTO_TEST_SUITE(InvalidInput)

  BOOST_AUTO_TEST_CASE(InvalidMinSeverity)
  {
    RunFailRead runner("Severities");
    runner.reader().addSwitch("--min-severity", "foo");
    runner.run();
    runner.cleanup();
  }

  BOOST_AUTO_TEST_CASE(InvalidMaxSeverity)
  {
    RunFailRead runner("Severities");
    runner.reader().addSwitch("--max-severity", "bar");
    runner.run();
    runner.cleanup();
  }

  BOOST_AUTO_TEST_CASE(InvalidMinMaxSeverity)
  {
    RunFailRead runner("Severities");
    runner.reader().addSwitch("--min-severity", "warning");
    runner.reader().addSwitch("--max-severity", "debug");
    runner.run();
    runner.cleanup();
  }

  BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE(Implementation)

BOOST_AUTO_TEST_CASE(StaticSourceCount)
{
  // Event sources must be defined exactly once.
  // This might go wrong if BINLOG_MESSAGE_ID is pasted more than once
  ReadDiff runner("StaticSourceCount");
  runner.reader().addPositional(g_context.inttestPath("UseTheSource").string());
  runner.reader().setPipe("wc -l");
  runner.changeExpected("SourceCount");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(LoggedSourceCount)
{
  // The Preamble should be consumed only once
  RunReadDiff runner("UseTheSource");
  runner.reader().addSwitch("--debug");
  runner.reader().addSwitch("--format", "%T");
  runner.reader().setPipe("grep -c EventSource");
  runner.changeExpected("SourceCount");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(FlowMarkerFiltering)
{
  Context c = g_context;
  c.readerRef().addSwitch("--format", "%t %m");
  c.readerRef().setPipe("sort");
  runReadDiff("FlowMarkerFiltering", c);
}

BOOST_AUTO_TEST_CASE(FunctionNames)
{
  Context c = g_context;
 c.readerRef().addSwitch("--format", "%N");
  runReadDiff("FunctionNames", c);
}

BOOST_AUTO_TEST_CASE(ProducersNotifyConsumer)
{
  Executable test{g_context.inttestPath("ProducersNotifyConsumer")};
  test.checkedRun();
}

BOOST_AUTO_TEST_CASE(GetterWithLogging)
{
  RunReadDiff runner("GetterWithLogging");
  runner.inttest().setStderr("/dev/null");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(Modules)
{
  auto dsoPath = g_context.inttestPath("libModDynamic.so").string();
  RunReadDiff runner("Modules");
  runner.inttest().addPositional(dsoPath);
  runner.reader().addSwitch("--format", "%C %m");
  runner.changeExpected("modules/Application");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(ModulesPie)
{
  auto dsoPath = g_context.inttestPath("libModDynamic.so").string();
  RunReadDiff runner("ModulesPie");
  runner.inttest().addPositional(dsoPath);
  runner.reader().addSwitch("--format", "%C %m");
  runner.changeExpected("modules/Application");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_CASE(ModulesBadExec)
{
  auto appPath = g_context.inttestPath("Modules").string();
  auto dsoPath = g_context.inttestPath("libModDynamic.so").string();
  RunReadDiff runner("BadExec");
  runner.inttest().addPositional(appPath);
  runner.inttest().addPositional(dsoPath);
  runner.reader().addSwitch("--format", "%C %m");
  runner.changeExpected("modules/Application");
  runner.run();
  runner.cleanup();
}

BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE(Examples)

void runExample(const std::string& name)
{
  Context c = g_context;

  const fs::path example_log = c.tempfile(name + ".log");
  const fs::path example_stderr = c.tempfile(name + "-err.txt");

  Executable example{c.examplePath(name)};
  example.setStdout("/dev/null");
  example.setStderr(example_stderr);
  example.addPositional(example_log.string());
  example.checkedRun();

  BOOST_TEST_INFO("STDERR: " << example_stderr.string());
  BOOST_TEST_REQUIRE(fs::file_size(example_stderr) == 0u);

  c.cleanTemp(example_log);
  c.cleanTemp(example_stderr);
}

BOOST_AUTO_TEST_CASE(Basics)        { runExample("01-Basics"); }
BOOST_AUTO_TEST_CASE(Libraries)     { runExample("02-Libraries"); }
BOOST_AUTO_TEST_CASE(Configuration) { runExample("03-Configuration"); }
BOOST_AUTO_TEST_CASE(StructLogging) { runExample("04-StructLogging"); }
BOOST_AUTO_TEST_CASE(FlowTracking)  { runExample("05-FlowTracking"); }
// BOOST_AUTO_TEST_CASE(CrashRecovery) { runExample("06-CrashRecovery"); } // Intentionally omitted
// BOOST_AUTO_TEST_CASE(EpollConsumer) { runExample("07-EpollConsumer"); } // Intentionally omitted
BOOST_AUTO_TEST_CASE(MultiConsumer) { runExample("08-MultiConsumer"); }
BOOST_AUTO_TEST_CASE(MultiSink)     { runExample("09-MultiSink"); }

BOOST_AUTO_TEST_SUITE_END()

std::string get_or(const boost::program_options::variables_map& vm,
                   const std::string& key, const std::string& def)
{
  if (vm.count(key))
  {
    // If ProgramOptions lib is compiled with RTTI and this file without
    // or vica versa, vm[key].as<std::string>() throws bad_any_cast,
    // because Boost.Any gets confused.
    return *boost::unsafe_any_cast<std::string>(& vm[key].value());
  }
  else
  {
    return def;
  }
}

Context contextFromArgs(int argc, char* argv[])
{
  namespace po = boost::program_options;

  bool flatExecDir = false;

  po::options_description opts("Context options");
  opts.add_options()
    ("platform", po::value<std::string>(), "")
    ("exec_dir", po::value<std::string>(), "")
    ("source_dir", po::value<std::string>(), "")
    ("temp_dir", po::value<std::string>(), "")
    ("flat_exec_dir", po::bool_switch(&flatExecDir), "")
    ("exec_suffix", po::value<std::string>(), "")
  ;

  po::variables_map vm;
  po::store(
    po::command_line_parser(argc, argv).options(opts).run(),
    vm
  );
  po::notify(vm);

  const std::string platform = get_or(vm, "platform", "rhel6_64");
  const std::string execDir = get_or(vm, "exec_dir", "../install/.exec/" + platform + "/bin/");
 const std::string inttestDir = (flatExecDir)
    ? execDir
    : execDir + "/test/integration/";
  const std::string exampleDir = (flatExecDir)
    ? execDir
    : execDir + "/example/";
  const std::string sourceDir = get_or(vm, "source_dir", ".");
  const std::string tempDir = get_or(vm, "temp_dir", "/tmp");
  const std::string execSuffix = get_or(vm, "exec_suffix", "");

  return Context(
    platform,
    execDir,
    inttestDir,
    exampleDir,
    sourceDir,
    tempDir,
    execSuffix
  );
}

bool init_master_test_suite()
{
  boost::unit_test::framework::master_test_suite().p_name.value = "Binlog Integration Test";

  // Boost.Test only allows custom args after the -- separator
  int argc = boost::unit_test::framework::master_test_suite().argc;
  char** argv = boost::unit_test::framework::master_test_suite().argv;

  g_context = contextFromArgs(argc, argv);
  g_context.readerRef().addSwitch("--rcfile", {});
  g_context.readerRef().addSwitch("--format", "%m");

  return true;
}

int main(int argc, char* argv[])
{
  return boost::unit_test::unit_test_main(&init_master_test_suite, argc, argv);
}
Attention:  ./test/integration/ConfigureSeverityThresholds.C
#define BINLOG_USER_META "filter"
#define BINLOG_USER_PROJECT "mtfilter"
#define BINLOG_USER_RELEASE "master"

//[compile_time
#define BINLOG_MIN_SEVERITY_INFO // TRACE and DEBUG levels will be compile time disabled

#include <binlog/Binlog.H>
//]

#define DEV_SUB_CATEGORY proc_dev
BINLOG_DEFINE_SUBCATEGORY(DEV_SUB_CATEGORY)

#define SUB_CATEGORY proc
BINLOG_DEFINE_SUBCATEGORY(SUB_CATEGORY)

BINLOG_INIT

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";
  binlog::openLogFile(logfile);

  BINLOG_TRACE("Trace 1"); // compile time disabled
  BINLOG_DEBUG("Debug 1"); // compile time disabled
  BINLOG_INFO("Info 1");
  // Outputs: Info 1
  BINLOG_WARNING("Warning 1");
  // Outputs: Warning 1
  BINLOG_ERROR("Error 1");
  // Outputs: Error 1
  BINLOG_CRITICAL("Critical 1");
  // Outputs: Critical 1

  //[set_category_configs
  binlog::setCategoryConfigs({
    {"filter/mtfilter/master/*_dev", {binlog::info}},
    {"filter/mtfilter/*",            {binlog::warning}},
    {"*",                            {binlog::none}}
  });
  //]

  BINLOG_INFO("Info 2"); // runtime disabled
  BINLOG_WARNING("Warning 2");
  // Outputs: Warning 2

  BINLOG_CATEGORIZED_INFO(SUB_CATEGORY, "Info 3"); // runtime disabled
  BINLOG_CATEGORIZED_INFO(DEV_SUB_CATEGORY, "Info 4");
  // Outputs: Info 4

  BINLOG_CATEGORIZED_WARNING(SUB_CATEGORY, "Warning 3");
  // Outputs: Warning 3

  return 0;
}
Attention:  ./test/integration/SourceSpecificConfiguration.C
#include <binlog/Binlog.H>
//[basics
#include <binlog/Configuration.H> // binlog::getConfiguration()
//]

BINLOG_INIT

unsigned sourceLine;

void action()
{
  sourceLine = __LINE__ + 1;
  BINLOG_INFO("Take action");
}

int main(int argc, char* argv[])
{
  const char* logfile = (argc >= 2) ? argv[1] : "/tmp/binlog-integration-test.log";

  binlog::openLogFile(logfile);

  action();
  // Outputs: Take action

  BINLOG_DEBUG("Action 1 taken");
  // Outputs: Action 1 taken

  const std::string fileName = "SourceSpecificConfiguration.C";

  //[basics

  auto&& config = binlog::getConfiguration();

  // Disable specified source
  config.toggleSource(fileName, sourceLine, false);
  //]

  action(); // no output

  BINLOG_DEBUG("Action 2 taken");
  // Outputs: Action 2 taken

  //[basics

  // Enable specified source
  config.toggleSource(fileName, sourceLine, true);
  //]

  action();
  // Outputs: Take action

  BINLOG_DEBUG("Action 3 taken");
  // Outputs: Action 3 taken

  // Disable every source in file
  config.toggleSource(fileName, 0, false);
  action(); // no output
  BINLOG_DEBUG("Action 4 taken"); // no output

  // Enable every source in file
  config.toggleSource(fileName, 0, true);

  action();
  // Outputs: Take action

  BINLOG_DEBUG("Action 5 taken");
  // Outputs: Action 5 taken

  // Disable some sources with a predicate
  config.toggleSource([](const binlog::reader::entry::EventSource& es)
  {
    return es.formatString() == "Take action";
  }, false);

  action(); // no output

  // Enable some sources with a predicate
  config.toggleSource([](const binlog::reader::entry::EventSource& es)
  {
    return es.formatString() == "Take action";
  }, true);

  action();
  // Outputs: Take action

  return 0;
}
Attention:  ./bin/reader/Reader.C
#include <iostream>
#include <fstream>
#include <cstring>
#include <ctime>

#include <sys/stat.h> // stat
#include <unistd.h> // getuid
#include <pwd.h>  // struct passwd
#include <signal.h> // sigaction

#include <boost/program_options.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

#include <binlog/reader/EntryStream.H>
#include <binlog/reader/EventStream.H>
#include <binlog/reader/TailEventStream.H>
#include <binlog/reader/EntryProcessor.H>
#include <binlog/reader/SortedEventStream.H>
#include <binlog/reader/EventSourceStream.H>
#include <binlog/reader/FlowNameStream.H>
#include <binlog/reader/FlowInstanceStream.H>
#include <binlog/reader/FlowEventStream.H>
#include <binlog/reader/FlowGroupedEventStream.H>
#include <binlog/reader/PrettyPrinter.H>

#include <binlog/reader/FileInputStream.H>
#include <binlog/reader/detail/MmapInputStream.H>
#include <binlog/reader/detail/CompressedFileInputStream.H>
#include <binlog/reader/detail/AggregateInputStream.H>

#include <binlog/reader/entry/Event.H>
#include <binlog/reader/entry/EventSource.H>

using namespace binlog::reader;

using binlog::reader::detail::InputStream;
using binlog::reader::detail::MmapInputStream;
using binlog::reader::detail::CompressedFileInputStream;
using binlog::reader::detail::AggregateInputStream;

using binlog::reader::entry::Event;
using binlog::reader::entry::EventSource;
using binlog::reader::entry::FlowInstance;

struct SeverityFilter
{
  binlog::Severity minSeverity = binlog::trace;
  binlog::Severity maxSeverity = binlog::critical;

  bool isMuted(const EventSource& source) const
  {
    return source.severity() < minSeverity || source.severity() > maxSeverity;
  }

  bool isMuted(const Event& event) const
  {
    return isMuted(event.source());
  }

  bool isMuted(const entry::Entry&) const { return false; }
};

SeverityFilter g_severityFilter;

PrettyPrinter g_printer;

template <typename Entity>
void writeEntity(const Entity& entity)
{
  if (g_severityFilter.isMuted(entity)) { return; }

  g_printer.print(entity, std::cout);
}

struct ErrorHandler
{
  void operator()(std::error_code& ec)
  {
    fprintf(stderr, "[binlog] Reader Error: %s\n", ec.message().c_str());
  }
};

bool isCompressedFile(const std::string& path)
{
  return (boost::ends_with(path, ".gz"));
}

bool isElfFile(const std::string& path)
{
  std::fstream file(path.c_str(), std::ios_base::in | std::ios_base::binary);
  if (!file) { return false; }

  char actualMagic[] = {0, 0, 0, 0};
  file.read(actualMagic, 4);

  const char elfMagic[] = {0x7F, 'E', 'L', 'F'};
  return strncmp(actualMagic, elfMagic, 4) == 0;
}

std::vector<std::string> sortFilesByMtime(const std::vector<std::string>& paths)
{
  std::vector<std::pair<time_t, std::string>> mtimePaths;
  mtimePaths.reserve(paths.size());

  for (auto&& path : paths)
  {
    time_t mtime = 0;
    struct stat statres;
    if (stat(path.c_str(), &statres) == 0)
    {
      mtime = statres.st_mtim.tv_sec;
    }
    // else stat failure...

    mtimePaths.push_back({mtime, path});
  }

  std::sort(mtimePaths.begin(), mtimePaths.end(),
    [](const std::pair<time_t, std::string>& a, const std::pair<time_t, std::string>& b)
    {
      return a.first < b.first || (a.first == b.first && a.second < b.second);
    }
  );

  std::vector<std::string> result;
  result.reserve(mtimePaths.size());
  for (auto&& mtimePath : mtimePaths)
  {
    result.push_back(mtimePath.second);
  }

  return result;
}

std::unique_ptr<InputStream>
openInputFiles(const std::vector<std::string>& files, bool continuous, std::error_code& ec)
{
  std::unique_ptr<InputStream> resultPtr;

  try
  {
    if (files.size() == 1)
    {
      if (isCompressedFile(files[0]))
      {
       resultPtr.reset(new CompressedFileInputStream(files[0]));
      }
      else if (continuous)
      {
        resultPtr.reset(new FileInputStream(files[0], continuous));
      }
      else
      {
        resultPtr.reset(new MmapInputStream(files[0]));
      }
    }
    else
    {
      auto sortedLogInputs = sortFilesByMtime(files);
      resultPtr.reset(new AggregateInputStream(sortedLogInputs, continuous));
    }
  }
  catch (const std::runtime_error& ex)
  {
    using namespace binlog::detail::error;
    setError(ec, Error::runtime_error) << ex.what();
  }

  return resultPtr;
}

void dumpEntries(InputStream& input)
{
  EntryStream entries(input);

  entries.consume([&](Entry& entry)
  {
    writeEntity(entry);
  }, ErrorHandler{});
}

void dumpLogfile(InputStream& input)
{
  EntryStream entries(input);
  EventStream events(entries);

  events.consume([&](Event& event)
  {
    writeEntity(event);
  }, ErrorHandler{});
}

void dumpLogfileSorted(InputStream& input)
{
  EntryStream entries(input);
  EventStream events(entries);
  SortedEventStream sortedEvents(events);

  sortedEvents.consume([&](Event& event)
  {
    writeEntity(event);
  }, ErrorHandler{});
}

void exitSignalHandler(int) { exit(0); }

void exitOnSignal(int signal)
{
  struct sigaction action;

  action.sa_handler = exitSignalHandler;
  sigemptyset(&action.sa_mask);
  action.sa_flags = 0;

  sigaction(signal, &action, nullptr);
}

void dumpLogfileTail(
  const std::string& file,
  const std::size_t maxTailSize
)
{
  exitOnSignal(SIGTERM);
  exitOnSignal(SIGINT);

  std::error_code ec;
  auto tailInput = openInputFiles({file}, false, ec);
  if (!ec)
  {
    // get the last `maxTailSize` events
    EntryStream entries(*tailInput);
    TailEventStream events(entries, maxTailSize);

    events.consume([&](Event& event)
    {
      writeEntity(event);
    }, ErrorHandler{});

    std::cout.flush();

    // do continuous read if not compressed
    if (! isCompressedFile(file))
    {
      FileInputStream input(file, true);
      input.seekg(tailInput->tellg());
      entries.replaceInput(input);
      tailInput.reset(nullptr);

      events.consume([&](Event& event)
      {
        writeEntity(event);
        std::cout.flush();
      }, ErrorHandler{});
    }
  }
  else
  {
    // no logfile found, wait for it
    FileInputStream input(file, true);
    EntryStream entries(input);
    EventStream events(entries);

    events.consume([&](Event& event)
    {
      writeEntity(event);
      std::cout.flush(); // can't use dumpLogfile because we need this flush
    }, ErrorHandler{});
  }
}

void dumpElf(const std::string& elfPath)
{
  std::error_code ec;

  binlog::detail::Elf elf(elfPath, ec);
  EventSourceStream sources(elf);

  sources.consume([&](EventSource& source)
  {
    writeEntity(source);
  }, ec);

  if (ec)
  {
    ErrorHandler handleError;
    handleError(ec);
  }
}

void listAvailableFlowNames(InputStream& input)
{
  EntryStream entries(input);
  FlowNameStream flowNamesSm(entries);

  std::vector<std::string> flowNames;
  flowNamesSm.consume([&](std::string& name)
  {
    flowNames.push_back(std::move(name));
  }, ErrorHandler{});

  if (flowNames.empty())
  {
    std::cerr << "No flows found. Flows are identified by named placeholders:"
      "\nBINLOG_INFO(\"Transaction id: {0:trId}\");"
      "\nIn this example, 'trId' is the flow name.\n";
    return;
  }

  std::cerr << "Available flow names:\n\n";
  std::copy(flowNames.begin(), flowNames.end(), std::ostream_iterator<std::string>(std::cout, "\n"));

  std::cerr << "\nTo list flow instance ids, run --flow <selected-flow-name>" << std::endl;
}

void listFlowIdsOfFlow(InputStream& input, const std::string& flowName)
{
  EntryStream entries(input);
  FlowInstanceStream instances(entries, flowName);

  bool first = true; // Leave stderr empty if no flow instance found

  // override max severity, always show control events i.e: flow markers
  auto oldMaxSev = g_severityFilter.maxSeverity;
  g_severityFilter.maxSeverity = binlog::control;

  instances.consume([&](FlowInstance& instance)
  {
    if (first)
    {
      first = false;
      std::cerr << "Available flow instances in flow '" << flowName << "':\n" << std::endl;
    }

    std::cout << instance.id() << '\t';
    writeEntity(instance.firstEvent());
  }, ErrorHandler{});

  if (! first)
  {
    std::cout << std::flush;
    std::cerr << "\nTo track an instance, run --flow " << flowName << ":<flow-id>" << std::endl;
  }

  // restore overridden max severity
  g_severityFilter.maxSeverity = oldMaxSev;
}

void dumpFlow(
  InputStream& input,
  const std::string& flowName,
  const std::string& flowId
)
{
  EntryStream entries(input);
  FlowEventStream flowEvents(entries, flowName, flowId);
  SortedEventStream sortedFlowEvents(flowEvents);

  sortedFlowEvents.consume([&](Event& flowEvent)
  {
    writeEntity(flowEvent);
  }, ErrorHandler{});
}

void executeFlowCommand(InputStream& input, const std::string& flowCommand)
{
  // split command on :
  std::vector<std::string> parts;
  boost::split(parts, flowCommand, [](const char c) { return c == ':'; });

  if (parts.size() == 1)
  {
    if (parts[0].empty())
    {
      listAvailableFlowNames(input);
    }
    else
    {
      listFlowIdsOfFlow(input, parts[0]);
    }
  }
  else if (parts.size() == 2 && parts[0].empty() == false && parts[1].empty() == false)
  {
    dumpFlow(input, parts[0], parts[1]);
  }
  else
  {
    std::cerr << "Flow command not understood: '" << flowCommand <<
      "'\n\tExpected: [flow-name[:flow-id]]" << std::endl;
  }
}

void dumpGroupsByFlow(InputStream& input, const std::string& flowName)
{
  EntryStream entries(input);
  FlowGroupedEventStream groupedEvents(entries, flowName);

  groupedEvents.consume([&](Event& event)
  {
    writeEntity(event);
  }, ErrorHandler{});
}

boost::program_options::parsed_options parseRcFile(
  std::ifstream& rcfile,
  const boost::program_options::options_description& allowedOpts
)
{
  boost::program_options::parsed_options result(
    &allowedOpts,
    boost::program_options::command_line_style::allow_long
  );

  try
  {
    boost::property_tree::ptree pt;
    boost::property_tree::read_json(rcfile, pt);

    if (pt.count("reader"))
    {
      auto&& readerConfig = pt.get_child("reader");

      // read switches
      for (auto&& allowedOpt : allowedOpts.options())
      {
        auto maybeOption = readerConfig.get_child_optional(allowedOpt->long_name());
        if (maybeOption)
        {
          boost::program_options::option option;
          option.string_key = allowedOpt->long_name();
          option.value.push_back(maybeOption->data());
          result.options.push_back(option);
        }
      }
    }
  }
  catch (const boost::property_tree::json_parser_error& ex)
  {
    throw std::runtime_error(ex.what());
  }

  return result;
}

// Allow `--switch`, `--switch value` and `--switch ''` forms
// Workaround Boost 88dea3c6fdea8c9ea894911897b1770599c383e4
template <typename T>
class greedy_implicit_value : public boost::program_options::typed_value<T>
{
  using base = boost::program_options::typed_value<T>;
public:
  greedy_implicit_value(const T& value) : base(nullptr)
  {
    base::implicit_value(value);
  }

  bool adjacent_tokens_only() const override { return false; }
  unsigned max_tokens() const override { return 1; }
};

template <typename T>
boost::program_options::typed_value<T>* implicit_value(const T& value)
{
  return new greedy_implicit_value<T>(value);
}

bool parseArguments(
  int argc,
  char* argv[],
  boost::program_options::variables_map& vm
)
{
  namespace po = boost::program_options;

  po::options_description opts("Allowed options");
  opts.add_options()
    ("help,h", "Show this help")
    ("sort,s", "Sort events by timestamp")
    ("min-severity", po::value<std::string>()->required(), "Severity filter lower bound")
    ("max-severity", po::value<std::string>()->required(), "Severity filter upper bound")
    ("tail,t",       implicit_value<std::size_t>(40),      "Show end of log file and wait for more")
    ("format,o",     po::value<std::string>(), "Entry/Event/EventSource format string")
    ("date-format",  po::value<std::string>(), "Date format string")
    ("flow,f",       implicit_value<std::string>({}),      "Track data flow")
    ("groupby,g",    po::value<std::string>(),             "Group events by flow name")
    ("rcfile",       implicit_value<std::string>({}),      "Path to the .binlogrc file")
    ("debug", "Show bare entries only")
  ;

  po::options_description hiddenOpts("Hidden");
  hiddenOpts.add_options()
    ("input", po::value<std::vector<std::string>>(), "Input file")
  ;

  po::positional_options_description posOpts;
  posOpts.add("input", -1);

  po::options_description cmdOptions;
  cmdOptions.add(opts).add(hiddenOpts);

  try
  {
    po::store(
      po::command_line_parser(argc, argv)
      .options(cmdOptions)
      .positional(posOpts)
      .run(),
      vm
    );
  }
  catch (const std::logic_error& ex)
  {
    std::cerr << "Error: " << ex.what() << std::endl;
    return false;
  }

  std::ifstream rcfile;
  std::string rcpath;

  if (vm.count("rcfile") > 0)
  {
    rcpath = vm["rcfile"].as<std::string>();
    if (! rcpath.empty())
    {
      rcfile.open(rcpath.c_str());
      if (! rcfile)
      {
        std::cerr << "Failed to open rc file: '" << rcpath << "'" << std::endl;
        return false;
      }
    } // else: User wants to explicitly disable lookup of rc file in home
  }
  else
  {
    // try default rc file in user home
    passwd* pw = getpwuid(getuid());
    if (pw)
    {
      rcpath = pw->pw_dir;
      rcpath += "/.binlogrc";
      rcfile.open(rcpath.c_str());
      // don't care if open fails, having an rc file in home is optional
    }
  }

  if (rcfile && rcfile.is_open())
  {
    try
    {
      po::store(parseRcFile(rcfile, opts), vm);
    }
   catch (const std::runtime_error& ex)
    {
      std::cerr << "Failure while reading rc file: '" << rcpath <<
        "'\n\t" << ex.what() << std::endl;
      return false;
    }
  }

  return true;
}

void displayHelp()
{
  std::cout <<
    "Binlog Reader -- transform binary logfiles to human readable text\n"
    "\n"
    "Synopsis:\n"
    "  Reader filename... [--sort|--tail [tail-size]]"   "\n"
    "                     [--format entry-format]"       "\n"
    "                     [--date-format date-format]"   "\n"
    "                     [--min-severity severity]"     "\n"
    "                     [--max-severity severity]"     "\n"
    "                     [--flow [flow-name[:flow-id]]" "\n"
    "                     |--groupby flow-name"          "\n"
    "                     [--rcfile [rcfile]]"           "\n"
    "\n"
    "Examples:\n"
    "  Reader logfile.log"              "\n"
    "  Reader logfile.log logfile.*.gz" "\n"
    "  ./logfile.log"                   "\n"
    "  ./logfile.log --sort"            "\n"
    "  ./logfile.log --flow tranId:123" "\n"
    "  ./logfile.log --groupby tranId"  "\n"
    "  ./logfile.log --format \"%S [%d] %t %N %m\"" "\n"
    "\n"
    "Arguments:\n"
    "  filename       Path to a (possibly compressed) logfile or ELF object\n"
    "  tail-size      Number of events to show at the end of the file\n"
    "  entry-format   Arbitrary string with optional placeholders, see below\n"
    "  date-format    Arbitrary string with optional placeholders, see below\n"
    "  severity       One of these: trace, debug, info, warning, error, critical, control\n"
    "  flow-name      One of the application specific transaction type (e.g: requestId)\n"
    "  flow-id        Transaction id of the data flow you are interested in\n"
    "  rcfile         Path to a Reader configuration file, see below\n"
    "\n"
    "Allowed options:\n"
    "  -h, --help    Show this help\n"
    "  -s, --sort    Sort events by timestamp\n"
    "  -t, --tail    Show end of log file and wait for more events (see note below)\n"
    "  -o  --format  Set a custom format string to write entities, see 'Entry Format'\n"
    "  -f, --flow    Track data flow throughout the library using transaction ids\n"
    "  -g, --groupby Group events by given flow\n"
    "  --date-format Set a custom format string to write timestamps, see 'Date Format'\n"
    "  --min-severity Hide entities below the specified threshold\n"
    "  --max-severity Hide entities above the specified threshold\n"
    "  --rcfile      Set config file, defaults to '~/.binlogrc'. Ignores default if empty.\n"
    "\n"
    "Configuration File\n"
    "  It's possible to specify regularly used options in a config file, overriding the defaults.\n"
    "  The config file is a JSON file, by default it's at '~/.binlogrc'. \n"
    "  This program only cares about the options under the 'reader' key. For example: \n"
    "\n"
    "    {"                                      "\n"
    "     \"reader\" :"                          "\n"
    "     {"                                     "\n"
    "       \"sort\" : true,"                    "\n"
    "       \"format\" : \"%S %C %t %N %m\","    "\n"
    "       \"date-format\" : \"%y/%m/%d %H:%M:%S\"" "\n"
    "     }"                                     "\n"
    "    }"                                      "\n"
    "\n"
    "Entry Format\n"
    "  Log entries are transformed to text by substituting placeholders"
    " of the format string by entry fields. Available placeholders:\n"
    "\n"
    "  %I \t Source id\n"
    "  %C \t Category name\n"
    "  %S \t Severity\n"
    "  %F \t Format string of event source\n"
    "  %M \t Enclosing function (method) full name\n"
    "  %N \t Enclosing function (method) short name\n"
    "  %L \t Location. Format: file:line\n"
    "  %d \t Timestamp. See 'Date Format' below\n"
    "  %h \t Hostname\n"
    "  %t \t Thread name (or id, if name is not available)\n"
    "  %a \t Arguments. Format: (arg1|arg2|...|)\n"
    "  %m \t Message: event source format string with arguments substituted\n"
    "\n"
    "  Lower-case placeholders are available only when reading log files.\n"
    "  Default format string when reading log files: \"%S %C [%d] %t %N %m\"\n"
    "\n"
    "Date Format\n"
    "  Timestamps are transformed to text by substituting placeholders"
    "of the date format string by date components. Available placeholders:\n"
    "\n"
    "  %Y \t Year, four digits\n"
    "  %y \t Year, two digits\n"
    "  %m \t Month (01-12)\n"
    "  %d \t Day (01-31)\n"
    "  %H \t Hour (00-23)\n"
    "  %M \t Minute (00-59)\n"
    "  %S \t Second (00-59)\n"
    "  %U \t Microsecond (0-999999)\n"
    "  %q \t Raw TSC value (elapsed cycles since CPU RESET)\n"
    "  %r \t Elapsed TSC ticks since previous event\n"
    "\n"
    " Default date format string: \"%m/%d %H:%M:%S\"\n"
    "\n"
    "Reading online logs realtime\n"
    "  It's possible to read logfiles realtime, i.e: while they are being produced."            "\n"
    "  The --tail argument tells the Reader to wait for the next event until the writer exits." "\n"
    "  However, executing files opened for writing might produce the following error:"          "\n"
    "  'Text file is busy'. To workaround the problem, run the Reader explicitly:"              "\n"
    "\n"
    "    $ head -n1 /path/to/your.log                 # get reader path"   "\n"
    "    #!/path/to/Reader"                                                "\n"
    "    $ /path/to/Reader /path/to/your.log --tail   # works as expected" "\n"
    "\n"
    "Report bugs to:\n"
    "  mstkhelp\n"
  << std::endl;
}

int main(int argc, char* argv[])
{
  boost::program_options::variables_map args;
  if (! parseArguments(argc, argv, args)) { return 2; };

  if (args.count("help")) {
    displayHelp();
    return 0;
  }

  // Get inputs
  if (args.count("input") == 0)
  {
    std::cerr << "No input file specified. See --help." << std::endl;
    return 1;
  }

  std::vector<std::string> inputs = args["input"].as<std::vector<std::string>>();

  // select ELF and log inputs
  std::vector<std::string> elfInputs;
  std::vector<std::string> logInputs;

  for (auto&& input : inputs)
  {
    if (isElfFile(input))
    {
      elfInputs.push_back(input);
    }
    else
    {
      logInputs.push_back(input);
    }
  }

  // Set severity thresholds
  if (args.count("min-severity"))
  {
    const auto str = args["min-severity"].as<std::string>();
    binlog::Severity thr = binlog::stringToSeverity(str);
    if (thr == binlog::unknown)
    {
      std::cerr << "Invalid min-severity specified: " << str << "\n"
        "Valid severities are: trace/debug/info/warning/error/critical/control\n";
      return 2;
    }
    else
    {
      g_severityFilter.minSeverity = thr;
    }
  }

  if (args.count("max-severity"))
  {
    const auto str = args["max-severity"].as<std::string>();
    binlog::Severity thr = binlog::stringToSeverity(str);
    if (thr == binlog::unknown)
    {
      std::cerr << "Invalid max-severity specified: " << str << "\n"
        "Valid severities are: trace/debug/info/warning/error/critical/control\n";
      return 2;
    }
    else
    {
      g_severityFilter.maxSeverity = thr;
    }
  }

  if (g_severityFilter.minSeverity > g_severityFilter.maxSeverity)
  {
    std::cerr << "Error: --min-severity > --max-severity" << std::endl;
    return 5;
  }

  // Set switches
  bool sortEntries = args.count("sort") > 0;
  bool tailMode = args.count("tail") > 0;
  bool flowMode = args.count("flow") > 0;
  bool groupMode = args.count("groupby") > 0;
  bool debugMode = args.count("debug") > 0;

  // Check mutually exclusive switches

  if (flowMode && groupMode)
  {
    std::cerr << "Can't track --flow and --groupby at the same time" << std::endl;
    return 2;
  }

  if (debugMode && (sortEntries || tailMode || flowMode || groupMode))
  {
    std::cerr << "No --sort/--tail/--flow/--groupby while --debug" << std::endl;
    return 2;
  }

  // Hope for better I/O performance
  std::cout.sync_with_stdio(false);

  // Process ELF inputs
  for (auto&& input : elfInputs)
  {
    if (sortEntries || tailMode || flowMode || groupMode)
    {
      std::cerr << "Ignoring invalid switch (sort/tail/flow/groupby)"
        " while reading ELF file" << std::endl;
    }

    if (args.count("format"))
    {
      g_printer.setEventSourceFormat(args["format"].as<std::string>() + "\n");
    }

    dumpElf(input);
  }

  // Process Log inputs
  if (logInputs.empty()) { return 0; }

  // Set event and date format string
  if (args.count("format"))
  {
    g_printer.setEventFormat(args["format"].as<std::string>() + "\n");
  }

  if (args.count("date-format"))
  {
    g_printer.setDateFormat(args["date-format"].as<std::string>());
  }

  if (tailMode)
  {
    try
    {
      auto sortedLogInputs = sortFilesByMtime(logInputs);
      auto tailSize = args["tail"].as<std::size_t>();
      dumpLogfileTail(sortedLogInputs.back(), tailSize);
    }
    catch (const std::runtime_error& ex)
    {
      std::cerr << "Error: " << ex.what() << std::endl;
      return 3;
    }

    return 0;
  }

  std::error_code ec;
  auto inputStreamPtr = openInputFiles(logInputs, false, ec);
  if (ec)
  {
    std::cerr << ec.message() << std::endl;
    return 3;
  }

  if (debugMode)
  {
    // Overwrite format if specified
    if (args.count("format"))
    {
      g_printer.setEntryFormat(args["format"].as<std::string>() + "\n");
    }

    dumpEntries(*inputStreamPtr);
  }
  else if (flowMode)
  {
    auto flowCommand = args["flow"].as<std::string>();
    executeFlowCommand(*inputStreamPtr, flowCommand);
  }
  else if (groupMode)
  {
    auto flowName = args["groupby"].as<std::string>();
    dumpGroupsByFlow(*inputStreamPtr, flowName);
  }
  else if (sortEntries)
  {
    dumpLogfileSorted(*inputStreamPtr);
  }
  else
  {
    dumpLogfile(*inputStreamPtr);
  }

  return 0;
}
Attention:  ./bin/logchecker/Logchecker.C
#include <string>
#include <cstdio>
#include <sstream>

#include <boost/lexical_cast.hpp>

#include <binlog/reader/EventSourceStream.H>

using binlog::reader::entry::EventSource;

namespace {

#define COLOR_ERROR     "\033[1;31m"
#define COLOR_ERROR_ARG "\033[1;35m"
#define COLOR_RESET     "\033[0m"

bool getNextArgument(
  const std::string& code, std::size_t& offset, std::size_t& argLen
)
{
  std::size_t braceCount = 0;
  bool inString = false;
  bool inArgument = false;
  std::size_t stringDelimEscape = -2lu;

  for (std::size_t i = offset; i < code.size(); ++i)
  {
    char c = code[i];

    if (!inArgument)
    {
      if (c == ')')
      {
        return false;
      }
      else if (c == ',' || isspace(c))
      {
        continue;
      }
      else
      {
        // argument start
        offset = i;
        inArgument = true;
      }
    }

    if (inArgument)
    {
      switch (c)
      {
      case '\\':
        stringDelimEscape = i;
        break;
      case '"':
        if (stringDelimEscape != i - 1) { inString = !inString; }
        break;
      case '(':
        if (!inString) { ++braceCount; }
        break;
      case ')':
        if (!inString)
        {
          --braceCount;
          if (braceCount == 0)
          {
            argLen = i - offset + 1;
            return true;
          }
        }
        break;
      case ',':
        if (!inString && braceCount == 0) {
          argLen = i - offset;
          return true;
        }
        break;
      }
    }
  }

  return false;
}

template <typename Item>
void highlightArgSpecByValue(EventSource& source, Item& highlightedItem)
{
  const auto& code = source.programCode();
  auto argIndex = highlightedItem->argIndex();

  auto toHighlight = '{' + boost::lexical_cast<std::string>(argIndex) + '}';

  std::stringstream out;
  std::size_t prevArgPos = 0;
  auto argPos = code.find(toHighlight, prevArgPos);

  while (argPos != std::string::npos)
  {
    out << code.substr(prevArgPos, argPos - prevArgPos)
        << COLOR_ERROR_ARG
        << toHighlight
        << COLOR_RESET;

    prevArgPos = argPos + toHighlight.size() + 1;
    argPos = code.find(toHighlight, prevArgPos);
  }

  out << code.substr(prevArgPos);

  printf("%s\n", out.str().c_str());
}

template <typename Item>
void highlightArgSpec(EventSource& source, Item& highlightedItem)
{
  const auto& code = source.programCode();
  const auto& formatStr = source.formatString();
  auto formatPos = code.find(formatStr);

  if (formatPos == std::string::npos)
  {
    // failed to get format string pos, fallback
    return highlightArgSpecByValue(source, highlightedItem);
  }

  std::stringstream out;

  std::size_t argPos = 0;
  bool closeHighlight = false;

  for (auto& item : source.parsedFormatString()._items)
  {
    out << code.substr(argPos, item->getPos() + formatPos - argPos);

    if (closeHighlight)
    {
      closeHighlight = false;
      out << COLOR_RESET;
    }

    if (item == highlightedItem)
    {
      out << COLOR_ERROR_ARG;
      closeHighlight = true;
    }

    argPos = item->getPos() + formatPos;
  }

  out << code.substr(argPos, formatStr.size() + formatPos - argPos);

  if (closeHighlight)
  {
    out << COLOR_RESET;
  }

  out << code.substr(formatPos + formatStr.size());

  printf("%s\n", out.str().c_str());
}

void highlightArgument(EventSource& source, std::size_t highlightedArg)
{
  auto code = source.programCode();
  const auto& formatStr = source.formatString();
  auto formatPos = code.find(formatStr);
  auto argOffset = formatPos + formatStr.size() + 1;
  auto prevArgOffset = argOffset;
  std::size_t argLen = 0;
  std::size_t argIndex = 0;

  if (formatPos == std::string::npos)
  {
    // failed to get format string pos, omit highlight
    printf("%s\n", code.c_str());
    return;
  }

  std::stringstream out;
  out << code.substr(0, argOffset);

  while (getNextArgument(code, argOffset, argLen))
  {
    // print whitespace and , before arg
    out << code.substr(prevArgOffset, argOffset - prevArgOffset);

    if (argIndex == highlightedArg)
    {
      out << COLOR_ERROR_ARG;
    }

    out << code.substr(argOffset, argLen);

    if (argIndex == highlightedArg)
    {
      out << COLOR_RESET;
    }

    argOffset += argLen;
    prevArgOffset = argOffset;

    ++argIndex;
  }

  out << code.substr(argOffset);

  printf("%s\n", out.str().c_str());
}

bool checkInvalidArgIndex(EventSource& source)
{
  bool status = true;
  std::size_t indexUpperBound = source.typeCodes().size();

  for (auto& item : source.parsedFormatString()._items)
  {
    auto argIndex = item->argIndex();
    if (argIndex != std::size_t(-1) && argIndex >= indexUpperBound)
    {
      status = false;

      // print diagnostics
      printf(COLOR_ERROR "Error" COLOR_RESET " in file: %s:%d\nInvalid argument requested:\n",
        source.file().c_str(), source.line());

      highlightArgSpec(source, item);
    }
  }

  return status;
}

bool checkUnusedArgument(EventSource& source)
{
  bool status = true;
  std::string unusedArguments(source.typeCodes().size(), '1');

  for (const auto& item : source.parsedFormatString()._items)
  {
    auto argIndex = item->argIndex();
    if (argIndex != -1lu)
    {
      if (argIndex < unusedArguments.size())
      {
        unusedArguments[argIndex] = '0';
      } // else: invalid index
    }
  }

  std::size_t argIndex = 0;
  for (auto& isUnused : unusedArguments)
  {
    if (isUnused == '1')
    {
      status = false;

      // print diagnostics
      printf(COLOR_ERROR "Error" COLOR_RESET " in file: %s:%d\nArgument unused:\n",
        source.file().c_str(), source.line());

      highlightArgument(source, argIndex);
    }

    ++argIndex;
  }

  return status;
}

bool checkFlowMarker(EventSource& source)
{
  if (source.isFlowBegin() == false && source.isFlowEnd() == false)
  {
    return true;
  }

  auto&& namedPlaceholders = source.parsedFormatString().getNamedPlaceholders();
  if (namedPlaceholders.size() < 1)
  {
    // print diagnostics
    printf(
      COLOR_ERROR "Error" COLOR_RESET " in file %s:%d\n"
      "Flow marker has no named placeholder:\n%s\n",
      source.file().c_str(), source.line(),
      source.programCode().c_str()
    );
    return false;
  }
  else if (namedPlaceholders.size() > 1)
  {
    // print diagnostics
    printf(
      COLOR_ERROR "Error" COLOR_RESET " in file %s:%d\n"
      "Flow marker has too many named placeholders:\n%s\n",
      source.file().c_str(), source.line(),
      source.programCode().c_str()
    );
    return false;
  }

  return true;
}

} // namespace

int main(int argc, char* argv[])
{
  if (argc < 2)
  {
    fprintf(stderr, "Usage: %s ELF\n", argv[0]);
    return 1;
  }

  const std::string elfPath(argv[1]);

  std::error_code ec;
  binlog::detail::Elf elf(elfPath, ec);
  binlog::reader::EventSourceStream sources(elf);

  bool elfOk = true;

  sources.consume([&](EventSource& source)
  {
    elfOk &= checkInvalidArgIndex(source);
    elfOk &= checkUnusedArgument(source);
    elfOk &= checkFlowMarker(source);
  }, ec);

  if (ec)
  {
    fprintf(stderr, "Error: %s\n", ec.message().c_str());
    return 3;
  }

  if (!elfOk)
  {
    return 2;
  }

  return 0;
}
Attention:  ./lib/binlog/CategoryConfig.C
#include <binlog/CategoryConfig.H>
#include <binlog/Configuration.H>

namespace binlog {

CategoryConfig::CategoryConfig()
  :minSeverity(debug)
{}

CategoryConfig::CategoryConfig(const Severity& minSeverityArg)
  :minSeverity(minSeverityArg)
{}

namespace detail {

CategoryConfigGuard::CategoryConfigGuard(const std::string& name, CategoryConfig& config)
  :_pConfig(&config)
{
  getConfiguration().registerCategory(name, config);
}

CategoryConfigGuard::~CategoryConfigGuard()
{
  getConfiguration().unregisterCategory(*_pConfig);
}

} // namespace detail

} // namespace binlog
Attention:  ./lib/binlog/Configuration.C
#include <algorithm>
#include <cstdio>
#include <cstdlib>  // getenv

#include <boost/algorithm/string/predicate.hpp> // ends_with

#include <binlog/Configuration.H>
#include <binlog/Severity.H>

#include <binlog/reader/EventSourceStream.H>

#include <binlog/sink/MultiConsumer.H>

#include <binlog/detail/ElfConfig.H>
#include <binlog/detail/ThreadContext.H>

namespace binlog {

Configuration& getConfiguration()
{
  static Configuration config;
  return config;
}

void Configuration::setSinkFactory(const detail::ConfigParser::SinkFactory& sf)
{
  _configParser.setSinkFactory(sf);
}

void Configuration::setPredicateFactory(const detail::ConfigParser::PredicateFactory& pf)
{
  _configParser.setPredicateFactory(pf);
}

void Configuration::initFromConfig(const std::string& configFile)
{
  std::error_code ec;
  if (!initFromConfig(configFile, ec))
  {
    throw std::system_error(ec);
  }
}

bool Configuration::initFromConfig(const std::string& configFile, std::error_code& ec)
{
  // Setup ${ENVVAR} replacement
  auto readEnvvar = [](const std::string& name)
  {
    const char* value = getenv(name.c_str());
    if (value) { return std::string{value}; }
    else { return name; }
  };

  _configParser.setVariableFactory(readEnvvar);

  // Read config file
  _configParser.readConfigFile(configFile, ec);

  auto&& categoryConfig = _configParser.getCategoryConfig(ec);
  auto&& sinkConfig     = _configParser.getConfiguredSinks(ec);
  auto&& producerConfig = _configParser.getProducerConfig(ec);

  if (ec) { return false; } // Transactional behavior

  // Apply category config
  if (categoryConfig.empty() == false)
  {
    resetCategoryConfig();
    setCategoryConfigs(categoryConfig);
  }

  // Apply sink config
  if (sinkConfig.empty() == false)
  {
    auto&& mc = sink::MultiConsumer::getInstance();

    // drop sinks
    auto&& sinks = mc.listSinks();
    for (auto&& sink : sinks)
    {
      mc.removeSink(sink);
    }

    for (auto&& sink : sinkConfig)
    {
      mc.addSink(std::move(sink.sinkPtr), sink.predicate, sink.description);
    }
  }

  // Apply producer config
  if (producerConfig.adaptiveSeverityCeiling)
  {
    setAdaptiveSeverityCeiling(*producerConfig.adaptiveSeverityCeiling);
  }

  if (producerConfig.minQueueSize)
  {
    setMinQueueSize(*producerConfig.minQueueSize);
  }

  return true;
}

void Configuration::registerCategory(
  const std::string& name,
  CategoryConfig& config
)
{
  std::lock_guard<std::mutex> lock(_categoryMutex);

  // save pointer for later use
  _configs[name].push_back(&config);

  // set config by preset if any
  auto presetIt = getMatchingPreset(name);
  if (presetIt != _presets.end())
  {
    config = presetIt->second;
  }
}

void Configuration::unregisterCategory(CategoryConfig& catconfig)
{
  std::lock_guard<std::mutex> lock(_categoryMutex);

  for (auto&& config : _configs)
  {
    auto&& ccs = config.second;
    ccs.erase(
      std::remove(ccs.begin(), ccs.end(), &catconfig),
      ccs.end()
    );
  }

  // remove empty keys
  auto configIt = _configs.begin();
  while (configIt != _configs.end())
  {
    if (configIt->second.empty())
    {
      configIt = _configs.erase(configIt);
    }
    else
    {
      ++configIt;
    }
  }
}

std::vector<std::pair<std::string, CategoryConfig*>>
Configuration::getCategories() const
{
  std::lock_guard<std::mutex> lock(_categoryMutex);

  std::vector<std::pair<std::string, CategoryConfig*>> result;
  result.reserve(_configs.size());

  for (auto&& name : _configs)
  {
    for (auto&& conf : name.second)
    {
      result.emplace_back(name.first, conf);
    }
  }

  return result;
}

void Configuration::setCategoryConfig(
  const std::string& category,
  const CategoryConfig& config
)
{
  std::vector<std::pair<std::string, CategoryConfig>>
  setting{{category, config}};

  setCategoryConfigs(setting);
}

void Configuration::setCategoryConfigs(
  std::vector<
    std::pair<std::string, CategoryConfig>
  > presets
)
{
  std::lock_guard<std::mutex> lock(_categoryMutex);

  _presets.clear();
  _presets.reserve(presets.size());

  std::vector<bool> configChanged(_configs.size(), false);

  for (auto&& preset : presets)
  {
    detail::Pattern pattern(preset.first);

    // update matching registered configs
    std::size_t configIdx = 0;
    for (auto&& config : _configs)
    {
      if (configChanged[configIdx] == false && pattern.matches(config.first))
      {
        for (auto&& pCategory : config.second)
        {
          *pCategory = preset.second;
        }

        configChanged[configIdx] = true;
      }

      ++configIdx;
    }

    // save preset for later registered configs
    _presets.emplace_back(std::move(pattern), preset.second);
  }
}

Configuration::PresetContainer::const_iterator
Configuration::getMatchingPreset(const std::string& name) const
{
  for (auto it = _presets.begin(); it != _presets.end(); ++it)
  {
    if (it->first.matches(name))
    {
      return it;
    }
  }

  return _presets.end();
}

void Configuration::resetCategoryConfig()
{
  std::lock_guard<std::mutex> lock(_categoryMutex);

  // drop presets
  _presets.clear();

  // reset managed configs
  for (auto&& namedConfigs : _configs)
  {
    for (CategoryConfig* pConfig : namedConfigs.second)
    {
      *pConfig = CategoryConfig{};
    }
  }
}

void Configuration::setAdaptiveSeverityCeiling(Severity ceiling)
{
  _adaptiveSeverityCeiling = ceiling;
}

Severity Configuration::getAdaptiveSeverityCeiling()
{
  return _adaptiveSeverityCeiling;
}

void Configuration::incrementCategoryThresholds()
{
  std::lock_guard<std::mutex> lock(_categoryMutex);

  Severity minThreshold = _adaptiveSeverityCeiling;

  for (auto&& nameCatvecPair : _configs)
  {
    for (auto&& cat : nameCatvecPair.second)
    {
      if (cat->minSeverity < minThreshold)
      {
        minThreshold = cat->minSeverity;
      }
    }
  }

  if (minThreshold < _adaptiveSeverityCeiling)
  {
    Severity newMinThreshold = detail::nextSeverity(minThreshold);

    fprintf(stderr, "[binlog] WARNING: Increase min severity threshold to %s\n",
      severityToString(newMinThreshold));

    for (auto&& nameCatvecPair : _configs)
    {
      for (auto&& cat : nameCatvecPair.second)
      {
        if (cat->minSeverity == minThreshold)
        {
          cat->minSeverity = newMinThreshold;
        }
      }
    }
  }
  // else: every category is at or above the max controlled level, nothing to do
}

void Configuration::setMinQueueSize(std::size_t size)
{
  return detail::ThreadContext::setMinQueueSize(size);
}

std::size_t Configuration::getMinQueueSize() const
{
  return detail::ThreadContext::getMinQueueSize();
}

void Configuration::registerElfConfig(detail::ElfConfig* elfConfig)
{
  std::lock_guard<std::mutex> lock(_elfMutex);
  _elfConfigs.push_back(elfConfig);
}

void Configuration::unregisterElfConfig(detail::ElfConfig* elfConfig)
{
  std::lock_guard<std::mutex> lock(_elfMutex);
  _elfConfigs.erase(
    std::remove(_elfConfigs.begin(), _elfConfigs.end(), elfConfig),
    _elfConfigs.end()
  );
}

bool Configuration::toggleSource(const std::string& fileEnd, unsigned line, bool enable)
{
  return toggleSource(
    [&](const reader::entry::EventSource& source)
    {
      return (!line || line == source.line()) && boost::ends_with(source.file(), fileEnd);
    },
    enable
  );
}

bool Configuration::toggleSource(EventSourcePredicate predicate, bool enable)
{
  return changeSources(
    predicate,
    [&](detail::ElfConfig* pElfConfig, std::size_t sourceIndex)
    {
      (enable)
        ? pElfConfig->enableSource(sourceIndex)
        : pElfConfig->disableSource(sourceIndex);
    }
  );
}

bool Configuration::changeSources(
  EventSourcePredicate& predicate,
  std::function<void(detail::ElfConfig*, std::size_t sourceIndex)> action
)
{
  std::lock_guard<std::mutex> lock(_elfMutex);

  bool sourceFound = false;

  for (auto pElfConfig : _elfConfigs)
  {
    std::error_code ec;
    binlog::detail::Elf elf(pElfConfig->getPath(), ec);
    reader::EventSourceStream source(elf);

    source.consume([&](reader::entry::EventSource& source)
    {
      if (predicate(source))
      {
        // this is one of the sources we are looking for
        sourceFound = true;

        // toggle it
        auto sourceIndex = pElfConfig->getSourceIndex(source.sourceId());
        action(pElfConfig, sourceIndex);
      }
    });
  }

  return sourceFound;
}

} // namespace binlog
Attention:  ./lib/binlog/Binlog.C
#include <binlog/Binlog.H>
#include <binlog/Configuration.H>
#include <binlog/sink/SingleConsumer.H>
#include <binlog/detail/WaitStrategy.H>
#include <binlog/detail/ThreadContext.H>

namespace binlog {

void setCategoryConfigs(
  const std::vector<
    std::pair<std::string, CategoryConfig>
  >& configs
)
{
  getConfiguration().setCategoryConfigs(configs);
}

void openLogFile(const std::string& logFile)
{
  static detail::SleepWaitStrategy waitStrategy;

  auto&& singleConsumer = sink::SingleConsumer::getInstance();
  singleConsumer.setFileSink(logFile);
  singleConsumer.start(waitStrategy);
}

void setThreadName(const std::string& name)
{
  detail::ThisThreadContext::get().setName(name);
}

} // namespace binlog
Attention:  ./lib/binlog/reader/SortedEventStream.C
#include <algorithm>

#include <binlog/reader/SortedEventStream.H>

namespace binlog {
namespace reader {

SortedEventStream::SortedEventStream(detail::Consumable<Event>& input)
  :_input(input)
{
  _buffer.reserve(1000000);
}

void SortedEventStream::consume(SinkT sink, ErrorHandler handleError)
{
  _input.consume([&](Event& event)
  {
    _buffer.push_back(std::move(event));
  }, handleError);

  std::sort(
    _buffer.begin(), _buffer.end(),
    [](const Event& a, const Event& b)
    {
      return a.tsc() < b.tsc();
    }
  );

  for (auto&& event : _buffer)
  {
    sink(event);
  }
}

} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/entry/StructDefinition.C
#include <binlog/reader/entry/StructDefinition.H>
#include <binlog/reader/detail/DeserializedStruct.H>
#include <binlog/reader/detail/DeserializedArray.H>
#include <binlog/reader/detail/DeserializedTuple.H>
#include <binlog/reader/detail/Argument.H>

namespace binlog {
namespace reader {
namespace entry  {

StructDefinition::StructDefinition(detail::ReadBuffer reader, std::error_code& ec)
{
  serialize(reader, ec);
}

StructDefinition::StructDefinition(uint64_t id, detail::ReadBuffer& reader, std::error_code& ec)
  :_id(id)
{
  using namespace binlog::detail::error;
  detail::serialize(reader, _name, ec, Error::no_sdef_name);

  unsigned char fieldCount = 0;
  detail::serialize(reader, fieldCount, ec, Error::no_sdef_fields);

  if (ec) { return; }

  _fields.resize(fieldCount);

  for (auto&& field : _fields)
  {
    field.serialize(reader, ec);
  }
}

detail::DeserializedStruct StructDefinition::instantiate(
  const detail::ArgumentParseContext& apc,
  detail::ReadBuffer& reader
) const
{
  detail::DeserializedStruct ds(_name);

  for (auto&& field : _fields)
  {
    auto&& arg = detail::readArgument(apc, reader, field._typeTag);
    ds.setField(field._name, std::move(arg));
  }

  return ds;
}

} // namespace entry
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/entry/HostProp.C
#include <binlog/reader/entry/HostProp.H>
#include <binlog/reader/detail/Buffer.H>

namespace binlog {
namespace reader {
namespace entry  {

HostProp::HostProp(detail::ReadBuffer input, std::error_code& ec)
{
  serialize(input, ec);
}

} // namespace entry
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/entry/ThreadProp.C
#include <sstream>

#include <binlog/reader/detail/Buffer.H>
#include <binlog/reader/entry/ThreadProp.H>

namespace binlog {
namespace reader {
namespace entry  {

ThreadProp::ThreadProp()
  :_lwp(0),
   _threadName("{InvalidThread}")
{}

ThreadProp::ThreadProp(detail::ReadBuffer input, std::error_code& ec)
{
  serialize(input, ec);

  if (_threadName.empty())
  {
    _threadName = std::to_string(_lwp);
  }
}

} // namespace entry
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/entry/ThreadActivity.C
#include <binlog/detail/Error.H>

#include <binlog/reader/entry/ThreadActivity.H>

namespace binlog {
namespace reader {
namespace entry  {

ThreadActivity::ThreadActivity(
  Entry base,
  const TscSynchronization& tscSync,
  const ThreadProp& threadProp,
  const HostProp& hostProp,
  std::error_code& ec
)
  :Entry(std::move(base)),
   _threadProp(threadProp),
   _hostProp(hostProp)
{
  using namespace binlog::detail::error;

  detail::serialize(_reader, _tsc, ec, Error::no_ta_tsc);

  _dateTime = tscSync.tscToLocaltime(_tsc);
}

void ThreadActivity::serialize(detail::WriteBuffer& writer)
{
  Entry::entry_size_t size = Entry::entry_size_t(
    sizeof(size) + sizeof(_tag) + sizeof(_tsc) + _reader.size()
  );

  writer.write(size);
  writer.write(_tag);
  writer.write(_tsc);
  writer.write(_reader.get(), _reader.size());
}

} // namespace entry
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/entry/EventSource.C
#include <fstream>
#include <algorithm>
#include <iterator>

#include <binlog/reader/entry/EventSource.H>
#include <binlog/reader/detail/Buffer.H>
#include <binlog/detail/Arguments.H>

namespace binlog {
namespace reader {
namespace entry  {

EventSource::EventSource(
  tag_t sourceId,
  void* instructionPointer,
  const std::string& category,
  Severity severity,
  const std::string& formatString,
  const std::string& typeCodes,
  const detail::SourceLocation& location
)
  :_sourceId(sourceId),
   _instructionPointer(instructionPointer),
   _category(category),
   _formatString(formatString),
   _typeCodes(typeCodes),
   _parsedFormatString(formatString),
   _function(location.function),
   _file(location.file),
   _line(location.line),
   _severity(severity)
{}

EventSource::EventSource(detail::ReadBuffer input, std::error_code& ec)
{
  serialize(input, ec);
  if (!ec)
  {
    _parsedFormatString = detail::ParsedFormat(_formatString);
  }
}

void EventSource::substituePlaceholders(
  const std::vector<detail::Argument>& arguments,
  std::ostream& out
) const
{
  _parsedFormatString.substituePlaceholders(arguments, out);
}

bool EventSource::isFlowBegin() const
{
  return
    _severity == control &&
    _formatString.compare(
      0, sizeof("Begin flow: ") - 1,
      "Begin flow: "
    ) == 0
  ;
}

bool EventSource::isFlowEnd() const
{
  return
    _severity == control &&
   _formatString.compare(
      0, sizeof("End flow: ") - 1,
      "End flow: "
    ) == 0
  ;
}

namespace {

int unbalancedBracesInLine(const std::string& line)
{
  int ubCount = 0;
  bool inString = false;
  std::size_t stringDelimEscape = -2lu;

  for (std::size_t i = 0; i < line.size(); ++i)
  {
    char c = line[i];
    switch (c) {
    case '\\':
      stringDelimEscape = i;
      break;
    case '"':
      if (stringDelimEscape != i - 1) { inString = !inString; }
      break;
    case '(':
      if (!inString) { ++ubCount; }
      break;
    case ')':
      if (!inString) { --ubCount; }
      break;
    }
  }

  return ubCount;
}

} // namespace

const std::string& EventSource::programCode()
{
  if (_programCode.empty())
  {
    std::fstream input(_file);

    if (!input)
    {
      _programCode = "Source code is not accessible";
      return _programCode;
    }

    unsigned lineIndex = 1;
    while (input && lineIndex < _line)
    {
      input.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
      ++lineIndex;
    }

    std::string wholeLine;
    int unbalancedBraceCount = -1;

    while (input && unbalancedBraceCount)
    {
      std::string nthLine;
      std::getline(input, nthLine);
      wholeLine += nthLine + "\n";

      unbalancedBraceCount = unbalancedBracesInLine(wholeLine);
    }

    _programCode = wholeLine;
  }

  return _programCode;
}

std::string EventSource::shortFunction() const
{
  std::stringstream result;
  writeShortFunction(*this, result);
  return result.str();
}

bool isIdentifierChar(char c)
{
  return ('a' <= c && c <= 'z')
    ||   ('A' <= c && c <= 'Z')
    ||   ('0' <= c && c <= '9')
    ||   c == '_';
}

std::size_t dropNestedParens(const std::string& input, std::size_t pos, char open, char close)
{
  if (input[pos] != open) { return pos; }

  std::size_t sepCount = 1;
  for (++pos; pos < input.size(); ++pos)
  {
    if (input[pos] == open) { ++sepCount; }
    else if (input[pos] == close)
    {
      --sepCount;
      if (sepCount == 0) { ++pos; break; }
    }
  }

  return pos;
}

void writeShortFunction(const EventSource& es, std::ostream& out)
{
  auto&& function = es.function();

  // class name position, or function name position, if there is no class name
  std::size_t cb = 0;
  std::size_t ce = 0;

  // function name position, if any
  std::size_t fb = 0;
  std::size_t fe = 0;

  while (true)
  {
    while (fe < function.size() && isIdentifierChar(function[fe]))
    {
      ++fe;
    }

    std::size_t i = dropNestedParens(function, fe, '<', '>');
    if (i + 2 < function.size() && function[i] == ':' && function[i+1] == ':')
    {
      cb = (ce) ? fb + 2 : fb; // +2: skip :: if not the first name
      ce = fe;
      fb = i;
      fe = i + 2;
    }
    else { break; }
  }

  if (ce)
  {
    out.write(function.data() + cb, std::streamsize(ce - cb));
  }

  out.write(function.data() + fb, std::streamsize(fe - fb));
}

} // namespace entry
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/entry/Event.C
#include <binlog/reader/entry/Event.H>
#include <binlog/reader/entry/EventSource.H>
#include <binlog/reader/detail/ArgumentParseContext.H>

namespace binlog {
namespace reader {
namespace entry  {

Event::Event(
  const EventSource& source,
  const detail::ArgumentParseContext& apc,
  ThreadActivity activity
)
  :ThreadActivity(std::move(activity)),
   _source(&source),
   _arguments(apc.readArguments(payloadRef(), source.typeCodes()))
{}

std::string Event::message() const
{
  std::stringstream result;
  writeMessage(*this, result);
  return result.str();
}

void writeMessage(const Event& event, std::ostream& out)
{
  event.source().substituePlaceholders(event.arguments(), out);
}

} // namespace entry
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/entry/TscSynchronization.C
#include <binlog/detail/Time.H>

#include <binlog/reader/entry/TscSynchronization.H>
#include <binlog/reader/detail/Buffer.H>

namespace binlog {
namespace reader {
namespace entry  {

TscSynchronization::TscSynchronization(detail::ReadBuffer input, std::error_code& ec)
{
  serialize(input, ec);
}

TscSynchronization::time_point
TscSynchronization::tscToTime(const uint64_t tsc) const
{
  auto diff = (tsc > _tsc) ? tsc - _tsc : _tsc - tsc;

  std::chrono::microseconds durDiff(
    static_cast<int64_t>(
      binlog::detail::tscToSeconds(diff, _cpufreq) * 1000 * 1000
    )
  );

  return (tsc > _tsc)
    ? _time + durDiff
    : _time - durDiff
  ;
}

TscSynchronization::time_point
TscSynchronization::tscToLocaltime(const uint64_t tsc) const
{
  auto diff = (tsc > _tsc) ? tsc - _tsc : _tsc - tsc;

  std::chrono::microseconds durDiff(
    static_cast<int64_t>(
      binlog::detail::tscToSeconds(diff, _cpufreq) * 1000 * 1000
    )
  );

  return (tsc > _tsc)
    ? _time + durDiff + std::chrono::seconds(_tzOffset)
    : _time - durDiff + std::chrono::seconds(_tzOffset)
  ;
}

} // namespace entry
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/FlowInstanceStream.C
#include <iostream>

#include <boost/lexical_cast.hpp>

#include <binlog/reader/FlowInstanceStream.H>

namespace binlog {
namespace reader {

FlowInstanceStream::FlowInstanceStream(detail::Consumable<Entry>& input, const std::string& flowName)
  :EntryProcessorT(input),
   _flowName(flowName)
{}

void FlowInstanceStream::processEventSource(EventSource& eventSource, SinkT& sink)
{
  bool sourceContainsFlow = false;

  auto namedPlaceholders = eventSource.parsedFormatString().getNamedPlaceholders();
  for (const auto& placeholder : namedPlaceholders)
  {
    if (placeholder.second == _flowName)
    {
      // this event source is part of our flow
     _flowSources.insert({eventSource.sourceId(), placeholder.first});

      sourceContainsFlow = true;

      // The following format string might be possible:
      // "Two flows meet here: {0:trId} and {1:trId}"
      // This would imply a multimap _flowSources
      // and more complex searches later. Disqualify this instead
      // and break; right after finding the first aptly named placeholder.
      break;
    }
  }

  if (sourceContainsFlow)
  {
    EntryProcessorT::processEventSource(eventSource, sink);
  } // else: we are not interested in this source, no need to consume
    // memory and increase search effort for nothing
}

void FlowInstanceStream::processThreadActivity(ThreadActivity& activity, SinkT& sink, std::error_code&)
{
  const auto placeholderIndexFinder = _flowSources.find(activity.tag());
  if (placeholderIndexFinder == _flowSources.end())
  {
    return;
  }

  const auto placeholderIndex = placeholderIndexFinder->second;

  const auto sourceFinder = _sources.find(activity.tag());
  if (sourceFinder == _sources.end())
  {
    std::cerr << "Invalid source id: " << activity.tag()
      << "\n\tThis indicates a FlowInstaceStream/EntryProcessor bug"
      << std::endl;
    return;
  }

  // get the flow instance id argument at `placeholderIndex`
  auto payload = activity.payload();
  const auto& source = sourceFinder->second;
  const std::string neededArgs = source.typeCodes().substr(0, placeholderIndex + 1);
  auto args = _argParseContext.readArguments(payload, neededArgs);

  const std::string instanceId = boost::lexical_cast<std::string>(args[placeholderIndex]);

  const auto instanceFinder = _instancesFound.lower_bound(instanceId);
  if (instanceFinder == _instancesFound.end() || *instanceFinder != instanceId)
  {
    // instanceFinder could not found the flow in _instancesFound
    // this means, this is the first encounter.

    _instancesFound.insert(instanceFinder, instanceId);

    entry::Event event(source, _argParseContext, std::move(activity));
    entry::FlowInstance flowInstance(instanceId, std::move(event));
    sink(flowInstance);
  } // else: this flow instance is already reported
}

} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/EventStream.C
#include <binlog/reader/EventStream.H>
#include <binlog/detail/EntryDefs.H> // ENTRY_TAG
#include <binlog/reader/entry/ThreadActivity.H>
#include <binlog/reader/entry/EventSource.H>

namespace binlog {
namespace reader {

EventStream::EventStream(detail::Consumable<Entry>& input)
  :EntryProcessorT(input)
{}

void EventStream::processThreadActivity(ThreadActivity& activity, SinkT& sink, std::error_code& ec)
{
  auto event = eventFromActivity(activity, ec);

  if (!ec) { sink(event); }
}

Event EventStream::eventFromActivity(ThreadActivity& activity, std::error_code& ec)
{
  auto sourceIt = _sources.find(activity.tag());
  if (sourceIt != _sources.end())
  {
    return Event(
      sourceIt->second,
      _argParseContext,
      std::move(activity)
    );
  }
  else
  {
    using namespace binlog::detail::error;
    setError(ec, Error::invalid_source_id) << activity.tag();
    return {};
  }
}

} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/TailEventStream.C
#include <cstdio>

#include <binlog/reader/TailEventStream.H>

namespace binlog {
namespace reader {

TailEventStream::TailEventStream(detail::Consumable<Entry>& input, std::size_t maxTailSize)
  :EventStream(input),
   _maxTailSize(maxTailSize)
{
  _tail.reserve(_maxTailSize);
}

void TailEventStream::processThreadActivity(ThreadActivity& activity, SinkT& sink, std::error_code& ec)
{
  if (_buffering)
  {
    if (_nextTailIndex < _tail.size())
    {
      using std::swap;
      swap(_tail[_nextTailIndex], activity);
    }
    else
    {
      _tail.push_back(std::move(activity));
    }

    _nextTailIndex = (_nextTailIndex + 1) % _maxTailSize;
  }
  else
  {
    EventStream::processThreadActivity(activity, sink, ec);
  }
}

void TailEventStream::endOfInput(SinkT& sink)
{
  // flush buffer collected so far
  std::error_code ec;
  for (std::size_t i = 0; i < _tail.size() && !ec; ++i)
  {
    auto&& activity = _tail[(_nextTailIndex + i) % _tail.size()];
   EventStream::processThreadActivity(activity, sink, ec);
  }

  if (ec)
  {
    fprintf(stderr, "[binlog] Failed to create event: %s\n", ec.message().c_str());
  }

  _tail.clear();

  // process subsequent events immediately
  _buffering = false;
}

} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/FileInputStream.C
#include <stdexcept>
#include <iostream>

#include <fcntl.h>  // open
#include <sys/inotify.h>
#include <limits.h> // NAME_MAX
#include <errno.h>  // errno
#include <stdio.h>  // perror
#include <unistd.h> // read, pread, lseek
#include <string.h> // strdup
#include <libgen.h> // dirname
#include <cassert>  // assert

#include <boost/algorithm/string.hpp>

#include <binlog/detail/Error.H>
#include <binlog/reader/FileInputStream.H>

namespace binlog {
namespace reader {

void openFile(const std::string& path, binlog::detail::Fd& result, std::error_code& ec)
{
  result = open(path.c_str(), O_RDONLY | O_NOATIME | O_LARGEFILE);

  if (! result && errno == EPERM)
  {
    // see man 2 open, EPERM if:
    // The O_NOATIME flag was specified, but the effective user ID of the caller did not
    // match the owner of the file and the caller was not privileged (CAP_FOWNER).

    result = open(path.c_str(), O_RDONLY | O_LARGEFILE);
  }

  if (! result)
  {
    using namespace binlog::detail::error;
    setError(ec, Error::file_open) << "'" << path << "', error: " << strerror(errno);
  }
}

namespace {

void printStatus(const char* msg)
{
  std::cout.flush();
  std::cerr << msg << std::endl;
}

} // namespace

//
// FileInputStream
//

FileInputStream::FileInputStream(const std::string& path, bool continuous)
  :_path(path),
   _continuous(continuous),
   _watch(-1),
   _dirWatch(-1)
{
  std::error_code ec;
  openFile(_path, _file, ec);
  if (ec && _continuous)
  {
    printStatus("File not found, wait...");
    if (waitForFile())
    {
      ec.clear();
      openFile(_path, _file, ec);
    }
  }

  if (ec)
  {
    throw std::system_error(ec);
  }
}

std::size_t FileInputStream::read(char* dst, std::size_t size)
{
  auto readRetval = ::read(*_file, dst, size);

  if (readRetval == -1)
  {
    perror("[binlog] read");
    return 0;
  }

  auto readSize = std::size_t(readRetval);

  if (readSize == size) { return readSize; } // OK, job done.

  assert(readSize < size);

  // failed to read enough bytes, wait if _continuous flag is set
  if (_continuous && waitForFile())
  {
    return readSize + read(dst+readSize, size - readSize);
  }

  return readSize;
}

FileInputStream::operator bool() const
{
  return _continuous || readAvailable();
}

bool FileInputStream::readAvailable() const
{
  char buffer;
  return pread(*_file, &buffer, 1, tellg()) == 1;
}

off_t FileInputStream::tellg() const
{
  return lseek(*_file, 0, SEEK_CUR);
}

bool FileInputStream::seekg(off_t index)
{
  return lseek(*_file, index, SEEK_SET) == index;
}

bool FileInputStream::waitForFile()
{
  while (_continuous)
  {
    if (! initInotify()) { return false; }

    enum { bufferSize = sizeof(inotify_event) + NAME_MAX + 1 };
    char buffer[bufferSize];

    // this blocks while IO event becomes available
    const ssize_t inotifyReadSize = ::read(*_inotify, buffer, bufferSize);
    if (inotifyReadSize == -1)
    {
      perror("[binlog] read inotify fd");
      return false;
    }

    char* pEvent = buffer;
    while (pEvent < buffer + inotifyReadSize)
    {
      // process inotify event
      auto&& event = reinterpret_cast<const inotify_event*>(pEvent);

      if (event->wd == _watch)
      {
        if (event->mask & IN_MODIFY)
        {
          removeWatch(_watch);
          return true;
        }
        else if (event->mask & IN_CLOSE_WRITE)
        {
          printStatus("File closed by writer, wait...");
        }
        else if (event->mask & (IN_DELETE_SELF | IN_MOVE_SELF))
        {
          printStatus("File disappeared, wait...");

          _file.close();
          removeWatch(_watch);

          // add dir watch
          if (! addDirWatch()) { return false; }

          // maybe the file is already there, try reopen
          std::error_code ec;
          openFile(_path, _file, ec);
          if (!ec)
          {
            // watch wasn't needed
            removeWatch(_dirWatch);

            readShebang();

            // continue reading
            return true;
          }
          // else
          // Let it pass, the new file is not yet there.
          // Adding the dir watch here would be too late,
          // we can miss the IN_CREATE event in the window.
        }
        else
        {
          fprintf(stderr, "[binlog] Unknown event for file watch: %d", event->mask);
        }
      }
      else if (event->wd == _dirWatch)
      {
        if ((event->mask & IN_CREATE) && boost::ends_with(_path, &event->name[0]))
        {
          // try reopen
          std::error_code ec;
          openFile(_path, _file, ec);
          if (!ec)
          {
            // not needed any more
            removeWatch(_dirWatch);

            readShebang();

            // continue reading
            return true;
          }
          // else
          // Damn, it's gone again.
          // Let it pass and wait for the next create event
        }
        // else: other event in the dir we are not interested
      }
      // else if: event->mask & IN_IGNORED
        // Generated by inotify_rm_watch, don't care
      // else:
        // Sometimes inotify falls back and reports events for already closed watches.
        // Ignore them for now.
        // fprintf(stderr, "[binlog] Unknown event for wd: %d, event: %d\n", event->wd, event->mask);

      // read next event
      pEvent += sizeof(inotify_event) + event->len;
    }
  }

  return false;
}

bool FileInputStream::initInotify()
{
  if (! _inotify) { _inotify = inotify_init(); }
  if (! _inotify)
  {
    perror("[binlog] inotify_init");
    _continuous = false;
    return false;
  }

  if (_watch < 0)
  {
    _watch = inotify_add_watch(
      *_inotify, _path.c_str(),
      IN_MODIFY | IN_CLOSE_WRITE | IN_DELETE_SELF | IN_MOVE_SELF
    );

    if (_watch < 0)
    {
      if (errno == ENOENT)
      {
        // no such file, try the directory
        return addDirWatch();
      }
      else
      {
        perror("[binlog] inotify_add_watch (1)");
        _continuous = false;
        return false;
      }
    }
  }

  return true;
}

bool FileInputStream::addDirWatch()
{
  char* path = strdup(_path.c_str());
  char* dir = dirname(path);

  _dirWatch = inotify_add_watch(
    *_inotify, dir,
    IN_CREATE | IN_ONLYDIR
  );

  free(path);

  if (_dirWatch < 0)
  {
    perror("[binlog] inotify_add_watch (2)");
    _continuous = false;
    return false;
  }

  return true;
}

bool FileInputStream::removeWatch(int& fd)
{
  // inotify_rm_watch has different signature
  // on different systems, this makes -Wsign-conversion
  // hard to humor, ignore it here.
  // Linux: 4ae8978cf92a96257cd8998a49e781be83571d64
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wsign-conversion"

  // And Now His Watch Is Ended
  bool ok = inotify_rm_watch(*_inotify, fd) == 0;
  fd = -1;
  return ok;

  #pragma GCC diagnostic pop
}

} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/FlowNameStream.C
#include <algorithm>

#include <binlog/reader/FlowNameStream.H>

namespace binlog {
namespace reader {

FlowNameStream::FlowNameStream(detail::Consumable<Entry>& input)
  :EntryProcessorT(input)
{}

void FlowNameStream::processEventSource(EventSource& eventSource, SinkT& sink)
{
  auto namedPlaceholders = eventSource.parsedFormatString().getNamedPlaceholders();
  if (namedPlaceholders.empty() == false)
  {
    for (auto&& placeholder : namedPlaceholders)
    {
      auto&& flowName = placeholder.second;
      auto&& finder = std::find(_flowNames.begin(), _flowNames.end(), flowName);
      if (finder == _flowNames.end())
      {
        // flow name not yet seen
        _flowNames.push_back(flowName);
        sink(flowName);
      }
    }
  }
}

} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/FlowEventStream.C
#include <binlog/reader/FlowEventStream.H>

namespace binlog {
namespace reader {

FlowEventStream::FlowEventStream(
  detail::Consumable<Entry>& input,
  const std::string& flowName,
  const std::string& flowId
)
  :EventStream(input),
   _flowName(flowName),
   _flowId(flowId)
{}

void FlowEventStream::processEventSource(EventSource& eventSource, SinkT& sink)
{
  auto namedPlaceholders = eventSource.parsedFormatString().getNamedPlaceholders();
  for (auto&& placeholder : namedPlaceholders)
  {
    if (placeholder.second == _flowName)
    {
      // this event source is part of our flow
      _flowSources.insert({eventSource.sourceId(), placeholder.first});

      break; // not interested in other flows
    }
  }

  EventStream::processEventSource(eventSource, sink);
}

void FlowEventStream::processThreadActivity(ThreadActivity& activity, SinkT& sink, std::error_code& ec)
{
  bool threadInFlow = _inFlow.count(activity.threadId()) > 0;
  bool sourceInFlow = false;
  bool matchingFlow = false;
  bool endOfFlow    = false;

  auto sourceFinder = _flowSources.find(activity.tag());
  if (sourceFinder != _flowSources.end())
  {
    sourceInFlow = true;

    auto&& source = _sources.at(activity.tag());
    endOfFlow = source.isFlowEnd();

    // get the argument pointed by sourceFinder->second
    auto payload = activity.payload();
    const std::string neededArgs = source.typeCodes().substr(0, sourceFinder->second + 1);
    auto args = _argParseContext.readArguments(payload, neededArgs);
    auto&& actualFlowId = args[sourceFinder->second];

    // check for match
    matchingFlow = (_flowId == actualFlowId);
  } // else: sourceInFlow = false remains

  if (threadInFlow)
  {
    if (matchingFlow || ! sourceInFlow)
    {
      sinkEvent(activity, sink, ec);
    }
    else
    {
      endOfFlow = true;
    }

    if (endOfFlow)
    {
      // turn off thread
      _inFlow.erase(activity.threadId());
    }
  }
  else if (matchingFlow)
  {
    // turn thread on
    _inFlow.insert(activity.threadId());

    sinkEvent(activity, sink, ec);
  }
}

void FlowEventStream::sinkEvent(ThreadActivity& activity, SinkT& sink, std::error_code& ec)
{
  auto event = eventFromActivity(activity, ec);

  if (!ec) { sink(event); }
}

} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/FlowGroupedEventStream.C
#include <algorithm>

#include <boost/lexical_cast.hpp>

#include <binlog/reader/FlowGroupedEventStream.H>

namespace binlog {
namespace reader {

FlowGroupedEventStream::FlowGroupedEventStream(
  detail::Consumable<Entry>& input,
  const std::string& flowName
)
  :EventStream(input),
   _flowName(flowName),
   _currentAge(0),
   _lastThreadIdSeen(0),
   _threadState(nullptr),
   _latestEmittedTsc(0)
{}

void FlowGroupedEventStream::processEventSource(EventSource& eventSource, SinkT& sink)
{
  auto namedPlaceholders = eventSource.parsedFormatString().getNamedPlaceholders();
  for (auto&& placeholder : namedPlaceholders)
  {
    if (placeholder.second == _flowName)
    {
      // this event source is part of our flow
      _flowSources.insert({eventSource.sourceId(), placeholder.first});

      break; // not interested in other flows
    }
  }

  EventStream::processEventSource(eventSource, sink);
}

void FlowGroupedEventStream::processThreadActivity(ThreadActivity& activity, SinkT& sink, std::error_code& ec)
{
  Event event = eventFromActivity(activity, ec);

  if (ec) { return; }

  auto threadId = event.threadId();

  if (threadId != _lastThreadIdSeen)
  {
    switchBatch(threadId, sink);
  }

  bool threadInFlow = (_threadState && _threadState->pFlowInstance);
  bool sourceInFlow = false;
  bool matchingFlow = false;
  std::string actualFlowId; // only valid if sourceInFlow == true

  auto sourceFinder = _flowSources.find(event.source().sourceId());
  if (sourceFinder != _flowSources.end())
  {
    sourceInFlow = true;

    // check for match
    actualFlowId = boost::lexical_cast<std::string>(event.arguments()[sourceFinder->second]);
    matchingFlow = _threadState && (_threadState->flowId == actualFlowId);
  }

  if (sourceInFlow)
  {
    if (! (threadInFlow && matchingFlow))
    {
      // change flow of thread
      _threadState->flowId = actualFlowId;
      _threadState->pFlowInstance = &(_activeFlows[actualFlowId]);
    }
  }
  else if ( ! threadInFlow)
  {
    // this event belongs to no flow
    _noflowEvents.push_back(std::move(event));
    return;
  }

  // add event to flow of thread
  _threadState->pFlowInstance->addEvent(std::move(event), _currentAge);

  if (_threadState && event.source().isFlowEnd())
  {
    // end of this flow instance on this thread
    _threadState->reset();
  }
}

void FlowGroupedEventStream::endOfInput(SinkT& sink)
{
  // no more input, flush all
  std::vector<FlowMap::iterator> remaining;
  for (auto flowIt = _activeFlows.begin(); flowIt != _activeFlows.end(); ++flowIt)
  {
    remaining.push_back(flowIt);
  }
  flushFlows(remaining, sink);

  // flush _noflowEvents
  for (auto&& event : _noflowEvents)
  {
    sink(event);
  }
}

void FlowGroupedEventStream::FlowInstanceState::addEvent(
  entry::Event event, std::size_t threadAge
)
{
  latestTsc = std::max(latestTsc, event.tsc());
  events.push_back(std::move(event));
  age = threadAge;
}

void FlowGroupedEventStream::ThreadState::reset()
{
  flowId.clear();
  pFlowInstance = nullptr;
  age = 0;
}

void FlowGroupedEventStream::switchBatch(const ThreadActivity::ThreadId& to, SinkT& sink)
{
  if (_threadState)
  {
    // flush flows older than age of this thread
    // (this age reflects the previous batch of this thread)
    flushOldUnusedFlows(_threadState->age, sink);

    _threadState->age = _currentAge;
  }

  _lastThreadIdSeen = to;

  ++_currentAge;
  _threadState = &(_activeThreads[to]);
}

void FlowGroupedEventStream::flushOldUnusedFlows(std::size_t minAge, SinkT& sink)
{
  auto victim = [this, minAge](const FlowMap::value_type& flowMapV)
  {
    // not a victim if recently used flow
    if (flowMapV.second.age >= minAge)
    {
      return false;
    }

    // not a victim if latest entry is too young
    auto tscDiff = flowMapV.second.latestTsc - _latestEmittedTsc;
    if (tscDiff < 10000000) // ~0.005 sec on 2 GHz
    {
      return false;
    }

    // not a victim if there is a thread with this flow
    for (auto&& threadState : _activeThreads)
    {
      if (threadState.second.pFlowInstance == &flowMapV.second)
      {
        return false;
      }
    }

    return true; // it's a victim
  };

  // find victims
  std::vector<FlowMap::iterator> victims;

  auto flowIt = _activeFlows.begin();
  while ((flowIt = std::find_if(flowIt, _activeFlows.end(), victim)) != _activeFlows.end())
  {
    victims.push_back(flowIt++);
  }

  // flush victims
  flushFlows(victims, sink);

  // remove victims
  for (auto&& flowIt : victims)
  {
    _activeFlows.erase(flowIt);
  }
}

void FlowGroupedEventStream::flushFlows(
  std::vector<FlowMap::iterator>& instances, SinkT& sink
)
{
  auto ascendingEvents = [](const Event& a, const Event& b)
  {
    return a.tsc() < b.tsc();
  };

  // sort events in flows
  for (auto&& instanceIt : instances)
  {
    auto& events = instanceIt->second.events;

    // sort events of flow by timestamp (ascending)
    std::stable_sort(events.begin(), events.end(), ascendingEvents);
  }

  // sort instances by first event timestamp
  auto ascending = [](const FlowMap::iterator& a, const FlowMap::iterator& b)
  {
    return a->second.events[0].tsc() < b->second.events[0].tsc();
  };

  std::stable_sort(instances.begin(), instances.end(), ascending);

  // update latest TSC seen
  for (auto&& instance : instances)
  {
    _latestEmittedTsc = std::max(
      _latestEmittedTsc, instance->second.events.back().tsc()
    );
  }

  // sort _noflowEvents, lower_bound will be used
  std::stable_sort(_noflowEvents.begin(), _noflowEvents.end(), ascendingEvents);

  // sink events
  for (auto&& instanceIt : instances)
  {
    // sink noflow events happened before this instance
    auto victimNoflowEnd = std::lower_bound(
      _noflowEvents.begin(), _noflowEvents.end(),
      instanceIt->second.events[0], ascendingEvents
    );

    auto noflowIt = _noflowEvents.begin();
    for(; noflowIt != victimNoflowEnd; ++noflowIt)
    {
      _latestEmittedTsc = std::max(_latestEmittedTsc, noflowIt->tsc());
      sink(*noflowIt);
    }

    _noflowEvents.erase(_noflowEvents.begin(), victimNoflowEnd);

    // sink events of the flow instance
    for (auto&& event : instanceIt->second.events)
    {
      sink(event);
    }
  }
}

} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/EntryStream.C
#include <binlog/reader/EntryStream.H>

namespace binlog {
namespace reader {

EntryStream::EntryStream(detail::InputStream& input)
  :_input(&input)
{
  input.readShebang(); // discard shebang
}

void EntryStream::consume(Callback consumer, ErrorHandler handleError)
{
  while (*_input)
  {
    std::error_code ec;
    Entry entry(*_input, ec);

    if (!ec)
    {
      consumer(entry);
    }
    else if (ec == binlog::detail::Error::end_of_stream) { return; }
    else
    {
      handleError(ec);
      return;
    }
  }
}

void EntryStream::replaceInput(detail::InputStream& input)
{
  _input = &input;
}

} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/EventSourceStream.C
#include <cstdint>
#include <vector>
#include <stdexcept>
#include <string>
#include <algorithm>
#include <iostream>

#include <binlog/detail/Elf.H>
#include <binlog/detail/Error.H>
#include <binlog/reader/EventSourceStream.H>
#include <binlog/reader/detail/Buffer.H>
#include <binlog/reader/detail/SourceLocation.H>

namespace binlog {
namespace reader {

namespace {

struct Descriptor
{
  uint32_t messagePtr;
  uint32_t iaddr;
};

std::vector<Descriptor> getDescriptors(binlog::detail::ElfSection& descSec, std::error_code& ec)
{
  std::vector<Descriptor> descriptors;

  std::size_t dataSize = 0;
  const char* data = reinterpret_cast<const char*>(descSec.data(dataSize, ec));

  const uint32_t* first = reinterpret_cast<const uint32_t*>(data);
  const uint32_t* last  = reinterpret_cast<const uint32_t*>(data + dataSize);

 for (; first + 1 < last; first += 2)
  {
    descriptors.push_back({*first, *(first+1)});
  }

  return descriptors;
}

std::vector<detail::SourceLocation> getLocations(
  const std::string& path,
  const std::vector<Descriptor>& descriptors
)
{
  std::vector<void*> iaddresses;
  iaddresses.reserve(descriptors.size());

  for (auto& desc : descriptors)
  {
    iaddresses.push_back(reinterpret_cast<void*>(desc.iaddr));
  }

  return detail::getSourceLocationsByAddrs(path, iaddresses);
}

} // namespace

EventSourceStream::EventSourceStream(const binlog::detail::Elf& elf)
  :_elf(elf)
{}

void EventSourceStream::consume(SinkT sink, ErrorHandler handleError)
{
  std::error_code ec;

  // category section
  auto secCategory = _elf.getSection(".ms.log.category", ec);
  std::size_t catDataSize = 0;
  auto catData = secCategory.data(catDataSize, ec);
  auto catBuffer = reinterpret_cast<char*>(catData);

  // message section
  auto secMessage  = _elf.getSection(".ms.log.message", ec);
  std::size_t msgDataSize = 0;
  void* msgData = secMessage.data(msgDataSize, ec);
  char* msgBuffer = reinterpret_cast<char*>(msgData);

  // descriptor section
  auto descSec = _elf.getSection(".ms.log.descriptor", ec);
  auto descriptors = getDescriptors(descSec, ec);

  if (descriptors.empty() || ec)
  {
    if(ec != binlog::detail::Error::not_binlog_user)
    {
      handleError(ec);
    }
    return;
  }

  // initial source id
  entry::EventSource::tag_t sourceId = (_elf.loadAddress() + descSec.address(ec)) >> 3;

  // get source locations
  auto locations = getLocations(_elf.path(), descriptors);

  // add end guard
  descriptors.push_back({static_cast<uint32_t>(msgDataSize), 0});

  for (std::size_t i = 0; i < descriptors.size() - 1; ++i)
  {
    using namespace binlog::detail::error;

    // Create reader
    uint32_t bufferSize = descriptors[i + 1].messagePtr - descriptors[i].messagePtr;
    detail::ReadBuffer reader(msgBuffer + descriptors[i].messagePtr, bufferSize);

    // Get category and severity
    uint16_t cat = 0;
    detail::serialize(reader, cat, ec, Error::no_ess_category_id);

    Severity severity = unknown;
    detail::serialize(reader, severity, ec, Error::no_ess_severity);

    // Get type codes
    std::string typeCodes;
    detail::serialize(reader, typeCodes, ec, Error::no_ess_type_tags);

    // Get format string
    std::string formatString;
    detail::serialize(reader, formatString, ec, Error::no_ess_format_string);

    if (ec)
    {
      fprintf(stderr,
        "[binlog] Failed to read event source from ELF: '%s', error: %s\n",
        _elf.path().c_str(), ec.message().c_str());
      handleError(ec);
      return;
    }

    std::string category(&catBuffer[cat]);
    std::string categoryName(&catBuffer[cat + category.size() + 1]);

    entry::EventSource eventSource(
      sourceId++,
      reinterpret_cast<void*>(descriptors[i].iaddr),
      categoryName,
      severity,
      formatString,
      typeCodes,
      locations[i]
    );

    sink(eventSource);
  }
}

} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/detail/CompressedFileInputStream.C
#include <fcntl.h>  // open
#include <stdexcept>

#include <binlog/reader/detail/CompressedFileInputStream.H>
#include <binlog/reader/FileInputStream.H> // openFile

namespace binlog {
namespace reader {
namespace detail {

CompressedFileInputStream::CompressedFileInputStream(const std::string& path)
{
  std::error_code ec;
  openFile(path, _file, ec);
  if (ec) { throw std::system_error(ec); }

  int gzd = dup(*_file);
  _gzFile = gzdopen(gzd, "rb");

  if (! _gzFile)
  {
    close(gzd);
    int errnum;
    throw std::runtime_error(
      "Gzip error in file: '" + path + std::string("': ") +
      gzerror(_gzFile, &errnum)
    );
  }
}

CompressedFileInputStream::~CompressedFileInputStream()
{
  gzclose_r(_gzFile);
}

off_t CompressedFileInputStream::tellg() const
{
  return gztell(_gzFile);
}

bool CompressedFileInputStream::seekg(off_t index)
{
  return gzseek(_gzFile, index, SEEK_SET) == index;
}

std::size_t CompressedFileInputStream::read(char* dst, std::size_t size)
{
  int rsize = gzread(_gzFile, dst, unsigned(size));
  if (rsize >= 0)
  {
    return std::size_t(rsize);
  }
  else
  {
    int errnum;
    const char* err = gzerror(_gzFile, &errnum);
    fprintf(stderr, "Gzip error: '%s' (%d)\n", err, errnum);
    return 0;
  }
}

} // namespace detail
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/detail/MmapInputStream.C
#include <stdexcept>
#include <cstring> // strerror, memcpy

#include <sys/mman.h>

#include <binlog/reader/detail/MmapInputStream.H>
#include <binlog/reader/FileInputStream.H> // openFile

namespace binlog {
namespace reader {
namespace detail {

MmapInputStream::MmapInputStream(const std::string& path)
{
  std::error_code ec;
  openFile(path, _file, ec);
  if (ec) { throw std::system_error(ec); }

  off_t fileSize = lseek(*_file, 0, SEEK_END);
  if (fileSize < 0)
  {
    throw std::runtime_error("Failed to get file size");
  }

  _bufferSize = size_t(fileSize);
  if (_bufferSize) // mmap doesn't like 0 size
  {
    const void* map = mmap64(
      nullptr, _bufferSize,
      PROT_WRITE,
      MAP_POPULATE | MAP_PRIVATE,
      *_file, 0
    );

    if (map == MAP_FAILED)
    {
      throw std::runtime_error(
        "Failed to mmap file: '" + path + std::string("', ") + strerror(errno)
      );
    }

    _current = _buffer = static_cast<const char*>(map);
  }
}

MmapInputStream::MmapInputStream(MmapInputStream&& rhs)
  :_file(std::move(rhs._file)),
   _buffer(rhs._buffer),
   _current(rhs._current),
   _bufferSize(rhs._bufferSize)
{
  rhs._buffer = nullptr;
  rhs._bufferSize = 0;
}

MmapInputStream::~MmapInputStream()
{
  if (_buffer)
  {
    munmap(const_cast<char*>(_buffer), _bufferSize);
  }
}

MmapInputStream::operator bool() const
{
  return _current < _buffer + _bufferSize;
}

off_t MmapInputStream::tellg() const
{
  return _current - _buffer;
}

bool MmapInputStream::seekg(off_t index)
{
  std::size_t offset = std::size_t(index);
  if (offset > _bufferSize)
  {
    return false;
  }

  _current = _buffer + offset;
  return true;
}

std::size_t MmapInputStream::read(char* dst, std::size_t size)
{
  const std::size_t readAvail = std::size_t(_buffer - _current) + _bufferSize;
  const std::size_t readSize = (std::min)(size, readAvail);

  std::memcpy(dst, _current, readSize);
  _current += readSize;
  return readSize;
}

bool MmapInputStream::read(Buffer&, ReadBuffer& reader, std::size_t size)
{
  if (_current + size > _buffer + _bufferSize)
  {
    return false;
  }

  reader = ReadBuffer(_current, size);
  _current += size;
  return true;
}

} // namespace detail
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/detail/StructDefinitionStream.C
#include <cstdio>

#include <binlog/detail/Elf.H>
#include <binlog/reader/detail/StructDefinitionStream.H>
#include <binlog/reader/detail/Buffer.H>

namespace binlog {
namespace reader {
namespace detail {

StructDefinitionStream::StructDefinitionStream(const binlog::detail::Elf& elf)
  :_elf(elf)
{}

void StructDefinitionStream::consume(SinkT sink, ErrorHandler handleError)
{
  std::error_code ec;

  auto secDescriptor = _elf.getSection(".ms.log.struct", ec);
  if (ec)
  {
    // no structures section, object doesn't log structs
    // or object doesn't use binlog: nothing to do.
    return;
  }

  auto elfOffset = secDescriptor.address(ec) + _elf.loadAddress();

  std::size_t dataSize = 0;
  auto data = static_cast<const char*>(secDescriptor.data(dataSize, ec));

  ReadBuffer reader(data, dataSize);
  auto secOffset = reader.get();

  while (reader.size())
  {
    auto structDefId = std::size_t(elfOffset + reader.get() - secOffset);
    entry::StructDefinition structDef(structDefId, reader, ec);
    if (ec) { break; }
    sink(structDef);
  }

  if (ec)
  {
    fprintf(stderr, "[binlog] Failed to extract struct definitions from ELF: %s\n",
      ec.message().c_str());
    handleError(ec);
    return;
  }
}

} // namespace detail
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/detail/SourceLocation.C
#include <memory> // std::unique_ptr

#define HAVE_DECL_BASENAME 1 // prevent libiberty.h to incorrectly declare basename
#include <demangle.h> // DMGL_*

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wsign-conversion"
#include <bfd.h>
#pragma GCC diagnostic pop

#include <boost/algorithm/string/predicate.hpp> // ends_with

#include <binlog/reader/detail/SourceLocation.H>

namespace {

struct BfdInitGuard
{
  BfdInitGuard()
  {
    bfd_init();
  }
};

BfdInitGuard g_bfdInitGuard;

using binlog::reader::detail::SourceLocation;

SourceLocation unknownSourceLocation()
{
  return SourceLocation{"?", "?", 0u};
}

struct FreeDeleter
{
  void operator()(const void* p) const { if(p) { free(const_cast<void*>(p)); } }
};

class Section
{
public:
  Section(bfd_vma addrBegin, bfd_vma size, asection* section)
    :_addrBegin(addrBegin),
     _addrEnd(addrBegin + size),
     _section(section)
  {}

  bool contains(void* addr) const
  {
    auto a = bfd_vma(addr);
    return _addrBegin <= a && a < _addrEnd;
  }

  SourceLocation resolveAddr(bfd* abfd, void* addr)
  {
    if (! _symtable)
    {
      initSymtable(abfd);
      if (! _symtable)
      {
        _addrBegin = 0;
        _addrEnd = 0;
        return unknownSourceLocation();
      }
    }

    const char* file = nullptr;
    const char* func = nullptr;
    unsigned line;
    const bool ok = bfd_find_nearest_line(
      abfd, _section, _symtable.get(), bfd_vma(addr) - _addrBegin,
      & file, & func, & line
    );

    if (!ok || !file || !func) { return unknownSourceLocation(); }

    getInlinerOfFunctionGuard(abfd, & file, & func, & line);

    // try demangle function name
    std::unique_ptr<const char, FreeDeleter> demangledFuncPtr(
      bfd_demangle(abfd, func, DMGL_PARAMS | DMGL_TYPES | DMGL_RET_DROP));
    if (demangledFuncPtr) { func = demangledFuncPtr.get(); }

    return SourceLocation{func, file, line};
  }

private:
  void initSymtable(bfd* abfd)
  {
    void* syms = nullptr;
    unsigned int size;
    bfd_read_minisymbols(abfd, false, & syms, & size);
    _symtable.reset(reinterpret_cast<bfd_symbol**>(syms));
  }

  void getInlinerOfFunctionGuard(bfd* abfd, const char** file, const char** func, unsigned* line)
  {
    if (boost::algorithm::ends_with(*file, "binlog/FunctionGuard.H"))
    {
      bfd_find_inliner_info(abfd, file, func, line);
    }
  }

  bfd_vma _addrBegin;
  bfd_vma _addrEnd;
  asection* _section;
  std::unique_ptr<bfd_symbol*, FreeDeleter> _symtable;
};

void addSection(bfd* abfd, asection* section, void* vsections)
{
  if ((bfd_get_section_flags(abfd, section) & SEC_ALLOC) == 0)
  {
    return;
  }

  auto* sections = reinterpret_cast<std::vector<Section>*>(vsections);
  sections->emplace_back(
    bfd_get_section_vma(abfd, section),
    bfd_get_section_size(section),
    section
  );
}

std::vector<Section> getSections(bfd* abfd)
{
  std::vector<Section> sections;
  sections.reserve(bfd_count_sections(abfd));

  bfd_map_over_sections(abfd, addSection, & sections);

  return sections;
}

void resolveAddresses(
  bfd* abfd,
  const std::vector<void*>& addrs,
  std::vector<SourceLocation>& result
)
{
  std::vector<Section> sections = getSections(abfd);

  for (void* addr : addrs)
  {
    for (auto&& section : sections)
    {
      if (section.contains(addr))
      {
        result.push_back(section.resolveAddr(abfd, addr));
      }
    }
  }
}

} // namespace

namespace binlog {
namespace reader {
namespace detail {

std::vector<SourceLocation> getSourceLocationsByAddrs(
  const std::string& objectFilePath,
  const std::vector<void*>& addrs
)
{
  bfd* abfd = bfd_openr(objectFilePath.c_str(), nullptr);

  std::vector<SourceLocation> result;
  result.reserve(addrs.size());

  if (abfd)
  {
    bfd_set_default_target("elf64-x86-64"); // optional, speed up loads
    bfd_set_file_flags(abfd, BFD_DECOMPRESS);
    bfd_check_format(abfd, bfd_object); // mandatory check, loads actual data
    resolveAddresses(abfd, addrs, result);

    bfd_close(abfd);
  }

  result.resize(addrs.size(), unknownSourceLocation());

  return result;
}

} // namespace detail
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/detail/InputStream.C
#include <binlog/reader/detail/InputStream.H>

namespace binlog {
namespace reader {
namespace detail {

std::string InputStream::readShebang()
{
  if (tellg() != 0) { return std::string(); }

  char mark[2] = {0, 0};

  if (read(mark, 2) != 2 || mark[0] != '#' || mark[1] != '!')
  {
    seekg(0);
    return std::string();
  }

  std::string result = "#!";

  // read until \n
  enum { BUF_SIZE = 128 }; // Matches the usual max shebang size
  char buffer[BUF_SIZE];
  char* delimPos = nullptr;
  std::size_t readSize = 0;

  while (delimPos == nullptr && (readSize = read(buffer, BUF_SIZE)))
  {
    delimPos = static_cast<char*>(memchr(buffer, '\n', readSize));
    if (delimPos != nullptr)
    {
      off_t ignoreSize = delimPos - buffer;
      off_t seekBack = off_t(readSize) - ignoreSize - 1;
      seekg(tellg() - seekBack);

      result.append(buffer, delimPos + 1);
    }
    else
    {
      result.append(buffer, readSize);
    }
  }

  return result;
}

} // namespace detail
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/detail/DeserializedArray.C
#include <algorithm>

#include <binlog/detail/ArrayWrapper.H>
#include <binlog/detail/Error.H>

#include <binlog/reader/detail/Buffer.H>
#include <binlog/reader/detail/DeserializedArray.H>
#include <binlog/reader/detail/ArgumentParseContext.H>

namespace binlog {
namespace reader {
namespace detail {

DeserializedArray::DeserializedArray(
  const ArgumentParseContext& apc, ReadBuffer& reader, std::error_code& ec
)
{
  using namespace binlog::detail::error;
  typedef binlog::detail::ArrayWrapper<int>::aw_size_t aw_size_t;

  aw_size_t size = 0;
  char typeSpec = 0;

  checkTrue(reader.read(size), ec, Error::no_array_size);
  checkTrue(reader.read(typeSpec), ec, Error::no_array_type_spec);

  if (ec) { return; }

  _data.reserve(size);

  for (aw_size_t i = 0; i < size; ++i)
  {
    Argument item = detail::readArgument(apc, reader, typeSpec);
    _data.push_back(std::move(item));
  }
}

namespace {

struct CharArgumentPrinter : public boost::static_visitor<>
{
  CharArgumentPrinter(std::ostream& out) : _out(out) {}

  template <typename T>
  void operator()(const T& c)
  {
    _out << c;
  }

private:
  std::ostream& _out;
};

void writeCharArray(std::ostream& out, const std::vector<Argument>& args)
{
  CharArgumentPrinter cap(out);
  auto capv = boost::apply_visitor(cap);
  std::for_each(args.begin(), args.end(), capv);
}

void writeGenericArray(std::ostream& out, const std::vector<Argument>& args)
{
  out << '[';

  bool first = true;

  for (auto&& arg : args)
  {
    if (!first)
    {
      out << ", ";
    }
    else
    {
      first = false;
    }

    out << arg;
  }

  out << ']';
}

} // namespace

std::ostream& operator<<(std::ostream& out, const DeserializedArray& da)
{
  IsPrintableArgument isPrintableArgument;
  auto isPrintable = boost::apply_visitor(isPrintableArgument);

  if (std::all_of(da._data.begin(), da._data.end(), isPrintable))
  {
    writeCharArray(out, da._data);
  }
  else
  {
    writeGenericArray(out, da._data);
  }

  return out;
}

} // namespace detail
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/detail/Argument.C
#include <sstream>

#include <binlog/detail/Arguments.H>
#include <binlog/detail/Error.H>

#include <binlog/reader/detail/Argument.H>
#include <binlog/reader/detail/DeserializedStruct.H>
#include <binlog/reader/detail/DeserializedArray.H>
#include <binlog/reader/detail/DeserializedTuple.H>
#include <binlog/reader/detail/ArgumentParseContext.H>

namespace binlog {
namespace reader {
namespace detail {

// Read

namespace {

using namespace binlog::detail;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"

template <typename T>
void read(const ArgumentParseContext&, ReadBuffer& in, Argument& out, std::error_code& ec)
{
  T arg;
  if (checkTrue(in.read(arg), ec, Error::payload_too_short))
  {
    out = arg;
  }
}

template <>
void read<std::string>(const ArgumentParseContext&, ReadBuffer& in, Argument& out, std::error_code& ec)
{
  std::string arg;
  if (checkTrue(in.readline(arg, '\0'), ec, Error::no_string_arg))
  {
    out = arg;
  }
}

template <>
void read<structure_type_tag>(const ArgumentParseContext& apc, ReadBuffer& in, Argument& out, std::error_code& ec)
{
  auto deserializedStruct = apc.readStructure(in, ec);
  if (!ec) { out = std::move(deserializedStruct); }
}

template <>
void read<array_type_tag>(const ArgumentParseContext& apc, ReadBuffer& in, Argument& out, std::error_code& ec)
{
  DeserializedArray da(apc, in, ec);
  if (!ec) { out = std::move(da); }
}

template <>
void read<tuple_type_tag>(const ArgumentParseContext& apc, ReadBuffer& in, Argument& out, std::error_code& ec)
{
  DeserializedTuple dt(apc, in, ec);
  if (!ec) { out = std::move(dt); }
}

template <>
void read<variant_type_tag>(const ArgumentParseContext& apc, ReadBuffer& in, Argument& out, std::error_code& ec)
{
  char typeSpec;
  if (checkTrue(in.read(typeSpec), ec, Error::no_variant_type_spec))
  {
    out = readArgument(apc, in, typeSpec);
  }
}

template <>
void read<null_type_tag>(const ArgumentParseContext&, ReadBuffer&, Argument& out, std::error_code&)
{
  out = NullArgument();
}

#pragma GCC diagnostic pop

} // namespace

Argument readArgument(
  const ArgumentParseContext& apc, ReadBuffer& in, const char typeSpec
)
{
  #define BINLOG_TYPE_SWITCH_BODY(TYPE) detail::read<TYPE>(apc, in, result, ec);

  Argument result(ReadError{});
  std::error_code ec;

  switch (typeSpec)
  {
    BINLOG_TYPE_SWITCH
  default:
    setError(ec, Error::invalid_type_tag);
    break;
  }

  if (ec)
  {
    fprintf(stderr, "[binlog] readArgument error: %s\n", ec.message().c_str());
  }

  return result;

  #undef BINLOG_TYPE_SWITCH_BODY
}

// Write

namespace {

struct ArgumentPrinter : public boost::static_visitor<>
{
  ArgumentPrinter(std::ostream& out) : _out(out) {}

  template <typename T>
  void operator()(const T& field)
  {
    _out << field;
  }

  void operator()(const bool& b)
  {
    b ? _out << "true"
      : _out << "false";
  }

  void operator()(const unsigned char& c)
  {
     _out << static_cast<unsigned int>(c);
  }

  void operator()(const signed char& c)
  {
     _out << static_cast<int>(c);
  }

  void operator()(const ReadError&)
  {
    _out << "{ReadError}";
  }

  void operator()(const NullArgument&)
  {
    _out << "{null}";
  }

private:
  std::ostream& _out;
};

} // namespace

std::ostream& operator<<(std::ostream& out, const Argument& arg)
{
  ArgumentPrinter printer(out);
  boost::apply_visitor(printer, arg);
  return out;
}

} // namespace detail
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/detail/DeserializedTuple.C
#include <binlog/detail/Error.H>

#include <binlog/reader/detail/Buffer.H>
#include <binlog/reader/detail/DeserializedTuple.H>
#include <binlog/reader/detail/ArgumentParseContext.H>

namespace binlog {
namespace reader {
namespace detail {

DeserializedTuple::DeserializedTuple(
  const ArgumentParseContext& apc, ReadBuffer& reader, std::error_code& ec
)
{
  using namespace binlog::detail::error;

  unsigned char tupleSize = 0;
  checkTrue(reader.read(tupleSize), ec, Error::no_tuple_size);

  std::vector<char> typeSpecs;
  typeSpecs.reserve(tupleSize);

  for (char i = 0; i < tupleSize; ++i)
  {
    char typeSpec = 0;
    checkTrue(reader.read(typeSpec), ec, Error::no_tuple_type_spec);
    typeSpecs.push_back(typeSpec);
  }

  if (ec) { return; }

  _data.reserve(tupleSize);

  for (auto&& typeSpec : typeSpecs)
  {
    Argument element = detail::readArgument(apc, reader, typeSpec);
    _data.push_back(std::move(element));
  }
}

std::ostream& operator<<(std::ostream& out, const DeserializedTuple& dt)
{
  out << '(';

  bool first = true;

  for (auto&& item : dt._data)
  {
    if (!first)
    {
      out << ", ";
    }
    else
    {
      first = false;
    }

    out << item;
  }

  out << ')';

  return out;
}

} // namespace detail
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/detail/FormatString.C
#include <stdexcept>
#include <ostream>

#include <boost/algorithm/string/replace.hpp>

#include <binlog/reader/detail/FormatString.H>

namespace binlog {
namespace reader {
namespace detail {

FormatItem::FormatItem(std::size_t pos)
  :_pos(pos)
{}

StaticFormatItem::StaticFormatItem(const std::string& staticData, std::size_t pos)
  :FormatItem(pos),
   _staticData(staticData)
{
  boost::replace_all(_staticData, "{{", "{");
  boost::replace_all(_staticData, "}}", "}");
}

void StaticFormatItem::toString(const std::vector<Argument>&, std::ostream& out) const
{
  out << _staticData;
}

ArgumentFormatItem::ArgumentFormatItem(std::size_t argIndex, std::size_t pos)
  :FormatItem(pos),
   _argIndex(argIndex)
{}

void ArgumentFormatItem::toString(const std::vector<Argument>& args, std::ostream& out) const
{
  if (_argIndex < args.size())
  {
    out << args[_argIndex];
  }
  else
  {
    out << "N/A";
  }
}

NamedArgumentFormatItem::NamedArgumentFormatItem(
  std::size_t argIndex, std::size_t pos, const std::string& name
)
  :ArgumentFormatItem(argIndex, pos),
   _name(name)
{}

ParsedFormat::ParsedFormat(const std::string& format)
{
  std::size_t index = 0;
  std::size_t chunkStart = 0;

  while (index < format.size())
  {
    // find next {
    const auto braceIndex = format.find('{', index);

    if (braceIndex != std::string::npos)
    {
      // { found
      const auto placeholderStart = braceIndex + 1;
      if (placeholderStart < format.size())
      {
        if (format[placeholderStart] != '{')
        {
          auto closingBraceIndex = format.find('}', placeholderStart);

          if (closingBraceIndex != std::string::npos)
          {
            const std::string placeholder = format.substr(placeholderStart, closingBraceIndex - placeholderStart);
            std::size_t argEndPos = 0;
            std::size_t argIndex = 0;

            try
            {
              argIndex = std::stoull(placeholder, & argEndPos);
            }
            catch (const std::exception&)
            {
              // failed to parse {argIndex}, skip it
              argEndPos = 0;
            }

            if (argEndPos && (argEndPos == placeholder.size() || placeholder[argEndPos] == ':'))
            {
              // add previous static
              _items.emplace_back(new StaticFormatItem(
                format.substr(chunkStart, braceIndex - chunkStart),
                chunkStart
              ));
              chunkStart = closingBraceIndex + 1;

              if (argEndPos == placeholder.size())
              {
                // unnamed placeholder
                _items.emplace_back(new ArgumentFormatItem(argIndex, braceIndex));
              }
              else
              {
                // named placeholder
                const std::string argName = placeholder.substr(argEndPos + 1); // +1: consume `:`
                _items.emplace_back(new NamedArgumentFormatItem(argIndex, braceIndex, argName));
              }
            } // else: conversion error or number was not fully parsed

            index = closingBraceIndex + 1; // consume placeholder
          }
          else
          {
            // unbalanced {, add the rest
            break;
          }
        }
        else
        {
          // escape sequence: {{, move on
          index = placeholderStart + 1; // consume escaped {
        }
      }
      else
      {
        break; // { is at the end
      }
    }
    else
    {
      break; // no { found
    }
  }

  // add the rest as a static format string item if any
  if (chunkStart < format.size())
  {
    _items.emplace_back(
      new StaticFormatItem(format.substr(chunkStart), chunkStart)
    );
  }
}

void ParsedFormat::substituePlaceholders(const std::vector<Argument>& args, std::ostream& out) const
{
  for (auto& item : _items)
  {
    item->toString(args, out);
  }
}

std::map<std::size_t, std::string> ParsedFormat::getNamedPlaceholders() const
{
  std::map<std::size_t, std::string> args;

  for (auto& itemPtr : _items)
  {
    auto name = itemPtr->name();
    if (name.empty() == false)
    {
      args.insert({itemPtr->argIndex(), name});
    }
  }

  return args;
}

} // namespace detail
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/detail/DeserializedStruct.C
#include <binlog/reader/detail/DeserializedStruct.H>

namespace binlog {
namespace reader {
namespace detail {

DeserializedStruct::DeserializedStruct(const std::string& name, std::size_t fieldCount)
  :_name(name)
{
  _fields.reserve(fieldCount);
}

void DeserializedStruct::setField(const std::string& name, const Argument& value)
{
  _fields.emplace_back(name, value);
}

std::ostream& operator<<(std::ostream& out, const DeserializedStruct& ds)
{
  // Produces: StructName { field1: field1val, field2: field2val }

  out << ds._name << "{ ";

  bool first = true;

  for (auto&& field : ds._fields)
  {
    if (!first)
    {
      out << ", ";
    }
    else
    {
      first = false;
    }

    out << field.first << ": " << field.second;
  }

  out << " }";

  return out;
}

} // namespace detail
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/detail/AggregateInputStream.C
#include <boost/algorithm/string/predicate.hpp>

#include <binlog/reader/FileInputStream.H>
#include <binlog/reader/detail/AggregateInputStream.H>
#include <binlog/reader/detail/MmapInputStream.H>
#include <binlog/reader/detail/CompressedFileInputStream.H>

namespace binlog {
namespace reader {
namespace detail {

AggregateInputStream::AggregateInputStream(const std::vector<std::string>& paths, bool continuous)
{
  _streams.reserve(paths.size());

  // Open each
  for (std::size_t i = 0; i < paths.size(); ++i)
  {
    if (boost::ends_with(paths[i], ".gz"))
    {
      _streams.emplace_back(new CompressedFileInputStream(paths[i]));
    }
    else
    {
      bool cont = continuous && (i == paths.size() - 1); // only the last one
      if (cont)
      {
        _streams.emplace_back(new FileInputStream(paths[i], cont));
      }
      else
      {
        _streams.emplace_back(new MmapInputStream(paths[i]));
      }
    }
  }

  _currentStreamIt = _streams.begin();
}

AggregateInputStream::operator bool() const
{
  for (auto streamIt = _currentStreamIt; streamIt != _streams.end(); ++streamIt)
  {
    if (**streamIt) { return true; }
  }

  return false;
}

off_t AggregateInputStream::tellg() const
{
  off_t pos = 0;

  auto end = (_currentStreamIt == _streams.end()) ? _currentStreamIt : _currentStreamIt + 1;
  for (auto streamIt = _streams.begin(); streamIt != end; ++streamIt)
  {
    pos += (*streamIt)->tellg();
  }

  return pos;
}

bool AggregateInputStream::seekg(off_t)
{
  return false;
}

std::size_t AggregateInputStream::read(char* dst, std::size_t size)
{
  std::size_t rsize = 0;
  while (rsize < size && *this)
  {
    rsize = (*_currentStreamIt)->read(dst + rsize, size);
    if (rsize != size)
    {
      ++_currentStreamIt;
    }
  }

  return rsize;
}

std::string AggregateInputStream::readShebang()
{
  std::string result;
  if (_streams.empty()) { return result; }

  result = _streams.front()->readShebang();

  // consume all shebangs
  for (auto streamIt = _streams.begin() + 1; streamIt != _streams.end(); ++streamIt)
  {
    (*streamIt)->readShebang();
  }

  return result;
}

} // namespace detail
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/detail/ArgumentParseContext.C
#include <binlog/reader/detail/ArgumentParseContext.H>
#include <binlog/reader/detail/DeserializedStruct.H>
#include <binlog/reader/detail/DeserializedArray.H>
#include <binlog/reader/detail/DeserializedTuple.H>

#include <binlog/detail/Error.H>

namespace binlog {
namespace reader {
namespace detail {

void ArgumentParseContext::addStructDefinition(entry::StructDefinition structDef)
{
  auto id = structDef.id();
  _structures.insert({id, std::move(structDef)});
}

DeserializedStruct ArgumentParseContext::readStructure(ReadBuffer& reader, std::error_code& ec) const
{
  using namespace binlog::detail::error;

  typeid_t structId = 0;
  if (! checkTrue(reader.read(structId), ec, Error::no_struct_id))
  {
    return {};
  }

  auto finder = _structures.find(structId);
  if (finder == _structures.end())
  {
    setError(ec, Error::invalid_struct_id) << structId;
    return {};
  }

  return finder->second.instantiate(*this, reader);
}

std::vector<Argument> ArgumentParseContext::readArguments(
  ReadBuffer& reader,
  const std::string& typeCodes
) const
{
  std::vector<Argument> arguments;
  arguments.reserve(typeCodes.size());

  for (auto typeCode : typeCodes)
  {
    auto&& arg = readArgument(*this, reader, typeCode);
    arguments.push_back(std::move(arg));
  }

  return arguments;
}

} // namespace detail
} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/reader/PrettyPrinter.C
#include <ostream>
#include <ctime>
#include <iomanip>
#include <chrono>

#include <binlog/reader/PrettyPrinter.H>

#include <binlog/reader/entry/Entry.H>
#include <binlog/reader/entry/Event.H>
#include <binlog/reader/entry/EventSource.H>

namespace {

using binlog::reader::entry::Entry;
using binlog::reader::entry::Event;
using binlog::reader::entry::EventSource;

void printTag(const Entry& entry, std::ostream& out)
{
  out << std::setw(12);

  switch (entry.tag())
  {
  case binlog::detail::EntryTag::tscSync:
    out << "TSCSync";
    break;
  case binlog::detail::EntryTag::threadProp:
    out << "ThreadProp";
    break;
  case binlog::detail::EntryTag::eventSource:
    out << "EventSource";
    break;
  case binlog::detail::EntryTag::structDef:
    out << "StructDef";
    break;
  case binlog::detail::EntryTag::hostProp:
    out << "HostProp";
    break;
  default:
    out << std::setfill('0') << std::hex << entry.tag()
        << std::setfill(' ') << std::dec;
    break;
  }
}

void printReadBuffer(const Entry& entry, std::ostream& out)
{
  out << std::hex << std::setfill('0');

  auto&& payload = entry.payload();
  while (payload.size())
  {
    char c = *payload.get();
    if (std::isprint(c))
    {
      out << c;
    }
    else
    {
      out << "0x" << std::setw(2) << +c << ' ';
    }
    payload.discard(1);
  }

  out << std::setfill(' ') << std::dec;
}

void printRelativeTsc(const uint64_t tsc, std::ostream& out)
{
  static int64_t latestTsc = 0; // TODO move state to PP member

  int64_t nextTsc = int64_t(tsc);

  int64_t diff = nextTsc - latestTsc;
  out << std::setfill(' ') << std::setw(6) << diff;

  latestTsc = nextTsc;
}

void printUsecs(const Event::DateTime& date, std::ostream& out)
{
  using std::chrono::duration_cast;
  using std::chrono::seconds;
  using std::chrono::microseconds;

  auto  secs = duration_cast<seconds>     (date.time_since_epoch());
  auto usecs = duration_cast<microseconds>(date.time_since_epoch());

  auto usecsPart = (usecs - duration_cast<microseconds>(secs)).count();
  out << std::setfill('0') << std::setw(6) << usecsPart;
}

void printArguments(const Event& event, std::ostream& out)
{
  out << '(';

  auto&& args = event.arguments();
  for (std::size_t i = 0; i < args.size(); ++i)
  {
    out << args[i];
    out << '|';
  }

  out << ')';
}

} // namespace

namespace binlog {
namespace reader {

struct PrettyPrinter::PrintableDate
{
  PrintableDate(const Event& event)
    :event(event)
  {
    std::time_t time = Event::Clock::to_time_t(event.dateTime());
    gmtime_r(&time, &tm); // TODO unchecked gmtime_r retval
  }

  const Event& event;
  std::tm tm;
};

PrettyPrinter::PrettyPrinter()
  :_entryFormat("%T %S %P\n"),
   _eventFormat("%S %C [%d] %t %N %m\n"),
   _eventSourceFormat("%I %C %S %F (%M)\n"),
   _dateFormat("%m/%d %H:%M:%S")
{}

std::ostream& PrettyPrinter::print(const Entry& entry, std::ostream& out) const
{
  printEntity(entry, _entryFormat, out);
  return out;
}

std::ostream& PrettyPrinter::print(const Event& event, std::ostream& out) const
{
  printEntity(event, _eventFormat, out);
  return out;
}

std::ostream& PrettyPrinter::print(const EventSource& eventSource, std::ostream& out) const
{
  printEntity(eventSource, _eventSourceFormat, out);
  return out;
}

template <typename Entity>
void PrettyPrinter::printEntity(const Entity& entity, const std::string& format, std::ostream& out) const
{
  std::size_t index = 0;

  while (index < format.size())
  {
    auto nextIndex = format.find('%', index);

    if (nextIndex != std::string::npos && nextIndex + 1 < format.size())
    {
      out.write(format.data() + index, std::streamsize(nextIndex - index));
      printField(entity, format[nextIndex + 1], out);
      index = nextIndex + 2; // skip % and field specifier
    }
    else
    {
      break;
    }
  }

  out.write(format.data() + index, std::streamsize(format.size() - index));
}

void PrettyPrinter::printField(const Entry& entry, const char spec, std::ostream& out) const
{
  switch (spec)
  {
  case 'T':
    printTag(entry, out);
    break;
  case 'S':
    out << std::setw(9) << entry.payload().size();
    break;
  case 'P':
    printReadBuffer(entry, out);
    break;
  default:
    out << '%' << spec;
    break;
  }
}

void PrettyPrinter::printField(const Event& event, const char spec, std::ostream& out) const
{
  switch (spec)
  {
  case 'I':
    out << event.source().instructionPointer();
    break;
  case 'C':
  case 'S':
  case 'F':
  case 'M':
  case 'N':
  case 'L':
    printField(event.source(), spec, out);
    break;
  case 'd':
    printEntity(PrintableDate(event), _dateFormat, out);
    break;
  case 'h':
    out << event.hostName();
    break;
  case 'n':
    out << event.threadId();
    break;
  case 't':
    out << event.threadName();
    break;
  case 'a':
    printArguments(event, out);
    break;
  case 'm':
    writeMessage(event, out);
    break;
  default:
    out << '%' << spec;
    break;
  }
}

void PrettyPrinter::printField(const EventSource& eventSource, const char spec, std::ostream& out) const
{
  switch (spec)
  {
  case 'I':
    out << eventSource.sourceId();
    break;
  case 'C':
    out << eventSource.category();
    break;
  case 'S':
    out << binlog::severityToString(eventSource.severity());
    break;
  case 'F':
    out << eventSource.formatString();
    break;
  case 'M':
    out << eventSource.function();
    break;
  case 'N':
    writeShortFunction(eventSource, out);
    break;
  case 'L':
    out << eventSource.file() << ':' << eventSource.line();
    break;
  default:
    out << '%' << spec;
    break;
  }
}

void PrettyPrinter::printField(const PrintableDate& date, const char spec, std::ostream& out) const
{
  switch (spec)
  {
  case 'Y':
    out << date.tm.tm_year + 1900;
    break;
  case 'y':
    out << date.tm.tm_year % 100;
    break;
  case 'm':
    out << std::setfill('0') << std::setw(2) << date.tm.tm_mon + 1;
    break;
  case 'd':
    out << std::setfill('0') << std::setw(2) << date.tm.tm_mday;
    break;
  case 'H':
    out << std::setfill('0') << std::setw(2) << date.tm.tm_hour;
    break;
  case 'M':
    out << std::setfill('0') << std::setw(2) << date.tm.tm_min;
    break;
  case 'S':
    out << std::setfill('0') << std::setw(2) << date.tm.tm_sec;
    break;
  case 'U':
    printUsecs(date.event.dateTime(), out);
    break;
  case 'q':
    out << date.event.tsc();
    break;
  case 'r':
    printRelativeTsc(date.event.tsc(), out);
    break;
  default:
    out << '%' << spec;
    break;
  }
}

} // namespace reader
} // namespace binlog
Attention:  ./lib/binlog/detail/ThreadContext.C
#include <algorithm>
#include <cstring>  // memcpy
#include <unistd.h> // SYS_gettid
#include <sys/syscall.h>

#include <binlog/detail/ThreadContext.H>
#include <binlog/detail/Core.H>
#include <binlog/detail/Entry.H>

namespace binlog {
namespace detail {

ThreadContext::ThreadContext()
  :_entryQueue(s_minQueueSize),
   _lwp(LWP(syscall(SYS_gettid)))
{
  _threadName.fill(0);
  initThreadPropBuf();
}

ThreadContext::ThreadContext(std::size_t queueSize, LWP lwp, const ThreadName& threadName)
  :_entryQueue(queueSize),
   _lwp(lwp),
   _threadName(threadName)
{
  initThreadPropBuf();
}

void ThreadContext::setName(const std::string& name)
{
  constexpr std::size_t threadNameLen = std::tuple_size<ThreadName>::value;

  _threadName.fill(0);
  const std::size_t size = std::min(name.size(), threadNameLen - 1);
  std::copy_n(name.begin(), size, _threadName.begin());

  // TODO race condition: consumer might be reading this buffer
  initThreadPropBuf();
}

void ThreadContext::setMinQueueSize(std::size_t minSize)
{
  s_minQueueSize = minSize;
}

std::size_t ThreadContext::getMinQueueSize()
{
  return s_minQueueSize;
}

void ThreadContext::initThreadPropBuf()
{
  Entry threadProp(_threadPropBuf.data());
  threadProp.writeThreadProp(_lwp, _threadName.data());
}

std::atomic<std::size_t> ThreadContext::s_minQueueSize = {1048576};

} // namespace detail
} // namespace binlog
Attention:  ./lib/binlog/detail/Entry.C
#include <cstring>
#include <chrono>
#include <ctime>  // localtime
#include <unistd.h> // gethostname
#include <climits> // HOST_NAME_MAX

#include <binlog/Configuration.H>

#include <binlog/detail/Entry.H>
#include <binlog/detail/Time.H>
#include <binlog/detail/ThreadContext.H>
#include <binlog/detail/Core.H>

namespace binlog {
namespace detail {

void Entry::writeTSCSync()
{
  typedef std::chrono::high_resolution_clock clock;

  const entry_size_t size = EntryDefs::tscSyncSize;
  const tag_t formatTag   = EntryTag::tscSync;
  const tsc_t tsc         = readTsc();
  const auto now          = clock::now();
  int64_t tzOffset        = 0;
  const int cpufreq       = getCpufreq();

  auto time = clock::to_time_t(now);
  auto tm = std::localtime(&time);
  if (tm)
  {
    tzOffset = tm->tm_gmtoff;
  }

  write(size);
  write(formatTag);
  write(tsc);
  write(now);
  write(tzOffset);
  write(cpufreq);
}

void Entry::writeThreadProp(
  ThreadContext::LWP lwp,
  const char* threadName
)
{
  const entry_size_t size = EntryDefs::threadPropSize;
  const tag_t formatTag   = EntryTag::threadProp;

  write(size);
  write(formatTag);
  write(lwp);
  write(threadName, EntryDefs::threadNameLen);
}

void Entry::writeHostProperties()
{
  const tag_t formatTag = EntryTag::hostProp;

  char hostname[HOST_NAME_MAX+1];
  gethostname(hostname, HOST_NAME_MAX);
  hostname[HOST_NAME_MAX] = '\0'; // needed if name size is maximal

  auto hostnameSize = strnlen(hostname, HOST_NAME_MAX) + 1;

  const std::size_t size =
    sizeof(entry_size_t)
  + sizeof(formatTag)
  + hostnameSize;

  write(entry_size_t(size));
  write(formatTag);
  write(hostname, hostnameSize);
}

void notifyConsumer()
{
  Core::getInstance().notifyConsumer();
}

void incrementCategoryThresholds()
{
  getConfiguration().incrementCategoryThresholds();
}

} // namespace detail
} // namespace binlog
Attention:  ./lib/binlog/detail/ThisThreadContext.C
#include <binlog/detail/ThisThreadContext.H>
#include <binlog/detail/Core.H>

namespace binlog {
namespace detail {

namespace {

template <typename... Args>
std::shared_ptr<ThreadContext> createImpl(Args&&... args)
{
  auto tcPtr = std::make_shared<ThreadContext>(std::forward<Args>(args)...);
  Core::getInstance().reportThread(tcPtr);
  return tcPtr;
}

} // namespace

void ThisThreadContext::resetQueue(std::size_t minSize)
{
  auto& old = getSharedPtr();
  std::size_t newSize = std::max(minSize + 1, old->getEntryQueue().size());
  auto tcPtr = createImpl(newSize, old->getLwp(), old->getThreadName());
  old = tcPtr;
}

std::shared_ptr<ThisThreadContext::T> ThisThreadContext::create()
{
  return createImpl();
}

} // namespace detail
} // namespace binlog
Attention:  ./lib/binlog/detail/ElfConfig.C
#include <stdexcept>
#include <cstdio>
#include <fstream>
#include <map>

#include <boost/spirit/include/qi_uint.hpp>
#include <boost/spirit/include/qi_parse_attr.hpp>
#include <boost/spirit/include/qi_char.hpp>
#include <boost/spirit/include/qi_operator.hpp>
#include <boost/spirit/include/qi_omit.hpp>
#include <boost/spirit/include/qi_rule.hpp>
#include <boost/spirit/include/qi_skip.hpp>
#include <boost/spirit/include/qi_string.hpp>

#include <binlog/Configuration.H>  // getConfiguration
#include <binlog/detail/ElfConfig.H>
#include <binlog/detail/Elf.H>
#include <binlog/detail/Preamble.H>

namespace binlog {
namespace detail {

namespace {

struct Map
{
  std::uintptr_t begin = 0;
  std::uintptr_t end = 0;
  std::string path;
};

/**
* Parse a line of /proc/<pid>/maps
*
* @see http://man7.org/linux/man-pages/man5/proc.5.html
* @returns memory begin, end and backing path,
*          empty map on error
*/
template <typename Iterator>
Map parseMap(Iterator first, Iterator last)
{
  namespace qi = boost::spirit::qi;

  Map map;

  qi::uint_parser<std::uintptr_t, 16> addr;
  qi::rule<Iterator> field_sep = *qi::lit(' ');
  qi::rule<Iterator> unused_field = *(!qi::lit(' ') >> qi::omit[qi::char_]);
  qi::rule<Iterator, std::string()> field = *(!qi::lit(' ') >> qi::char_);

  bool ok = qi::parse(
    first, last,
    addr >> '-' >> addr >>
    field_sep >> unused_field >>
    field_sep >> unused_field >>
    field_sep >> unused_field >>
    field_sep >> unused_field >>
    field_sep >> field,
    map.begin, map.end, map.path
  );

  if (!ok) { map.end = 0; map.begin = 0; }
  return map;
}

/**
* Find the file mapped in virtual memory containing `addr`.
*
* Assumes file is continously mapped.
*
* @returns an empty map and sets `ec` if not found
*/
Map findMapOf(void* addr, std::error_code& ec)
{
  std::uintptr_t need = 0;
  std::memcpy(&need, &addr, sizeof(addr));

  std::map<std::string, std::uintptr_t> begins;

  std::ifstream maps("/proc/self/maps");

  std::string line;
  while (std::getline(maps, line))
  {
    Map map = parseMap(line.begin(), line.end());

    auto& minBegin = begins[map.path];
    if (minBegin == 0 || minBegin > map.begin)
    {
      minBegin = map.begin;
    }

    if (map.begin <= need && need < map.end)
    {
      if (minBegin < map.begin)
      {
        map.begin = minBegin;
      }
      return map;
    }
  }

  ec = std::make_error_code(std::errc::no_such_device_or_address);
  return {};
}

std::size_t computeSourceCount(const Elf& elf, std::error_code& ec)
{
  ElfSection descSec = elf.getSection(".ms.log.descriptor", ec);
  std::size_t secSize = descSec.size(ec);
  return secSize / 8;
}

} // namespace

ElfConfig::ElfConfig()
{
  std::error_code ec;

  // Find the file which contains `this` as a global object
  // and report it to the preamble.

  Map map = findMapOf(this, ec);
  _path = map.path;
  _memoryOffset = map.begin;

  Elf elf(_path, _memoryOffset, ec);
  if (elf.isExecutable(ec))
  {
    _memoryOffset = 0; // special for exe
    elf.loadAddress(_memoryOffset);
  }

  _formatIdOffset = _memoryOffset >> 3;

  std::size_t sourceCount = computeSourceCount(elf, ec);

  if (ec)
  {
    fprintf(stderr, "[binlog] Failed to create ElfConfig: %s\n", ec.message().c_str());
    return;
  }

  Preamble::getInstance().addBinlogUserElf(elf);

  // One bit for every source in the _sourceConfig array,
  // (+1 accounts for cases when sourceCount & 8 != 0)
  std::size_t sourceConfigSize = (sourceCount / 8) + 1;
  initSourceConfig(sourceConfigSize);

  getConfiguration().registerElfConfig(this);
}

ElfConfig::~ElfConfig()
{
  getConfiguration().unregisterElfConfig(this);
}

void ElfConfig::initSourceConfig(std::size_t size)
{
  // allocate source config, zeroed memory
  _sourceConfig.reset(new char[size]);
  std::fill_n(_sourceConfig.get(), size, 0);
  _sourceConfigSize = size;
}

void ElfConfig::enableSource(std::size_t sourceIndex)
{
  clearBit(sourceIndex);
}

void ElfConfig::disableSource(std::size_t sourceIndex)
{
  setBit(sourceIndex);
}

void ElfConfig::setBit(std::size_t bitIndex)
{
  if (bitIndex / 8 < _sourceConfigSize)
  {
    char mask = char(1 << (bitIndex & 7));
    _sourceConfig[bitIndex / 8] |= mask;
  }
}

void ElfConfig::clearBit(std::size_t bitIndex)
{
  if (bitIndex / 8 < _sourceConfigSize)
  {
    char mask = char(~(1 << (bitIndex & 7)));
    _sourceConfig[bitIndex / 8] &= mask;
  }
}

} // namespace detail
} // namespace binlog
Attention:  ./lib/binlog/detail/Pattern.C
#include <algorithm>

#include <binlog/detail/Pattern.H>

namespace binlog {
namespace detail {

Pattern::Pattern(const std::string& pattern)
  :_pattern(pattern)
{}

bool Pattern::matches(const std::string& input) const
{
  auto i = input.begin();

  for (auto p = _pattern.begin(); p != _pattern.end(); ++p, ++i)
  {
    if (*p == '*')
    {
      ++p;

      if (p == _pattern.end())
      {
        break;
      }
      else
      {
        // ignore until the next char of the pattern or end
        for (; i != input.end() && *i != *p; ++i)
          ;

        if (i == input.end()) { return false; }
      }
    }
    else if (i == input.end() || *p != *i)
    {
      return false; // no match
    }
  }

  return true;
}

bool Pattern::replace(std::string& input, const std::string& replacement) const
{
  if (_pattern.empty()) { return false; }

  auto matchBegin = input.begin();
  auto matchEnd   = input.begin();

  auto p = _pattern.begin();

  if (*p == '*')
  {
    ++p;
    if (p == _pattern.end())
    {
      matchEnd = input.end();
    }
    else
    {
      matchEnd = std::find(input.begin(), input.end(), *p);
      // if not found, the loop will return false
    }
  }
  else
  {
    matchBegin = std::find(input.begin(), input.end(), *p);
    matchEnd = matchBegin;
  }

  for (; p != _pattern.end(); ++p, ++matchEnd)
  {
    if (matchEnd == input.end()) { return false; }

    if (*p == '*')
    {
      ++p;

      if (p == _pattern.end())
      {
        matchEnd = input.end();
        break;
      }
      else
      {
        matchEnd = std::find(matchEnd, input.end(), *p);
        if (matchEnd == input.end()) { return false; }
      }
    }
    else if (*p != *matchEnd)
    {
      return false;
    }
  }

  input.replace(matchBegin, matchEnd, replacement);
  return true;
}

} // namespace detail
} // namespace binlog
Attention:  ./lib/binlog/detail/ConfigParser.C
#include <stdexcept>
#include <sstream>
#include <iostream>

#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/xpressive/xpressive.hpp>

#include <binlog/detail/ConfigParser.H>
#include <binlog/detail/Error.H>
#include <binlog/detail/Pattern.H>

#include <binlog/sink/FileSink.H>
#include <binlog/sink/StreamSink.H>
#include <binlog/sink/SyslogSink.H>

namespace binlog {
namespace detail {

namespace {

typedef ConfigParser::Config Config;

template <typename Field>
bool readField(
  const Config& pt, const char* field, Field& retval,
  const char* expected, std::error_code& ec
)
{
  if (! pt.count(field)) { return false; }

  auto optValue = pt.get_optional<Field>(field);
  if (! optValue)
  {
    setError(ec, Error::config_invalid_field) << field << " 'field, expected " << expected;
    return false;
  }

  retval = *optValue;
  return true;
}

std::unique_ptr<sink::Sink> createFileSink(const Config& sinkConfig, std::error_code& ec)
{
  if (! sinkConfig.count("target"))
  {
    setError(ec, Error::config_no_target_for_file);
    return {};
  }

  auto&& logfile = sinkConfig.get<std::string>("target");

  sink::FileSink* pFileSink;

  try
  {
    pFileSink = new sink::FileSink(logfile);
  }
  catch (const std::runtime_error& ex)
  {
    setError(ec, Error::runtime_error) << ex.what();
    return {};
  }

  std::unique_ptr<sink::Sink> sinkPtr(pFileSink);

  std::size_t rotateBytes;
  if (readField(sinkConfig, "rotateBySize", rotateBytes, "std::size_t (bytes)", ec))
  {
    pFileSink->rotateBySize(rotateBytes);
  }

  std::size_t rotateSecondsCount;
  if (readField(sinkConfig, "rotateByTime", rotateSecondsCount, "std::size_t (seconds)", ec))
  {
   std::chrono::seconds rotateSeconds(rotateSecondsCount);
    pFileSink->rotateByTime(rotateSeconds);
  }

  bool compression;
  if (readField(sinkConfig, "compression", compression, "compression (true/false)", ec))
  {
    pFileSink->compression(true);
  }

  return sinkPtr;
}

std::unique_ptr<sink::Sink> createStreamSink(const Config& sinkConfig, std::error_code& ec)
{
  if (! sinkConfig.count("target"))
  {
    setError(ec, Error::config_no_target_for_stream);
    return {};
  }

  auto&& stream = sinkConfig.get<std::string>("target");
  std::ostream* pStream = nullptr;
       if (stream == "cout") { pStream = &std::cout; }
  else if (stream == "cerr") { pStream = &std::cerr; }
  else if (stream == "clog") { pStream = &std::clog; }

  if (!pStream)
  {
    setError(ec, Error::config_invalid_target_for_stream);
    return {};
  }

  auto&& format = sinkConfig.get<std::string>("format", "%S %C [%d] %t %N %m");
  return std::unique_ptr<sink::Sink>(
    new sink::StreamSink(*pStream, format)
  );
}

std::unique_ptr<sink::Sink> createSyslogSink(const Config& sinkConfig)
{
  auto&& format = sinkConfig.get<std::string>("format", "%S %C [%d] %t %N %m");
  return std::unique_ptr<sink::Sink>(
    new sink::SyslogSink(format)
  );
}

std::vector<std::pair<std::string, CategoryConfig>>
parseCategoryConfig(const Config& node, std::error_code& ec)
{
  std::vector<std::pair<std::string, CategoryConfig>> configs;

  configs.reserve(node.size());

  for (auto&& category : node)
  {
    auto&& severityStr = category.second.data();
    auto severity = stringToSeverity(severityStr);
    if (severity == binlog::unknown)
    {
      setError(ec, Error::config_invalid_severity) << severityStr << "'";
      break;
    }

    configs.emplace_back(category.first, CategoryConfig{severity});
  }

  return configs;
}

} // namespace

struct ConfigParser::Implementation
{
  Config config;
  boost::xpressive::sregex variableRegex;
};

ConfigParser::ConfigParser()
  :_impl(new Implementation())
{}

ConfigParser::~ConfigParser() = default;

void ConfigParser::readConfigFile(const std::string& configFile, std::error_code& ec)
{
  boost::property_tree::ptree fullConfig;

  try
  {
    boost::property_tree::json_parser::read_json(configFile, fullConfig);
  }
  catch (const boost::property_tree::json_parser::json_parser_error& ex)
  {
    setError(ec, Error::config_invalid_json) << ex.what();
    return;
  }

  if (! fullConfig.count("binlog"))
  {
    setError(ec, Error::config_no_binlog_key);
    return;
  }

  _impl->config = std::move(fullConfig.get_child("binlog"));

  if (_variableFactory)
  {
    replaceVariables(_impl->config);
  }
}

void ConfigParser::setSinkFactory(const SinkFactory& sinkFactory)
{
  _sinkFactory = sinkFactory;
}

void ConfigParser::setPredicateFactory(const PredicateFactory& predicateFactory)
{
  _predicateFactory = predicateFactory;
}

void ConfigParser::setVariableFactory(const VariableFactory& variableFactory)
{
  _variableFactory = variableFactory;
  _impl->variableRegex = _impl->variableRegex.compile("\\$\\{([A-Za-z0-9_]+)\\}");
}

std::vector<std::pair<std::string, CategoryConfig>>
ConfigParser::getCategoryConfig(std::error_code& ec)
{
  auto&& optCategories = _impl->config.get_child_optional("categories");
  if (! optCategories) { return {}; }

  return parseCategoryConfig(*optCategories, ec);
}

std::vector<ConfigParser::ConfiguredSink>
ConfigParser::getConfiguredSinks(std::error_code& ec)
{
  std::vector<ConfiguredSink> sinks;

  auto&& optSinkConfig = _impl->config.get_child_optional("sinks");
  if (!optSinkConfig) { return sinks; }

  sinks.reserve(optSinkConfig->size());

  for (auto&& node : *optSinkConfig)
  {
    auto&& type = node.first;
    auto&& sinkConfig = node.second;

    auto sinkPtr = createSink(type, sinkConfig, ec);
    auto predicate = extractEventSourcePredicate(sinkConfig, ec);

    std::ostringstream description;
    try
    {
      boost::property_tree::json_parser::write_json(description, sinkConfig, true);
    }
    catch (const boost::property_tree::json_parser_error& ex)
    {
      description.str(""); // reset
      description << ex.what();
    }

    if (!ec)
    {
      sinks.push_back(
        ConfiguredSink{std::move(sinkPtr), predicate, description.str()}
      );
    }
  }

  return sinks;
}

ConfigParser::ProducerConfig ConfigParser::getProducerConfig(std::error_code& ec)
{
  ProducerConfig result;

  if (! _impl->config.count("producers")) { return result; }
  auto&& prodConfig = _impl->config.get_child("producers");

  auto optCeilingStr = prodConfig.get_optional<std::string>("adaptive_severity_ceiling");

  if (optCeilingStr)
  {
    Severity ceiling = stringToSeverity(*optCeilingStr);
    if (ceiling != binlog::unknown)
    {
      result.adaptiveSeverityCeiling = ceiling;
    }
    else
    {
      setError(ec, Error::config_invalid_severity) << *optCeilingStr << "'";
    }
  }

  std::size_t queueSize;
  if (readField(prodConfig, "min_queue_size", queueSize, "std::size_t (bytes)", ec))
  {
    result.minQueueSize = queueSize;
  }

  return result;
}

void ConfigParser::replaceVariables(Config& config)
{
  if (! config.data().empty())
  {
    auto substituteVariable = [&](const boost::xpressive::smatch& match)
    {
      return _variableFactory(match[1]);
    };

    // apply replacement
    config.data() = boost::xpressive::regex_replace(
      config.data(), _impl->variableRegex, substituteVariable
    );
  }

  // visit children
  for (auto&& nameConfigPair : config)
  {
    replaceVariables(nameConfigPair.second);
  }
}

ConfigParser::EventSourcePredicate
ConfigParser::extractEventSourcePredicate(
  const Config& sinkConfig,
  std::error_code& ec
) const
{
  auto optPredicate = sinkConfig.get_child_optional("predicate");

  if (! optPredicate)
  {
    return [](const sink::MultiSink::EventSource&) { return true; };
  }

  auto&& predicate = *optPredicate;

  auto&& predicateStr = predicate.data();

  // try interpret as severity
  auto severity = stringToSeverity(predicateStr);
  if (severity != binlog::unknown)
  {
    return [severity](const sink::MultiSink::EventSource& es)
    {
      return es.severity() >= severity;
    };
  }

  // try interpret as object
  if (predicateStr.empty())
  {
    auto categoryConfig = parseCategoryConfig(predicate, ec);
    if (!ec)
    {
      std::vector<std::pair<Pattern, Severity>> thresholds;
      thresholds.reserve(categoryConfig.size());

      for (auto&& cc : categoryConfig)
      {
        thresholds.emplace_back(cc.first, cc.second.minSeverity);
      }

      return [thresholds](const sink::MultiSink::EventSource& es)
      {
        for (auto&& thr : thresholds)
        {
          if (thr.first.matches(es.category()))
          {
            return es.severity() >= thr.second;
          }
        }

        return true;
      };
    }
  }

  // try custom predicate
  if (_predicateFactory)
  {
    auto&& customPredicate = _predicateFactory(predicateStr);
    if (customPredicate)
    {
      return customPredicate;
    }
  }

  setError(ec, Error::config_invalid_predicate) << predicateStr;
  return {};
}

std::unique_ptr<sink::Sink> ConfigParser::createSink(
  const std::string& type,
  const Config& sinkConfig,
  std::error_code& ec
) const
{
  if (type == "File")
  {
    return createFileSink(sinkConfig, ec);
  }
  else if (type == "Stream")
  {
    return createStreamSink(sinkConfig, ec);
  }
  else if (type == "Syslog")
  {
    return createSyslogSink(sinkConfig);
  }
  else if (_sinkFactory) // try custom sink
  {
    auto sinkPtr = _sinkFactory(type, sinkConfig);
    if (sinkPtr)
    {
      return sinkPtr;
    }
  }

  setError(ec, Error::config_invalid_sink) << type;
  return {};
}


} // namespace detail
} // namespace binlog
Attention:  ./lib/binlog/detail/Time.C
#include <cstdio>
#include <cstdlib>
#include <climits>
#include <string>

#include <boost/algorithm/string/predicate.hpp>

#include <binlog/detail/Time.H>

namespace binlog {
namespace detail {

int getCpufreq()
{
  // memoization
  static int freq = 0;
  if (freq != 0) return freq;

  // if there is cpu scaling installed, it's easy to get the frequency:
  FILE* fp = fopen("/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq", "r");
  if (fp)
  {
    fscanf(fp, "%d", &freq);
    fclose(fp);
  }
  else
  {
    // if file not found, there is no cpu scaling
    // cpuinfo will be sufficient
    FILE* fp = fopen("/proc/cpuinfo", "r");
    if (fp)
    {
      char lineBuf[LINE_MAX];
      while (fgets(lineBuf, LINE_MAX, fp) != nullptr)
      {
        std::string line(lineBuf);

        if (boost::starts_with(line, "cpu MHz"))
        {
          std::string valueStr = line.substr(line.find(':') + 2);
          float value = strtof(valueStr.c_str(), nullptr);
          freq = static_cast<int>(value * 1000);
          break;
        }
      }

      fclose(fp);
    }
  }

  if (freq == 0)
  {
    fprintf(stderr, "[binlog] Failed to get CPU frequency\n");
    freq = -1;
  }

  return freq;
}

} // namespace detail
} // namespace binlog
Attention:  ./lib/binlog/detail/Elf.C
#include <cstddef>
#include <stdexcept>

#include <fcntl.h>

#include <binlog/detail/Elf.H>
#include <binlog/detail/Error.H>

namespace binlog {
namespace detail {

namespace {

class ElfErrorCategory : public std::error_category
{
public:
  const char* name() const noexcept { return "elf"; }
  std::string message(int ev) const { return elf_errmsg(ev); }
};

void setElfError(std::error_code& ec)
{
  static ElfErrorCategory static_category;

  int errc = elf_errno(); // clear errno any way
  if (! ec)               // but don't overwrite already set `ec`
  {
    ec.assign(errc, static_category);
  }
}

} // namespace

//
// ElfSection
//

ElfSection::ElfSection(Elf_Scn* section)
  :_section(section)
{}

uint64_t ElfSection::size(std::error_code& ec)
{
  GElf_Shdr sectionHeader;
  if (! gelf_getshdr(_section, &sectionHeader))
  {
    setElfError(ec);
    return 0;
  }

  return sectionHeader.sh_size;
}

void* ElfSection::data(std::size_t& size, std::error_code& ec)
{
  Elf_Data* data = elf_getdata(_section, nullptr);
  if (!data)
  {
    setElfError(ec);
    size = 0;
    return nullptr;
  }

  size = data->d_size;
  return data->d_buf;
}

uint64_t ElfSection::address(std::error_code& ec)
{
  GElf_Shdr sectionHeader;
 if (! gelf_getshdr(_section, &sectionHeader))
  {
    setElfError(ec);
    return 0;
  }

  return sectionHeader.sh_addr;
}

//
// Elf
//

Elf::Elf(const std::string& elfPath, std::error_code& ec)
:_path(elfPath),
  _fd(open(elfPath.c_str(), O_RDONLY))
{
  if (!_fd)
  {
    if (!ec) { ec.assign(errno, std::system_category()); }
    return;
  }

  if (elf_version(EV_CURRENT) == EV_NONE)
  {
    setElfError(ec);
    return;
  }

  _elf = elf_begin(*_fd, ELF_C_READ_MMAP_PRIVATE, NULL);
  if (! _elf)
  {
    setElfError(ec);
    return;
  }

  if (elf_kind(_elf) != ELF_K_ELF)
  {
    setElfError(ec);
    return;
  }
}

Elf::Elf(const std::string& elfPath, std::size_t loadAddress, std::error_code& ec)
  :Elf(elfPath, ec)
{
  _loadAddress = loadAddress;
}

Elf::~Elf()
{
  if (_elf)
  {
    elf_end(_elf);
  }
}

ElfSection Elf::getSection(const std::string& sectionName, std::error_code& ec) const
{
  size_t sectionCount = 0;
  if (elf_getshdrnum(_elf, &sectionCount) < 0) { setElfError(ec); }

  size_t shdrIndex = 0;
  if (elf_getshdrstrndx(_elf, &shdrIndex) < 0) { setElfError(ec); }

  Elf_Scn* reqSection = nullptr;

  for (size_t i = 0; i < sectionCount; ++i)
  {
    Elf_Scn* section = elf_getscn(_elf, i);
    if (!section) { continue; }

    GElf_Shdr sectionHeader;
    if (! gelf_getshdr(section, &sectionHeader)) { continue; }

    const char* name = elf_strptr(_elf, shdrIndex, sectionHeader.sh_name);
    if (!name) { continue; }

    if (sectionName == name)
    {
      reqSection = section;
      break;
    }
  }

  if (!reqSection && !ec)
  {
    setError(ec, Error::not_binlog_user);
  }

  return ElfSection(reqSection);
}

bool Elf::isExecutable(std::error_code& ec) const
{
  GElf_Ehdr ehdr;
  if (! gelf_getehdr(_elf, &ehdr))
  {
    setElfError(ec);
    return false;
  }

  return ehdr.e_type == ET_EXEC;
}

} // namespace detail
} // namespace binlog
Attention:  ./lib/binlog/detail/WaitStrategy.C
#include <thread>

#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/select.h>

#ifdef BINLOG_HAS_EVENTFD // No eventfd on AS5
#include <sys/eventfd.h>
#endif

#include <binlog/detail/WaitStrategy.H>
#include <binlog/detail/Core.H>

namespace binlog {
namespace detail {

SleepWaitStrategy::SleepWaitStrategy()
  :SleepWaitStrategy(
    std::chrono::milliseconds(500),
    std::chrono::milliseconds(4000)
  )
{}

SleepWaitStrategy::SleepWaitStrategy(
  const std::chrono::milliseconds& minSleepDuration,
  const std::chrono::milliseconds& maxSleepDuration
)
  :_minSleepDuration(minSleepDuration),
   _maxSleepDuration(maxSleepDuration),
   _nextSleepDuration(minSleepDuration)
{}

void SleepWaitStrategy::reset()
{
  _nextSleepDuration = _minSleepDuration;
}

void SleepWaitStrategy::wait()
{
  std::this_thread::sleep_for(_nextSleepDuration);
  if (_nextSleepDuration < _maxSleepDuration)
  {
    _nextSleepDuration *= 2;
  }
}

BlockWaitStrategy::BlockWaitStrategy()
  :BlockWaitStrategy(std::chrono::milliseconds(2000))
{}

BlockWaitStrategy::BlockWaitStrategy(const std::chrono::milliseconds& timeout)
  :_timeout(timeout)
{}

void BlockWaitStrategy::wait()
{
  std::unique_lock<std::mutex> lk(_mutex);
  _signal.wait_for(lk, _timeout);
}

void BlockWaitStrategy::notify()
{
  _signal.notify_one();
}

PipeWaitStrategy::PipeWaitStrategy()
  :PipeWaitStrategy(std::chrono::milliseconds(2000))
{}

PipeWaitStrategy::PipeWaitStrategy(const std::chrono::milliseconds& timeout)
  :_fdRead(-1),
   _fdWrite(-1),
   _promoted(false)
{
  // initialize _timeout
  std::chrono::duration<suseconds_t, std::micro> usecs(timeout);
  _timeout.tv_sec = 0;
  _timeout.tv_usec = usecs.count();

  // initialize _fdRead and _fdWrite
#ifdef BINLOG_HAS_EVENTFD

  _fdRead = eventfd(0, EFD_NONBLOCK);
  if (_fdRead == -1)
  {
    perror("[binlog] PipeWaitStrategy failed to create eventfd");
  }
  else
  {
    _fdWrite = _fdRead;
  }

#else // no eventfd

  int fds[2];

  int status = pipe(fds); // No pipe2 on AS5
  if (status == -1)
  {
    perror("[binlog] PipeWaitStrategy failed to create pipe");
  }
  else
  {
    _fdRead = fds[0];
    _fdWrite = fds[1];

    status = fcntl(_fdRead, F_SETFL, O_NONBLOCK);
    if (status == -1)
    {
      perror("[binlog] PipeWaitStrategy failed to set O_NONBLOCK on _fdRead");
    }

    status = fcntl(_fdWrite, F_SETFL, O_NONBLOCK);
    if (status == -1)
    {
      perror("[binlog] PipeWaitStrategy failed to set O_NONBLOCK on _fdWrite");
    }
  }

#endif // BINLOG_HAS_EVENTFD
}

PipeWaitStrategy::~PipeWaitStrategy()
{
  if (_promoted)
  {
    Core::getInstance().setConsumerWaitStrategy(nullptr);
  }

  if (_fdRead > 0)
  {
    int result = close(_fdRead);
    if (result == -1)
    {
      perror("[binlog] PipeWaitStrategy failed to close _fdRead");
    }
  }

#ifndef BINLOG_HAS_EVENTFD

  if (_fdWrite > 0)
  {
    int result = close(_fdWrite);
    if (result == -1)
    {
      perror("[binlog] PipeWaitStrategy failed to close _fdWrite");
    }
  }

#endif // BINLOG_HAS_EVENTFD
}

void PipeWaitStrategy::reset()
{
  ssize_t status = 0;
  char buffer[64];
  while (read(_fdRead, &buffer, 64) == 64)
    /* nop */;

  if (status == -1 && errno != EAGAIN && errno != EWOULDBLOCK)
  {
    perror("[binlog] PipeWaitStrategy read failed");
  }
}

void PipeWaitStrategy::wait()
{
  fd_set fds;
  FD_ZERO(&fds);
  FD_SET(_fdRead, &fds);

  int result = select(_fdRead + 1, &fds, NULL, NULL, &_timeout);
  if (result == -1)
  {
    perror("[binlog] PipeWaitStrategy select failed");
  }
  else if (result > 0)
  {
    reset();
  }
}

void PipeWaitStrategy::notify()
{
  uint64_t dummy = 1;
  ssize_t result = write(_fdWrite, &dummy, sizeof(dummy));
  if (result == -1 && errno != EAGAIN && errno != EWOULDBLOCK)
  {
    perror("[binlog] PipeWaitStrategy failed to write");
  }
}

int PipeWaitStrategy::promoteToConsumerWaiter()
{
  Core::getInstance().setConsumerWaitStrategy(this);
  _promoted = true;
  return _fdRead;
}

} // namespace detail
} // namespace binlog
Attention:  ./lib/binlog/detail/Core.C
#include <algorithm>

#include <binlog/detail/Core.H>
#include <binlog/detail/Time.H>
#include <binlog/detail/Entry.H>
#include <binlog/detail/WaitStrategy.H>

namespace binlog {
namespace detail {

Core& Core::getInstance()
{
  static Core instance;
  return instance;
}

void Core::reportThread(ThreadContextPtr& threadPtr)
{
  std::lock_guard<std::mutex> lock(_recentThreadsMutex);
  _recentThreads.push_back(threadPtr);
}

bool Core::empty()
{
  for (auto&& threadPtr : _threads)
  {
    if (threadPtr->getEntryQueue().empty() == false)
    {
      return false;
    }
  }

  std::lock_guard<std::mutex> lock(_recentThreadsMutex);
  for (auto&& threadPtr : _recentThreads)
  {
    if (threadPtr->getEntryQueue().empty() == false)
    {
      return false;
    }
  }

  return true;
}

bool Core::tryAcquire(const sink::ConsumerBase* pConsumer)
{
  const sink::ConsumerBase* prevConsumer = nullptr;
  return _consumer.compare_exchange_weak(prevConsumer, pConsumer);
}

bool Core::tryRelease(const sink::ConsumerBase* pConsumer)
{
  return _consumer.compare_exchange_weak(pConsumer, nullptr);
}

void Core::setConsumerWaitStrategy(WaitStrategy* pWaitStrategy)
{
  _consumerWaitStrategy.store(pWaitStrategy, std::memory_order_release);
}

void Core::notifyConsumer()
{
  WaitStrategy* pWaitStrategy = _consumerWaitStrategy.load(std::memory_order_acquire);
  if (pWaitStrategy != nullptr)
  {
    pWaitStrategy->notify();
  }
}

Core::Core()
  :_nextThread(_threads.begin()),
   _consumer(nullptr),
   _consumerWaitStrategy(nullptr)
{}

void Core::removeEmptyQueues()
{
  _threads.erase(std::remove_if(
    _threads.begin(),
    _threads.end(),
    [](const ThreadContextPtr& threadPtr)
    {
      return threadPtr.unique()
          && threadPtr->getEntryQueue().empty();
    }
  ), _threads.end());

  _nextThread = _threads.begin();
}

bool Core::writeTscSyncIfNeeded(char* target)
{
  static uint64_t last;
  auto now = readTsc();

  if (tscToSeconds(now - last) > 60*60*4)
  {
    Entry tscEntry(target);
    tscEntry.writeTSCSync();
    last = now;
    return true;
  }

  return false;
}

void Core::mergeRecentThreads()
{
  std::lock_guard<std::mutex> lock(_recentThreadsMutex);

  _threads.reserve(_threads.size() + _recentThreads.size());

  std::copy(
    std::make_move_iterator(_recentThreads.begin()),
    std::make_move_iterator(_recentThreads.end()),
    std::back_inserter(_threads)
  );

  _recentThreads.clear();
  _nextThread = _threads.begin();
}

} // namespace detail
} // namespace binlog
Attention:  ./lib/binlog/detail/Preamble.C
#include <cstdio>

#include <binlog/detail/Preamble.H>
#include <binlog/detail/Entry.H>

#include <binlog/reader/EventSourceStream.H>
#include <binlog/reader/detail/StructDefinitionStream.H>
#include <binlog/reader/detail/Buffer.H>

namespace binlog {
namespace detail {

Preamble& Preamble::getInstance()
{
  static Preamble instance;
  return instance;
}

void Preamble::addBuffer(const char* buffer, std::size_t size)
{
  std::lock_guard<std::mutex> lock(_mutex);
  addBuffer(lock, buffer, size);
}

void Preamble::addBinlogUserElf(const Elf& elf)
{
  std::lock_guard<std::mutex> lock(_mutex);
  resolveBinlogElf(lock, elf);
}

Preamble::Preamble()
{
  // Add TSC sync and Host prop entries
  _buffer.resize(EntryDefs::tscSyncSize + EntryDefs::hostPropMaxSize);

  Entry tscSync(_buffer.data());
  tscSync.writeTSCSync();

  Entry hostProp(_buffer.data() + tscSync.getSize());
  hostProp.writeHostProperties();

  _buffer.resize(tscSync.getSize() + hostProp.getSize());
}

void Preamble::addBuffer(std::lock_guard<std::mutex>&, const char* buffer, std::size_t size)
{
  _buffer.insert(_buffer.end(), buffer, buffer + size);

  if (_forward)
  {
    auto memory = getMemory(size);
    memcpy(memory.arena, buffer, size);
    memory.commit(size);
  }
}

namespace {

using WriteBuffer = binlog::reader::detail::WriteBuffer;

// Serialize the given Entity and give it a size and a tag, just like an Entry
template <typename Entity>
WriteBuffer serializeAsEntry(Entity& entity, EntryTag::EntryTag entryTag)
{
  WriteBuffer buffer;

  EntryDefs::entry_size_t size = 0;

  buffer.write(size); // will overwrite below
  buffer.write(entryTag);

  std::error_code ec;
  entity.serialize(buffer, ec);

  size = EntryDefs::entry_size_t(buffer.size());
  buffer.overwrite(0, size);

  return buffer;
}

} // namespace

void Preamble::resolveBinlogElf(std::lock_guard<std::mutex>& lock, const Elf& elf)
{
  // Extract event sources
  reader::EventSourceStream sources(elf);
  sources.consume([&](reader::entry::EventSource& source)
  {
    auto writeBuffer = serializeAsEntry(source, EntryTag::eventSource);
    addBuffer(lock, writeBuffer.get(), writeBuffer.size());
  });

  // Extract structure definitions
  reader::detail::StructDefinitionStream structDefs(elf);
  structDefs.consume([&](reader::entry::StructDefinition& structDef)
  {
    auto writeBuffer = serializeAsEntry(structDef, EntryTag::structDef);
    addBuffer(lock, writeBuffer.get(), writeBuffer.size());
  });
}

} // namespace detail
} // namespace binlog
Attention:  ./lib/binlog/detail/Error.C
#include <binlog/detail/Error.H>

namespace binlog {
namespace detail {
inline namespace error {

thread_local ErrorCategory g_errorCategory;

std::error_code make_error_code(Error error)
{
  return std::error_code(
    static_cast<int>(error),
    g_errorCategory
  );
}

std::ostream& setError(std::error_code& ec, Error error)
{
  static std::ostringstream ignoredMessage;

  if (!ec)
  {
    ec.assign(
      static_cast<int>(error),
      g_errorCategory
    );

    g_errorCategory._dynamicMessage.str(""); // clear previous message
    return g_errorCategory._dynamicMessage;
  }

  ignoredMessage.seekp(0);
  return ignoredMessage;
}

const char* ErrorCategory::name() const noexcept { return "binlog"; }

std::string ErrorCategory::message(int ev) const
{
  Error err = static_cast<Error>(ev);
  switch (err)
  {
  case Error::no_error:
    return "Success";
  case Error::runtime_error:
    return "Runtime error: " + _dynamicMessage.str();

  case Error::config_invalid_json:
    return "Failed to parse json config: " + _dynamicMessage.str();
  case Error::config_no_binlog_key:
    return "No 'binlog' key found in config file";
  case Error::config_invalid_severity:
    return "Failed to recognize severity: '" + _dynamicMessage.str() + "'";
  case Error::config_invalid_field:
    return "Failed to parse '" + _dynamicMessage.str();
  case Error::config_no_target_for_file:
    return "Missing mandatory 'target' argument for file sink";
  case Error::config_no_target_for_stream:
    return "Missing mandatory 'target' argument for stream sink";
  case Error::config_invalid_target_for_stream:
    return "Failed to parse 'target' field, expected 'cout', 'cerr' or 'clog'";
  case Error::config_invalid_sink:
    return "Unknown sink: '" + _dynamicMessage.str() + "'";
  case Error::config_invalid_predicate:
    return "Unknown predicate: '" + _dynamicMessage.str() + "'";

  case Error::end_of_stream:
    return "End of stream";
  case Error::invalid_entry_size:
    return "Invalid entry size: " + _dynamicMessage.str();
  case Error::no_tag_found:
    return "Entry tag not found";
  case Error::payload_too_short:
    return "Entry payload too short";
  case Error::invalid_type_tag:
    return "Invalid type tag found";
  case Error::no_string_arg:
    return "String argument not found";
  case Error::no_struct_id:
    return "Structure id not found";
  case Error::invalid_struct_id:
    return "Invalid struct id: '" + _dynamicMessage.str() + "'";
  case Error::no_array_size:
    return "Array size not found";
  case Error::no_array_type_spec:
    return "Array type spec not found";
  case Error::no_tuple_size:
    return "Tuple size not found";
  case Error::no_tuple_type_spec:
    return "Tuple type spec not found";
  case Error::no_variant_type_spec:
    return "Variant type spec not found";

  case Error::invalid_entry_tag:
    return "Invalid Entry tag: " + _dynamicMessage.str();

  case Error::no_tsc:
    return "TscSynchronization: TSC not found";
  case Error::no_time:
    return "TscSynchronization: wall clock time not found";
  case Error::no_timezone:
    return "TscSynchronization: timezone not found";
  case Error::no_cpu_freq:
    return "TscSynchronization: CPU frequency not found";

  case Error::no_source_id:
    return "EventSource: source id not found";
  case Error::no_instruction_pointer:
    return "EventSource: instruction pointer not found";
  case Error::no_category:
    return "EventSource: category not found";
  case Error::no_severity:
    return "EventSource: severity not found";
  case Error::no_format_string:
    return "EventSource: format string not found";
  case Error::no_type_codes:
    return "EventSource: type code not found";
  case Error::no_function:
    return "EventSource: function not found";
  case Error::no_file:
    return "EventSource: file not found";
  case Error::no_line:
    return "EventSource: line not found";
  case Error::no_program_code:
    return "EventSource: program code not found";

  case Error::no_sdef_id:
    return "StructureDefinition: struct id not found";
  case Error::no_sdef_name:
    return "StructureDefinition: struct name not found";
  case Error::no_sdef_fields:
    return "StructureDefinition: field vector not found";
  case Error::no_sdef_field_name:
    return "StructureDefinition: field name not found";
  case Error::no_sdef_field_type:
    return "StructureDefinition: field type tag not found";

  case Error::no_lwp:
    return "ThreadProp: LWP not found";
  case Error::no_thread_name:
    return "ThreadProp: Thread name not found";

  case Error::no_hostname:
    return "HostProp: hostname not found";

  case Error::no_ta_tsc:
    return "ThreadActivity: TSC not found";

  case Error::no_ess_category_id:
    return "EventSourceStream: category id not found";
  case Error::no_ess_severity:
    return "EventSourceStream: severity not found";
  case Error::no_ess_type_tags:
    return "EventSourceStream: type tags not found";
  case Error::no_ess_format_string:
    return "EventSourceStream: format string not found";

  case Error::invalid_source_id:
    return "Unknown source id: " + _dynamicMessage.str();

  case Error::not_binlog_user:
    return "ELF does not use binlog";
  case Error::section_not_found:
    return "Requested ELF section not found";

  case Error::file_open:
    return "Failed to open file: " + _dynamicMessage.str();

  default:
    return "Unknown Error";
  }
}

bool checkTrue(bool condition, std::error_code& ec, Error error)
{
  if (!condition)
  {
    setError(ec, error);
  }
  return condition;
}

} // namespace error
} // namespace detail
} // namespace binlog
Attention:  ./lib/binlog/sink/MultiSink.C
#include <cstdio>

#include <boost/property_tree/json_parser.hpp>

#include <binlog/sink/MultiSink.H>

#include <binlog/detail/EntryDefs.H>
#include <binlog/detail/Preamble.H>

#include <binlog/reader/detail/Buffer.H>

namespace binlog {
namespace sink {

/**
* Send entries in `buffer` to the matching sinks
*
* This method ought to be really simple,
* but because of the flow marker issue, it
* gets really complicated and requires a lot of
* house keeping.
*
* Assume the following user code:
*
* BINLOG_BEGIN_FLOW(...)
* BINLOG_DEBUG(...)
* BINLOG_END_FLOW(...)
*
* If the debug severity is disabled, we send two by default muted entries
* for no reason. A lot of similar case is possible, see the FlowMarkerFiltering.C
* test. In the solution below, for each enabled sink we iterate on the
* entries in the given buffer. The matching regular entries are added to a batch,
* non-matching entries are ignored (and the batch is sent to the sink if any).
* Flow marker entries are added to a sink && thread && flow specific pending area,
* and discarded or sent on demand.
*/
void MultiSink::operator()(const char* buffer, std::size_t bufferSize)
{
  using binlog::detail::EntryDefs;
  enum { headerSize = sizeof(Entry::entry_size_t) + sizeof(Entry::tag_t) };

  std::lock_guard<std::mutex> lock(_mutex);

  // Some entries are always sent on their own
  {
    const Entry::tag_t* pTag = reinterpret_cast<const Entry::tag_t*>(buffer + sizeof(Entry::entry_size_t));

    // If thread prop, save pointer, return
    if (bufferSize == EntryDefs::threadPropSize && *pTag == detail::EntryTag::threadProp)
    {
      _latestThreadProp = buffer;
      return;
    }

    // If TSC, send to enabled, return
    if (bufferSize == EntryDefs::tscSyncSize && *pTag == detail::EntryTag::tscSync)
    {
      for (auto&& sink : _sinks)
      {
        if (sink.enabled)
        {
          (*sink.impl)(buffer, bufferSize);
        }
      }
      return;
    }
  }

  if (! verifyEntryBuffer(buffer, bufferSize))
  {
    // The only known error triggering this branch is to log in a getter
    // while the enclosing object is being logged.
    fprintf(stderr, "[binlog] Sink encountered invalid Entry, drop buffer to prevent corruption\n");
    return;
  }

  // Some entries must be sent to disabled sinks as well
  // (EventSource, StructDef)
  // to maintain the proper parser state.
  // Also, the MultiSink must see the EventSources
  // to maintain the matching sources of the sinks.
  {
    reader::detail::ReadBuffer reader(buffer, bufferSize);
    while (reader.size() >= headerSize)
    {
      const Entry::entry_size_t* pSize = reinterpret_cast<const Entry::entry_size_t*>(reader.get());
      const Entry::tag_t* pTag = reinterpret_cast<const Entry::tag_t*>(reader.get() + sizeof(Entry::entry_size_t));

      if (
         *pTag == detail::EntryTag::eventSource
      || *pTag == detail::EntryTag::structDef
      )
      {
        // Send them to *disabled* sinks

        for (auto&& sink : _sinks)
        {
          if (sink.enabled == false)
          {
            (*sink.impl)(reader.get(), *pSize);
          }
        }

        if (*pTag == detail::EntryTag::eventSource)
        {
          processEventSource(reader.get() + headerSize, *pSize - headerSize, lock);
        }
      }

      reader.discard(*pSize);
    }
  }

  // Send matching entries to enabled sinks
  for (auto&& sink : _sinks)
  {
    if (sink.enabled == false) { continue; }

    const char* threadPropBuf = _latestThreadProp;

    reader::detail::ReadBuffer reader(buffer, bufferSize);
    const char* batchBegin = nullptr;
    std::size_t batchSize = 0;

    auto sendThreadPropIfNeeded = [&]()
    {
      if (threadPropBuf)
      {
        (*sink.impl)(threadPropBuf, EntryDefs::threadPropSize);
        threadPropBuf = nullptr;
      }
    };

    auto sendBatch = [&]()
    {
      if (batchSize)
      {
        sendThreadPropIfNeeded();
        (*sink.impl)(batchBegin, batchSize);
        batchSize = 0;
      }
    };

    while (reader.size() >= headerSize)
    {
      const Entry::entry_size_t* pSize = reinterpret_cast<const Entry::entry_size_t*>(reader.get());
      const Entry::tag_t* pTag = reinterpret_cast<const Entry::tag_t*>(reader.get() + sizeof(Entry::entry_size_t));

      if (*pTag >= detail::EntryTag::smallestSpec)
      {
        // add to batch
        if (!batchSize) { batchBegin = reader.get(); }
       batchSize += *pSize;
      }
      else if (sink.isMatchingSource(*pTag))
      {
        auto flowFinder = _flowSources.find(*pTag);

        if (flowFinder == _flowSources.end())
        {
          // regular entry
          if (!batchSize)
          {
            batchBegin = reader.get();
            sendThreadPropIfNeeded();
            sink.sendPendings(_latestThreadProp);
          }

          batchSize += *pSize;
        }
        else if (flowFinder->second.type == FlowSource::Type::BEGIN)
        {
          sendBatch();
          sink.addPending(_latestThreadProp, flowFinder->second.flowIndex, reader.get(), *pSize);
        }
        else if (flowFinder->second.type == FlowSource::Type::END)
        {
          if (sink.isFlowActive(_latestThreadProp, flowFinder->second.flowIndex))
          {
            // if flow is active, append this
            if (!batchSize) { batchBegin = reader.get(); }
            batchSize += *pSize;
          }
          else
          {
            // discard this entry by doing nothing, send the others
            sendBatch();
          }

          // discard the matching flow begin, if any
          sink.discardPending(_latestThreadProp, flowFinder->second.flowIndex);
        }
        else // if (flowFinder->type == FlowSource::Type::REGULAR)
        {
          sink.sendPendings(_latestThreadProp);

          if (!batchSize) { batchBegin = reader.get(); }
          batchSize += *pSize;

          sink.setFlowActive(_latestThreadProp, flowFinder->second.flowIndex);
        }
      }
      else
      {
        // ignore this entry, send the previous if any
        sendBatch();
      }

      reader.discard(*pSize);
    }

    // send last batch
    if (batchSize)
    {
      sendThreadPropIfNeeded();
      sink.sendPendings(_latestThreadProp);
      (*sink.impl)(batchBegin, batchSize);
    }

    // remaining flow markers will be needed in the next consume cycle
    sink.persistPendings(_latestThreadProp);
  }
}

void MultiSink::afterConsume()
{
  std::lock_guard<std::mutex> lock(_mutex);
  for (auto&& sink : _sinks)
  {
    sink.impl->afterConsume();
  }
}

void MultiSink::addSink(
  Sink& sink,
  const EventSourcePredicate& matchingSource,
  const SinkDescription& description
)
{
  AttachedSink attachedSink(sink, matchingSource, description);

  // add matching event sources we already know
  std::lock_guard<std::mutex> lock(_mutex);

  for (auto&& eventSource : _eventSources)
  {
    if (matchingSource(eventSource))
    {
      attachedSink.addMatchingSource(eventSource.sourceId());
    }
  }

  // feed preamble to the sink
  detail::Preamble::getInstance().readPreamble(
    [&](const char* buffer, std::size_t size)
    {
      sink(buffer, size);
    }
  );

  _sinks.push_back(std::move(attachedSink));
}

bool MultiSink::removeSink(const Sink& sink)
{
  std::lock_guard<std::mutex> lock(_mutex);

  auto beforeSize = _sinks.size();

  _sinks.erase(
    std::remove(_sinks.begin(), _sinks.end(), sink),
    _sinks.end()
  );

  return beforeSize != _sinks.size();
}

bool MultiSink::toggleSink(const Sink& sink, bool enable)
{
  std::lock_guard<std::mutex> lock(_mutex);
  for (auto&& attachedSink : _sinks)
  {
    if (attachedSink.impl == &sink)
    {
      attachedSink.enabled = enable;
      return true;
    }
  }

  return false;
}

std::vector<MultiSink::SinkDescription> MultiSink::getSinkDescriptions()
{
  std::vector<SinkDescription> descs;

  std::lock_guard<std::mutex> lock(_mutex);
  descs.reserve(_sinks.size());

  for (auto&& attachedSink : _sinks)
  {
    descs.push_back(attachedSink.getDescription());
  }

  return descs;
}

void MultiSink::processEventSource(
  const char* buffer, std::size_t size,
  std::lock_guard<std::mutex>&
)
{
  // deserialize event source
  reader::detail::ReadBuffer payload(buffer, size);
  std::error_code ec;
  reader::entry::EventSource source(payload, ec);
  if (ec)
  {
    fprintf(stderr, "[binlog] MultiSink encountered invalid EventSource: %s\n", ec.message().c_str());
    return;
  }

  // extract flows (for flow marker filtering)
  for (auto&& placeholder : source.parsedFormatString().getNamedPlaceholders())
  {
    // get or assign flow index
    std::size_t flowIndex = 0;
    for (; flowIndex < _appFlows.size() && _appFlows[flowIndex] != placeholder.second; ++flowIndex)
      ; // empty body
    if (flowIndex == _appFlows.size())
    {
      _appFlows.push_back(placeholder.second);
    }

    FlowSource::Type type = (source.isFlowBegin()) ? FlowSource::Type::BEGIN
                          : (source.isFlowEnd())   ? FlowSource::Type::END
                          :                          FlowSource::Type::REGULAR;

    _flowSources.emplace(source.sourceId(), FlowSource{unsigned(flowIndex), type});
  }

  // match source to sinks
  for (auto&& sink : _sinks)
  {
    if (sink.isMatchingSource(source))
    {
      sink.addMatchingSource(source.sourceId());
    }
  }

  // save the source, will need it when a new sink added later
  _eventSources.push_back(std::move(source));
}

MultiSink::AttachedSink::AttachedSink(
  Sink& sink,
  const EventSourcePredicate& predicate,
  const SinkDescription& description
)
  :impl(&sink),
   _predicate(predicate),
   _description(description)
{}

void MultiSink::AttachedSink::addMatchingSource(Entry::tag_t sourceId)
{
  _matchingSourceIds.insert(sourceId);
}

bool MultiSink::AttachedSink::isMatchingSource(Entry::tag_t sourceId) const
{
  return _matchingSourceIds.count(sourceId) > 0;
}

bool MultiSink::AttachedSink::isMatchingSource(const EventSource& source)
{
  return _predicate(source);
}

bool MultiSink::AttachedSink::operator==(const Sink& sink) const
{
  return impl == &sink;
}

MultiSink::SinkDescription MultiSink::AttachedSink::getDescription() const
{
  auto actualDescription = _description;

  try
  {
    std::stringstream strDesc;
    strDesc << actualDescription;

    boost::property_tree::ptree treeDesc;
    boost::property_tree::json_parser::read_json(strDesc, treeDesc);

    treeDesc.add("_enabled", enabled);
    treeDesc.add("_sourceCount", _matchingSourceIds.size());

    strDesc.str(""); // reset
    boost::property_tree::json_parser::write_json(strDesc, treeDesc);

    actualDescription = strDesc.str();
  }
  catch (const boost::property_tree::json_parser_error& ex)
  {
    // let it pass, desciption has a custom format.
  }

  return actualDescription;
}

void MultiSink::AttachedSink::addPending(
  const char* thread,
  const unsigned flowIndex,
  const char* buffer,
  const Entry::entry_size_t size
)
{
  _pendings[thread][flowIndex] = EntryRef{buffer, size};
}

namespace {
  static const char* activeFlowBegin = reinterpret_cast<const char*>(1);
} // namespace

void MultiSink::AttachedSink::sendPendings(const char* thread)
{
  auto thrPendings = _pendings.find(thread);
  auto thrPersPends = _persistedPendings.find(thread);

  if (thrPendings != _pendings.end())
  {
    for (auto&& entryIt : thrPendings->second)
    {
      if (entryIt.second.begin > activeFlowBegin)
      {
        (*impl)(entryIt.second.begin, entryIt.second.size);
        entryIt.second.begin = activeFlowBegin;

        // discard persisted preceding matching entry
        if (thrPersPends != _persistedPendings.end())
        {
          thrPersPends->second.erase(entryIt.first);
        }
      }
    }
  }

  if (thrPersPends != _persistedPendings.end())
  {
    for (auto&& entryIt : thrPersPends->second)
    {
      if (entryIt.second.size)
      {
        (*impl)(entryIt.second.begin.get(), entryIt.second.size);
      }
      _pendings[thread][entryIt.first].begin = activeFlowBegin;
    }
    thrPersPends->second.clear();
  }
}

void MultiSink::AttachedSink::discardPending(const char* thread, const unsigned flowIndex)
{
  auto pfinder = _pendings.find(thread);
  if (pfinder != _pendings.end())
  {
    pfinder->second.erase(flowIndex);
  }

  auto ppfinder = _persistedPendings.find(thread);
  if (ppfinder != _persistedPendings.end())
  {
    ppfinder->second.erase(flowIndex);
  }
}

void MultiSink::AttachedSink::persistPendings(const char* thread)
{
  auto pfinder = _pendings.find(thread);
  if (pfinder != _pendings.end())
  {
    for (auto&& entryIt : pfinder->second)
    {
      PersistedEntry& persisted = _persistedPendings[thread][entryIt.first];
      if (entryIt.second.begin > activeFlowBegin)
      {
        persisted.begin.reset(new char[entryIt.second.size]);
        memcpy(persisted.begin.get(), entryIt.second.begin, entryIt.second.size);
        persisted.size = entryIt.second.size;
      } // else: default constructed is just fine
    }

    _pendings.erase(pfinder);
  }
}

void MultiSink::AttachedSink::setFlowActive(const char* thread, const unsigned flowIndex)
{
  _pendings[thread][flowIndex].begin = activeFlowBegin;
}

bool MultiSink::AttachedSink::isFlowActive(const char* thread, const unsigned flowIndex) const
{
  auto pfinder = _pendings.find(thread);
  if (pfinder != _pendings.end())
  {
    auto ffinder = pfinder->second.find(flowIndex);
    if (ffinder != pfinder->second.end() && ffinder->second.begin == activeFlowBegin)
    {
      return true;
    }
  }

  auto ppfinder = _persistedPendings.find(thread);
  if (ppfinder != _persistedPendings.end())
  {
    auto ffinder = ppfinder->second.find(flowIndex);
    if (ffinder != ppfinder->second.end() && ffinder->second.size == 0)
    {
      return true;
    }
  }

  return false;
}

bool MultiSink::verifyEntryBuffer(const char* buffer, std::size_t bufferSize) const
{
  while (bufferSize >= sizeof(Entry::entry_size_t))
  {
    auto entrySize = *reinterpret_cast<const Entry::entry_size_t*>(buffer);
    if (entrySize <= bufferSize && entrySize >= sizeof(entrySize))
    {
      bufferSize -= entrySize;
      buffer += entrySize;
    }
    else { return false; }
  }

  return bufferSize == 0;
}

} // namespace sink
} // namespace binlog
Attention:  ./lib/binlog/sink/PlaintextSink.C
#include <binlog/sink/PlaintextSink.H>

namespace binlog {
namespace sink {

PlaintextSink::PlaintextSink(Consumer consumer)
  :_consumer(std::move(consumer)),
   _entryStream(_buffer),
   _events(_entryStream)
{}

void PlaintextSink::operator()(const char* buffer, std::size_t size)
{
  _buffer.reset(buffer, size);
  _events.consume(_consumer);
}

} // namespace sink
} // namespace binlog
Attention:  ./lib/binlog/sink/FileSink.C
#define _LARGEFILE64_SOURCE
#define _FILE_OFFSET_BITS 64

#include <sstream>
#include <stdexcept>
#include <errno.h>
#include <fcntl.h>  // open
#include <unistd.h> // write, fsync
#include <cstring> // strerror
#include <zlib.h> // see compress()
#include <sys/stat.h> // fchmod
#include <memory>

#include <boost/preprocessor/stringize.hpp>

#include <binlog/sink/FileSink.H>

#include <binlog/detail/Preamble.H>

namespace binlog {
namespace sink {

FileSink::FileSink(const std::string& logfile)
  :_path(logfile),
   _lastRotation(clock::now()),
   _fileSizeLimit(0),
   _fileAgeLimit(std::chrono::seconds::zero())
{
  if ( ! open(logfile))
  {
    throw std::runtime_error("Failed to open logfile: '" + logfile + "'");
  }
}

FileSink::FileSink(FileSink&& rhs)
  :_path(std::move(rhs._path)),
   _logfile(std::move(rhs._logfile)),
   _nextIndex(rhs._nextIndex),
   _bytesWritten(rhs._bytesWritten),
   _lastRotation(rhs._lastRotation),
   _fileSizeLimit(rhs._fileSizeLimit.load()),
   _fileAgeLimit(rhs._fileAgeLimit.load())
{
  rhs._nextIndex = 0;
}

namespace {

bool nextAvailableName(
  std::string& name, unsigned& startIndex, detail::Fd& opened, const std::string& suffix = {}
)
{
  std::ostringstream rotName;
  rotName << name << '.';
  auto indexPos = rotName.tellp();

  auto index = startIndex;

  // open the next available file: _path.fileIndex
  while (! opened && index - startIndex < 2048)
  {
    rotName.seekp(indexPos);
    rotName << index++ << suffix;

    opened = ::open(rotName.str().c_str(), O_WRONLY | O_LARGEFILE | O_CREAT | O_EXCL);
  }

  if (! opened) { return false; }

  name = rotName.str();
  startIndex = index;
  return true;
}

bool compress(const std::string& infile, detail::Fd& outfd, unsigned level, const char*& err)
{
  // open input
  detail::Fd infd(::open(infile.c_str(), O_RDONLY | O_LARGEFILE));
  if (! infd)
  {
    err = strerror(errno);
    return false;
  }

  // open gz output stream
  // cannot use infd directly or the Fd wrapper,
  // gzclose closes the underlying fd if gzdopen succeeds
  int gzd = dup(*outfd);
  gzFile outgz = gzdopen(gzd, "wb");

  if (!outgz)
  {
    close(gzd);
    int errnum;
    err = gzerror(outgz, &errnum);
    return false;
  }

  // set compression level
  int normLevel = int(std::max(1u, std::min(level, 9u)));
  gzsetparams(outgz, normLevel, Z_DEFAULT_STRATEGY);

  // read input / write output
  const unsigned bufferSize = 64 * 1024;
  std::unique_ptr<char[]> buffer(new char[bufferSize]);

  ssize_t readSize = 0;
  while ((readSize = read(*infd, buffer.get(), bufferSize)) > 0)
  {
    auto writeSize = unsigned(readSize);
    if (! gzwrite(outgz, buffer.get(), writeSize))
    {
      int errnum;
      err = gzerror(outgz, &errnum);
      gzclose_w(outgz);
     return false;
    }
  }

  // if there was a read error
  if (readSize < 0)
  {
    gzclose_w(outgz);
    err =  strerror(errno);
    return false;
  }

  // cleanup
  gzclose_w(outgz);

  // chmod r--r--r-- compressed file
  fchmod(*outfd, S_IRUSR|S_IRGRP|S_IROTH);

  // remove uncompressed file
  if(unlink(infile.c_str()) != 0)
  {
    err = strerror(errno);
    return false;
  }

  return true;
}

} // namespace

bool FileSink::open(const std::string& path)
{
  if (_logfile) { return false; }

  // owner: rwx, group: rx, other: rx
  auto permissions = S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;

  // try to open, but look for already present file
  _logfile = ::open(path.c_str(), O_WRONLY | O_LARGEFILE | O_CREAT | O_EXCL, permissions);

  if (! _logfile)
  {
    // there's already a file at `path`
    // try to move it away

    bool compressed = false;

    // try to compress file
    if (_compressionLevel)
    {
      const char* errmsg = "Unknown error";

      auto compressedPath = path;
      auto index = _nextIndex;
      detail::Fd compressFd;

      if (nextAvailableName(compressedPath, index, compressFd, ".gz"))
      {
        // compress will also unlink path
        compressed = compress(path, compressFd, _compressionLevel, errmsg);
      }

      if (! compressed)
      {
        fprintf(stderr, "[binlog] Failed to compress rotated file: %s\n", errmsg);
      }
    }

    if (! compressed) // Compression disabled or failed to compress
    {
      std::string rotatedName = path;
      detail::Fd opened;

      if (nextAvailableName(rotatedName, _nextIndex, opened))
      {
        rename(path.c_str(), rotatedName.c_str());
      }
    }

    // try open again, truncate if something gets into the way
    _logfile = ::open(path.c_str(), O_WRONLY | O_LARGEFILE | O_CREAT | O_TRUNC, permissions);
  }

  if (! _logfile) { return false; }

  _path = path;

  // add #! /path/to/installed/Reader
  const char shebang[] = "#!" BOOST_PP_STRINGIZE(BINLOG_READER_BINARY) "\n";
  (*this)(shebang, sizeof(shebang) - 1);

  return true;
}

void FileSink::operator()(const char* buffer, std::size_t size)
{
  std::size_t rsize = size;

  do
  {
    ssize_t wsize = write(*_logfile, buffer, rsize);

    if (wsize >= 0)
    {
      rsize -= std::size_t(wsize);
      buffer += wsize;
    }
    else if (errno != EINTR)
    {
      // TODO let the application know about the sink failure
      fprintf(stderr, "[binlog] FileSink failed to write file: %s\n", strerror(errno));
      return;
    }
    // else: EINTR, try again
  }
  while (rsize);

  _bytesWritten += size;
}

void FileSink::afterConsume()
{
  fsync(*_logfile);

  const auto sizeLimit = _fileSizeLimit.load();
  const auto ageLimit = _fileAgeLimit.load();

  const bool rotationNeeded =
     (sizeLimit                                && _bytesWritten                >= sizeLimit)
  || (ageLimit != std::chrono::seconds::zero() && clock::now() - _lastRotation >= ageLimit);

  if (rotationNeeded)
  {
    bool rotateOk = rotate();
    if (! rotateOk)
    {
      fprintf(stderr, "[binlog] Log file rotation failed: %s\n", strerror(errno));
    }

    // reset these counters anyway,
    // rather than try to rotate all the time on failure
    _bytesWritten = 0;
    _lastRotation = clock::now();
  }
}

void FileSink::rotateBySize(std::size_t fileSizeLimit)
{
  _fileSizeLimit.store(fileSizeLimit);
}

void FileSink::rotateByTime(std::chrono::seconds elapsedTimeLimit)
{
  _fileAgeLimit.store(elapsedTimeLimit);
}

void FileSink::compression(bool enable)
{
  _compressionLevel = (enable) ? 9u : 0u;
}

bool FileSink::rotate()
{
  if (! _logfile) { return false; }

  // try to reopen path, open will move away
  // the original file
  {
    detail::Fd oldLog(std::move(_logfile));

    if (! open(_path))
    {
      // failed to move away target,
      // keep everything as is
      _logfile = std::move(oldLog);
      return false;
    }
  }

  // add preamble to the rotated file
  detail::Preamble::getInstance().readPreamble(
    [this](const char* buffer, std::size_t size)
    {
      (*this)(buffer, size);
    }
  );

  return true;
}

} // namespace sink
} // namespace binlog
Attention:  ./lib/binlog/sink/SingleConsumer.C
#include <binlog/sink/SingleConsumer.H>
#include <binlog/sink/FileSink.H>
#include <binlog/sink/StreamSink.H>
#include <binlog/sink/SyslogSink.H>

namespace binlog {
namespace sink {

SingleConsumer& SingleConsumer::getInstance()
{
  static SingleConsumer instance;
  return instance;
}

SingleConsumer::~SingleConsumer()
{
  /*
   * stop() now, stopping in ~Consumer<>
   * is too late, the _sinkPtr would
   * be destroyed by then.
   */
  stop();
}

FileSink& SingleConsumer::setFileSink(const std::string& logfile)
{
  return setSink<FileSink>(logfile);
}

StreamSink& SingleConsumer::setStreamSink(std::ostream& output, const std::string& format)
{
  return setSink<StreamSink>(output, format);
}

SyslogSink& SingleConsumer::setSyslogSink()
{
  return setSink<SyslogSink>();
}


} // namespace sink
} // namespace binlog
Attention:  ./lib/binlog/sink/AnySink.C
#include <cstddef> // std::size_t

#include <binlog/sink/AnySink.H>

#include <binlog/detail/Preamble.H>

namespace binlog {
namespace sink {

void AnySink::setSink(Sink& sink)
{
  // add preamble
  detail::Preamble::getInstance().readPreamble(
    [&](const char* buffer, std::size_t size)
    {
      sink(buffer, size);
    }
  );

  _sink = &sink;
}

} // namespace sink
} // namespace binlog
Attention:  ./lib/binlog/sink/Consumer.C
#include <binlog/sink/Consumer.H>

namespace binlog {
namespace sink {

ConsumerBase::ConsumerBase(binlog::detail::Core& core)
  :_core(core)
{
  if ( ! _core.tryAcquire(this))
  {
    // Failed to claim core, there's an other consumer.

    /*
     * Note to user:
     *
     * If you are receiving this exception, you have too much
     * consumers running in your application. E.g:
     *
     * SingleConsumer::getInstance();
     * MultiConsumer::getInstance(); // exception here
     */
    throw std::runtime_error("[binlog] Other consumer detected");
  }
}

ConsumerBase::~ConsumerBase()
{
  if (_pWaitStrategy)
  {
    _core.setConsumerWaitStrategy(nullptr);
  }

  _core.tryRelease(this);
}

void ConsumerBase::setWaitStrategy(WaitStrategy* pWaitStrategy)
{
  _pWaitStrategy = pWaitStrategy;
  _core.setConsumerWaitStrategy(_pWaitStrategy);
}

} // namespace sink
} // namespace binlog
Attention:  ./lib/binlog/sink/SyslogSink.C
#include <sstream>
#include <syslog.h>

#include <binlog/sink/SyslogSink.H>

#include <binlog/reader/PrettyPrinter.H>

namespace binlog {
namespace sink {

namespace {

int severityToSyslogPriority(binlog::Severity severity)
{
  switch (severity)
  {
  case binlog::trace    : return LOG_DEBUG;
  case binlog::debug    : return LOG_DEBUG;
  case binlog::info     : return LOG_INFO;
  case binlog::warning  : return LOG_WARNING;
  case binlog::error    : return LOG_ERR;
  case binlog::critical : return LOG_CRIT;
  default               : return 0;
  }
}

class Consumer
{
public:
  Consumer(const std::string& format)
  {
    _printer.setEventFormat(format + "\n");
  }

  void operator()(PlaintextSink::Event& event);

private:
  reader::PrettyPrinter _printer;
};

void Consumer::operator()(PlaintextSink::Event& event)
{
  std::stringstream out;
  _printer.print(event, out);
  int severity = severityToSyslogPriority(event.source().severity());
  syslog(severity, "%s", out.str().c_str());
}

} // namespace

SyslogSink::SyslogSink(const std::string& format, const char* program, int option, int facility)
  :_plaintextSink(Consumer(format))
{
  openlog(program, option, facility);
}

SyslogSink::SyslogSink(const std::string& format)
  :SyslogSink(format, nullptr, LOG_NDELAY, LOG_USER)
{}

SyslogSink::SyslogSink()
  :SyslogSink("%S %C %t %N %m")
{}

void SyslogSink::operator()(const char* buffer, std::size_t size)
{
  _plaintextSink(buffer, size);
}

} // namespace sink
} // namespace binlog
Attention:  ./lib/binlog/sink/MultiConsumer.C
#include <algorithm>

#include <binlog/sink/MultiConsumer.H>
#include <binlog/sink/FileSink.H>
#include <binlog/sink/StreamSink.H>
#include <binlog/sink/SyslogSink.H>

namespace binlog {
namespace sink {

MultiConsumer& MultiConsumer::getInstance()
{
  static MultiConsumer instance;
  return instance;
}

MultiConsumer::~MultiConsumer()
{
  /*
   * stop() now, stopping in ~Consumer<>
   * is too late, the `_sinks` would
   * be destroyed by then.
   */
  stop();
}

void MultiConsumer::addSink(
  std::unique_ptr<Sink> sinkPtr,
  const EventSourcePredicate& predicate,
  const SinkDescription& description
)
{
  getSink().addSink(*sinkPtr, predicate, description);
  _sinks.push_back(std::move(sinkPtr));
}

FileSink& MultiConsumer::addFileSink(const std::string& logfile)
{
  SinkDescription description;
  //description.emplace("target", logfile);
  //description.emplace("predicate", "any");

  return addFileSink(logfile, [](const EventSource&) { return true; }, description);
}

FileSink& MultiConsumer::addFileSink(
  const std::string& logfile,
  const EventSourcePredicate& predicate,
  const SinkDescription& description
)
{
  return addSink<FileSink>(predicate, description, logfile);
}

StreamSink& MultiConsumer::addStreamSink(std::ostream& output, const std::string& format)
{
  SinkDescription description;
  //description.emplace("format", format);
  //description.emplace("predicate", "not-control");

  return addStreamSink(
    output, format,
    [](const EventSource& es) { return es.severity() != binlog::control; },
    description
  );
}

StreamSink& MultiConsumer::addStreamSink(
  std::ostream& output, const std::string& format,
  const EventSourcePredicate& predicate,
  const SinkDescription& description
)
{
  return addSink<StreamSink>(predicate, description, output, format);
}

SyslogSink& MultiConsumer::addSyslogSink()
{
  SinkDescription description;
  //description.emplace("predicate", "error");

  return addSink<SyslogSink>(
    [](const EventSource& es)
    {
      return es.severity() != binlog::control && es.severity() >= binlog::error;
    },
    description
  );
}

SyslogSink& MultiConsumer::addSyslogSink(
  const EventSourcePredicate& predicate,
  const SinkDescription& description
)
{
  return addSink<SyslogSink>(predicate, description);
}

bool MultiConsumer::removeSink(const Sink* sink)
{
  if (getSink().removeSink(*sink))
  {
    _sinks.erase(
      std::remove_if(
        _sinks.begin(), _sinks.end(),
        [sink](const std::unique_ptr<Sink>& sinkPtr)
        {
          return sinkPtr.get() == sink;
        }
      ),
      _sinks.end()
    );

    return true;
  }

  return false;
}

bool MultiConsumer::toggleSink(const Sink* sink, bool enable)
{
  return getSink().toggleSink(*sink, enable);
}

std::vector<Sink*> MultiConsumer::listSinks()
{
  std::vector<Sink*> result;
  result.reserve(_sinks.size());

  std::transform(
    _sinks.begin(), _sinks.end(), std::back_inserter(result),
    [](std::unique_ptr<Sink>& sinkPtr) { return sinkPtr.get(); }
  );

  return result;
}

void MultiConsumer::describeSinks(std::ostream& output)
{
  auto descs = getSink().getSinkDescriptions();
  for (auto&& desc : descs)
  {
    output << desc << "\n";
  }
}

} // namespace sink
} // namespace binlog
Attention:  ./lib/binlog/Severity.C
#include <binlog/Severity.H>

namespace binlog {

const char* severityToString(const Severity severity)
{
  switch (severity)
  {
  case trace    : return "TRAC";
  case debug    : return "DEBG";
  case info     : return "INFO";
  case warning  : return "WARN";
  case error    : return "ERRO";
  case critical : return "CRIT";
  case control  : return "CTRL";
  case none     : return "NONE";
  case unknown  : break;
  }

  return "UNKW";
}

Severity stringToSeverity(const std::string& severity)
{
  if (severity == "TRAC" || severity == "trace"   ) { return trace    ; }
  if (severity == "DEBG" || severity == "debug"   ) { return debug    ; }
  if (severity == "INFO" || severity == "info"    ) { return info     ; }
  if (severity == "WARN" || severity == "warning" ) { return warning  ; }
  if (severity == "ERRO" || severity == "error"   ) { return error    ; }
  if (severity == "CRIT" || severity == "critical") { return critical ; }
  if (severity == "CTRL" || severity == "control" ) { return control  ; }
  if (severity == "NONE" || severity == "none"    ) { return none     ; }

  return unknown;
}

namespace detail {

Severity nextSeverity(const Severity severity)
{
  if (trace <= severity && severity < none)
  {
    return static_cast<Severity>(severity << 1);
  }
  else if (severity == none)
  {
    return none;
  }
  else
  {
    return unknown;
  }
}

} // namespace detail

} // namespace binlog
Attention:  ./test/perf/UTune.HPP
#ifndef BINLOG_TEST_PERF_UTUNE_HPP_
#define BINLOG_TEST_PERF_UTUNE_HPP_

#include <cstring>

#ifdef BINLOG_UTUNE
  #include <utune/probes.h>
#endif

namespace binlog {
namespace utune {

#ifdef BINLOG_UTUNE

#define UTUNE_PROBE(name) UTUNE_PROBES_INLINE_PROBE(name)

#else // BINLOG_UTUNE

#define UTUNE_PROBE(name) {}

#endif // BINLOG_UTUNE

} // namespace utune
} // namespace binlog


#endif /* BINLOG_TEST_PERF_UTUNE_HPP_ */
Attention:  ./test/integration/modules/HeaderLog.HPP
#ifndef BINLOG_TEST_INTEGRATION_MODULES_HEADERLOG_HPP
#define BINLOG_TEST_INTEGRATION_MODULES_HEADERLOG_HPP

#include "HeaderLog.H"

BINLOG_DEFINE_CATEGORY(header, "m/p/header")

#endif // BINLOG_TEST_INTEGRATION_MODULES_HEADERLOG_HPP
Attention:  ./lib/binlog/detail/Entry.HPP
#ifndef BINLOG_DETAIL_ENTRY_HPP_
#define BINLOG_DETAIL_ENTRY_HPP_

#include <binlog/detail/Entry.H>
#include <binlog/detail/Serialize.H>
#include <binlog/detail/Time.H>
#include <binlog/detail/ThisThreadContext.H>

namespace binlog {
namespace detail {

#if defined BINLOG_PRODUCERS_NOTIFY_CONSUMER
inline std::size_t criticalLoad(const Queue& q)
{
  #if defined BINLOG_CRIT_LOAD_FACTOR
    // user defined threshold
    return q.maxRequestSize() * (100 - BINLOG_CRIT_LOAD_FACTOR) / 100;
  #else
    // default threshold is at 80% queue load
    return q.maxRequestSize() * 20 / 100;
  #endif
}
#endif

struct WriteMemoryHandle
{
  Queue* queue;
  char* arena;

  void commit(std::size_t size)
  {
    queue->commit(size);
  }
};

__attribute__((visibility("default")))
void notifyConsumer();

__attribute__((visibility("default")))
void incrementCategoryThresholds();

__attribute__((visibility("default")))
inline WriteMemoryHandle getMemory(const std::size_t size)
{
  auto* queue = & ThisThreadContext::get().getEntryQueue();
  char* arena = queue->reserve(size);

  #if defined BINLOG_PRODUCERS_NOTIFY_CONSUMER
  if (__builtin_expect(queue->writeAvailable() < criticalLoad(*queue), false))
  {
    notifyConsumer();
  }
  #endif

  if (__builtin_expect(! arena, false))
  {
    incrementCategoryThresholds();
    ThisThreadContext::resetQueue(size * 2);
    queue = & ThisThreadContext::get().getEntryQueue();
    arena = queue->reserve(size);
  }

  return WriteMemoryHandle{queue, arena};
}

template <typename... Args>
void Entry::createLog(
  const tag_t formatId,
  Args&&... args
)
{
  const std::size_t lsize =
    sizeof(Entry::entry_size_t)
  + sizeof(Entry::tag_t)
  + sizeof(Entry::tsc_t)
  + argumentsSerializedSize(std::forward<Args>(args)...);

  const Entry::tsc_t now = readTsc();

  auto memory = getMemory(lsize);

  // create entry
  Entry entry(memory.arena);

  auto size = entry_size_t(lsize);

  // copy fields into _data
  entry.write(size);
  entry.write(formatId);
  entry.write(now);
  serializeArguments(entry, std::forward<Args>(args)...);

  memory.commit(lsize);
}

} // namespace detail
} // namespace binlog

#endif /* BINLOG_DETAIL_ENTRY_HPP_ */
