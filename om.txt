Attention:  AlertTypes.H
#pragma once
#include <ets/procStatusMgr/core/Message.H>
#include <OR/fixMessage/fixBinMessage/Message.H>
#include <MSBase/MSMemoryBuffer.H>
#include <boost/noncopyable.hpp>

namespace ets { namespace fix { namespace bin {
  class Message;
}}}

namespace ets { namespace vx { namespace om {

class ClientOrder;      // forward
class ExchangeOrder;    // forward

namespace alert {
// DELARE_VX_ORDER_ALERT should only be used by vx stack
// these alerts are resetable as the order object will contain a uint32_t mask to record the raised alerts. 

#ifndef VX_ORDER_ALERT_IMPL
#define VX_ORDER_ALERT_REGISTER(NAME)
#else
bool __registerOrderAlert(uint32_t value_, const std::string& name_);
#define VX_ORDER_ALERT_REGISTER(NAME) \
bool NAME::_registered = __registerOrderAlert(NAME::value, NAME::type())
#endif

#define DECLARE_VX_ORDER_ALERT(NAME, SEVERITY, BIT_ID) \
struct NAME \
{ \
  static const std::string& type() \
  { \
    static const std::string type_name(#NAME); \
    return type_name; \
  } \
  static ets::app::proc::Message::Severity severity() \
  { \
    return ets::app::proc::Message::SEVERITY; \
  } \
  static const uint32_t value = BIT_ID; \
  static const uint32_t mask = 1 << BIT_ID; \
  static bool _registered; \
}; \
VX_ORDER_ALERT_REGISTER(NAME);

DECLARE_VX_ORDER_ALERT(PendingRequest,                   Major   ,  0)
DECLARE_VX_ORDER_ALERT(OrderRejected,                    Major   ,  1)
DECLARE_VX_ORDER_ALERT(ReplaceRejected,                  Major   ,  2)
DECLARE_VX_ORDER_ALERT(CancelRejected,                   Major   ,  3)
DECLARE_VX_ORDER_ALERT(TestAlert,                        Major   ,  4)
DECLARE_VX_ORDER_ALERT(OrderFrozen,                      Major   ,  5)
DECLARE_VX_ORDER_ALERT(MaxEvalFreqReached,               Critical,  6)
DECLARE_VX_ORDER_ALERT(DroppedMessage,                   Major   ,  7)
DECLARE_VX_ORDER_ALERT(BadPriceBreach,                   Major   ,  8)
DECLARE_VX_ORDER_ALERT(TradeBust,                        Major   ,  9)
DECLARE_VX_ORDER_ALERT(TradeCorrection,                  Major   , 10)
DECLARE_VX_ORDER_ALERT(OverFill,                         Major   , 11)
DECLARE_VX_ORDER_ALERT(UnknownProduct,                   Major   , 12)
DECLARE_VX_ORDER_ALERT(SendMessageFailed,                Critical, 13)
DECLARE_VX_ORDER_ALERT(AssertionFailure,                 Critical, 14)
DECLARE_VX_ORDER_ALERT(ProductError,                     Major   , 15)
DECLARE_VX_ORDER_ALERT(ProfileError,                     Major   , 16)
DECLARE_VX_ORDER_ALERT(TimerError,                       Major   , 17)
DECLARE_VX_ORDER_ALERT(InvalidOrderFlow,                 Major   , 18)
DECLARE_VX_ORDER_ALERT(EvalDisabled,                     Major   , 19)
DECLARE_VX_ORDER_ALERT(DestinationNotFound,              Major   , 20)
DECLARE_VX_ORDER_ALERT(ReporterError,                    Major   , 21)
DECLARE_VX_ORDER_ALERT(TradeStatus,                      Major   , 22)
DECLARE_VX_ORDER_ALERT(AllocationFailure,                Major   , 23)
DECLARE_VX_ORDER_ALERT(RecoveryFailure,                  Major   , 24)
DECLARE_VX_ORDER_ALERT(VGLMCheckLimitBreach,             Major   , 25)
DECLARE_VX_ORDER_ALERT(VGLMConfigChange,                 Minor   , 26)
DECLARE_VX_ORDER_ALERT(OrderInconsistent,                Major   , 27)
DECLARE_VX_ORDER_ALERT(ConditionalOrderRejected,         Major   , 28)
DECLARE_VX_ORDER_ALERT(ConditionalOrderReplaceRejected,  Major   , 29)
#undef DECLARE_VX_ORDER_ALERT

extern const std::string NULL_DATA;

// for vx internal ussage
bool __raiseAlert(const std::string& alertType_, 
                  const std::string& alertKey_,
                  const std::string& alertText_,
                  ets::app::proc::Message::Severity alertSeverity_);

void __clearAlert(const std::string& alertType_,
                  const std::string& alertKey_);

bool __raiseOrderAlert(const om::ClientOrder& co_,
                       const std::string& alertText_,
                       const std::string& alertType_,
                       const ets::app::proc::Message::Severity alertSeverity_);

void __clearOrderAlert(const om::ClientOrder& co_, const std::string& alertType_);

bool __raiseOrderAlert(const om::ExchangeOrder& eo_,
                       const std::string& alertText_,
                       const std::string& alertType_,
                       const ets::app::proc::Message::Severity alertSeverity_);

void __clearOrderAlert(const om::ExchangeOrder& eo_, const std::string& alertType_);

bool __raiseOrderAlert(
  const fix::bin::Message& msg_,
  const std::string& symbol_,
  const std::string& alertText_,
  const std::string& alertType_,
  const ets::app::proc::Message::Severity alertSeverity_);

void __clearOrderAlert(
  const fix::bin::Message& msg_,
  const std::string& alertType_);

// public API
template <typename AlertT>
inline bool raiseOrderAlert(const om::ClientOrder& co_, const std::string& alertText_)
{
  return __raiseOrderAlert(co_, alertText_, AlertT::type(), AlertT::severity());
}

template <typename AlertT>
inline void clearOrderAlert(const om::ClientOrder& co_)
{
  return __clearOrderAlert(co_, AlertT::type());
}

template <typename AlertT>
inline bool raiseOrderAlert(const om::ExchangeOrder& eo_, const std::string& alertText_)
{
 return __raiseOrderAlert(eo_, alertText_, AlertT::type(), AlertT::severity());
}

template <typename AlertT>
inline void clearOrderAlert(const om::ExchangeOrder& eo_)
{
  return __clearOrderAlert(eo_, AlertT::type());
}

template <typename AlertT>
bool raiseOrderAlert(
  const fix::bin::Message& msg_,
  const std::string& symbol_,
  const std::string& alertText_)
{
  return __raiseOrderAlert(msg_, symbol_, alertText_, AlertT::type(), AlertT::severity());
}

template <typename AlertT>
void clearOrderAlert(const fix::bin::Message& msg_)
{
  __clearOrderAlert(msg_, AlertT::type());
}

// please ensure the combination of the alertType and the alertKey must be unique, 
// otherwise the later alert will override the previous alert.
template <std::size_t N>
bool raiseInstanceAlert(const char (&alertType_)[N], 
                        const std::string& alertKey_,
                        const std::string& alertText_,
                        ets::app::proc::Message::Severity alertSeverity_ = ets::app::proc::Message::Major)
{
  assert(!alertKey_.empty() && !alertText_.empty());
  return __raiseAlert(std::string(alertType_, N-1), alertKey_, alertText_, alertSeverity_);
}

template <std::size_t N>
void clearInstanceAlert(const char (&alertType_)[N],
                        const std::string& alertKey_)
{
  assert(!alertKey_.empty());
  __clearAlert(std::string(alertType_, N-1), alertKey_);
}

void printOrderAlert(uint32_t mask_, std::string& value_);

// configure alert filters either through configuration or net admin
bool configureAlerterFilters(const MSHDOMElementPtr& config);
std::string alertFilterDesc();
bool setAlertFilter(const std::string& filterName, const std::string& filterExpr, std::string* error);

//
// Raise Alert
//  RAII interface which accepts stream input of the alert text;
//   on destruction, uses the accumulated stream to raise the alert.
//  Usage:
//    AlertStream(VGLMConfigChange(), _id)          // use alert types from DECLARE_ALERT() above
//        << "Limits: an error occurred around " << somevalue << "...";
//    AlertStream("VGLMProductUpdate", _id, Minor)  // alert types defined on use
//        << "Limits: an error occurred around " << somevalue << "...";
//
struct AlertStream : private boost::noncopyable
{
  using Severity = ets::app::proc::Message::Severity;

  AlertStream(const std::string& alertType_, const std::string& alertKey_, const Severity alertSeverity_)
    : _alertType(alertType_), _alertKey(alertKey_), _alertSeverity(alertSeverity_)
  {
    assert( !_alertKey.empty() );
  }

  // use declared alert types for AlertType and Severity values
  template <typename AlertT>
  AlertStream(const AlertT unused_var_because_ctor_cant_have_explicit_templ_arg, const std::string& alertKey_)
    : AlertStream(AlertT::type(), alertKey_, AlertT::severity())
  { }

  ~AlertStream() 
  { // raise the alert
    assert( !_alertTextStream.asString().empty() );
    ets::vx::om::alert::__raiseAlert(_alertType, _alertKey, _alertTextStream.asString(), _alertSeverity);
  }
  
  // operator<<(anything), shunted to internal ostrstream
  template<typename T>
  AlertStream& operator<<(const T& t) { _alertTextStream << t; return *this; }

protected:
  MSMemoryBufferOStrStream<2048> _alertTextStream;
  const std::string _alertType;
  const std::string _alertKey;
  const ets::app::proc::Message::Severity _alertSeverity;
}; // end class AlertStream

//
// Log & Raise Alert
//  RAII interface which accepts stream input of the alert text;
//   on destruction: flushes accumulated text to ORlogError and raises the alert.
//  ** NB: NOT FOR CRITICAL PATH USAGE due to use of slow ORLog.
//  Note that the alert mechanism already creates log entries; this class should 
//   only be used for cases where a clear human-readable log entry is desired
//   and time is not at a premium (e.g., startup code, or off-critical-path threads).
//  Usage:  (identical to AlertStream)
//    AlertAndLogStream(VGLMConfigChange(), _id)          // use alert types from DECLARE_ALERT() above
//        << "Limits: an error occurred around " << somevalue << "...";
//    AlertAndLogStream("VGLMProductUpdate", _id, Minor)  // alert types defined on use
//        << "Limits: an error occurred around " << somevalue << "...";
//
struct AlertAndLogStream : public AlertStream
{ // NB: NOT FOR CRITICAL PATH USAGE!

  // inherit AlertStream constructors
  using AlertStream::AlertStream;

  ~AlertAndLogStream() 
  { // flush to ORlogError; base AlertStream dtor will raise the alert
    ORlogError << _alertTextStream.asString() << ORLog::send;
  }
}; // end class AlertAndLogStream

} // end namepsace alerts

}}} // end namespace ets::vx::om
Attention:  AsyncQueryableHandler.H
///////////////////////////////////////////////////////////////////////////////
//
// Copyright 2013 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef ets_vx_om_AsyncQueryableHandler_H
#define ets_vx_om_AsyncQueryableHandler_H

#include "RemoteQueryProxy.H"
#include "ExchangeOrderFsmTypes.H"
#include "OrderQueryUtil.H"
#include "RecoveryUtil.H"

#include <ets/vx/common/ThreadContext.H>
#include <ets/vx/common/Primitives.H>
#include <ets/vx/om/ClientOrder.H>
#include <ets/vx/om/ExchangeOrder.H>
#include <ets/vx/om/StripeContext.H>

#include <OR/fixMessage/fixBinMessage/Message.H>

#include <MSBase/MSHashSet.H>

namespace ets { namespace vx { namespace om {

/// \brief An abstraction of a common handler with async query functionality
///
/// AsyncQueryableHandler provides a default implementation for handling the
/// retrieved query result, in order for resue by any other concrete handler
/// implementations, e.g. SortHandler
///
/// The concrete handler deriving from AsyncQueryableHandler should have the
/// following API contract
///
/// HandlerT::tc(); - returns the associated ThreadContext
/// HandlerT::sc(); - returns the associated StripeContext
/// HandlerT::onQueryFailed(); - handles query failures
template <typename HandlerT>
class AsyncQueryableHandler : public QueryHandlerInterface
{
protected:
  HandlerT&       self()       { return static_cast<HandlerT&>(*this); }
  const HandlerT& self() const { return static_cast<const HandlerT&>(*this); }

  void onQueryResultRetrieved(const ets::vx::msg::ExchangeReportPtr& response_,
                              void*                                  pForwardExecutionUserData_,
                              oom::recovery::QueryResult&            result_);

  bool prepareSuspendedMessage(const ets::vx::msg::ExchangeReportPtr& response_,
                               oom::recovery::QueryResult&            result_);

private:
  void consolidateOrderStates(const ets::vx::msg::ExchangeReportPtr& response_,
                              void*                                  pForwardExecutionUserData_,
                              oom::recovery::QueryResult&            result_);
};

template <typename HandlerT>
void AsyncQueryableHandler<HandlerT>::onQueryResultRetrieved(const ets::vx::msg::ExchangeReportPtr& response_,
                                                             void*                                  pForwardExecutionUserData_,
                                                             oom::recovery::QueryResult&            result_)
{
  if (!result_.code)
  {
    self().onQueryFailed(response_, result_.code);
    return;
  }

  if (!result_.bindedOrders.empty())
  {
    // For SORT, we should find CO & EO in retrieved order state
    oom::recovery::BindedOrderMap& orders = result_.bindedOrders;
    assert(orders.find(oom::Order::Direction::In)  != orders.end() &&
           orders.find(oom::Order::Direction::Out) != orders.end());

    // Restore the order state
    consolidateOrderStates(response_, pForwardExecutionUserData_, result_);
  }

  if (!self().prepareSuspendedMessage(response_, result_))
  {
    ORlogError << "Failed to combine query result with pending messages"
               << ORLog::send;
    return;
  }
}

template <typename HandlerT>
bool AsyncQueryableHandler<HandlerT>::prepareSuspendedMessage(const ets::vx::msg::ExchangeReportPtr& response_,
                                                              oom::recovery::QueryResult&            result_)
{
  if (result_.execution)
  {
    const oom::Execution& execution = result_.execution.get();

    // Apply retrieved information to the current response
    response_->RefLastShares = doubleToQty(execution.lastShares());
    response_->RefLastPrice = execution.lastPx();

    ORlogDebug << "Execution retrieved , execId [" << execution.initialExecID()
               << "], response ref last price = [" << response_->RefLastPrice
               << "], response last price = [" << response_->LastPx
               << "], response ref last shares = [" << qtyToDouble(response_->RefLastShares)
               << "], response last shares = [" << qtyToDouble(response_->LastShares)
               << "], last shares = [" << execution.lastShares()
               << ORLog::send;

    const fix::bin::TagValueGroup& m = execution.data();
    if (!response_->msg().hasTag(ORFixUserTag::FillUUId))
    {
      std::string fillUuid;
      if (m.getPair(ORFixUserTag::FillUUId, fillUuid))
      {
        // Stamp FillUUId here.  When the task continuation is invoked
        // later, VX will think FillUUId is stampped by downstream and
        // do not generate FillUUId by its own
        response_->msg().setPair(ORFixUserTag::FillUUId, MSUuid(fillUuid, true)); // convert from legacy string
      }
    }

    if (!response_->msg().hasTag(ORFixUserTag::FillVId))
    {
      uint32_t fillVId;
      if (m.getPair(ORFixUserTag::FillVId, fillVId))
      {
        // Increment and stamp FillVId.  When the task continuation is
        // invoked later, VX will think FillVId is stampped by downstream
        // and do not generate FillVId by its own
        response_->msg().setPair(ORFixUserTag::FillVId, ++fillVId);
      }
    }
  }

  return true;
}



template <typename HandlerT>
void AsyncQueryableHandler<HandlerT>::consolidateOrderStates(const ets::vx::msg::ExchangeReportPtr& response_,
                                                             void*                                  pForwardExecutionUserData_,
                                                             oom::recovery::QueryResult&            result_)
{
  oom::OrderData& clientData = result_.bindedOrders[oom::Order::Direction::In];
  oom::OrderData& exchangeData = result_.bindedOrders[oom::Order::Direction::Out];
  common::ReturnCode rc;

  // The retrieved EO state might have more executions applied since vOOM
  // may receive more messages at EO side and it lacks causal ordering for
  // now.  If only EO receives the execution, that execution is not binded
  // in CO.  Therefore, we can diff CO execIds and EO execIds from the
  // query result, find all the executions unprocessed in CO, query for
  // them individually, revert the executions from EO state.
  oom::ExecIDSet unbindedExecIds = getUnbindedExecIds(clientData.execIds(), exchangeData.execIds());

  ets::vx::common::LightStringRef execId;
  response_->getExecID(execId);

  if (unbindedExecIds.find(execId.asString()) != unbindedExecIds.end())
  {
    ets::vx::om::ExchangeOrderEvent::Enum event = ets::vx::om::eventType(*response_);
    if (event == ets::vx::om::ExchangeOrderEvent::ExchangeTradeCancel ||
        event == ets::vx::om::ExchangeOrderEvent::ExchangeTradeCorrect)
    {
      revertOrderState(event, response_, result_.execution.get(), const_cast<oom::OrderData&>(exchangeData).state());
    }
    else // Fill or PartialFill
    {
      revertOrderState(event, response_, oom::Execution(response_->msg()), const_cast<oom::OrderData&>(exchangeData).state());
    }
  }

  // Recover the order based on the consolidated order state.  Bring the
  // order to the state before it's just about to handle THE response_
  ets::vx::common::ThreadContext& tc = self().tc();
  ets::vx::om::StripeContext* sc = self().sc(clientData.state().currentTradingData());
  if (!sc)
  {
    ORlogError << "Failed to process recovered messages: no StripeContext. "
               << "CO [" << clientData.orderUUId() << "] "
               << "EO [" << exchangeData.orderUUId() << "]"
               << ORLog::send;
    return;
  }

  ets::vx::om::ClientOrder* clientOrder = 0;
  rc = tc.com().processRecoveredMsg(clientData, *sc, tc, clientOrder, /* migrated_ = */ false, /* recovery_ = */ false);
  if(!rc)
  {
    ORlogError << "Failed to process recovered message for CO "
               << "Error [" << rc.asString() << "] "
               << "CO [" << clientData.orderUUId() << "] "
               << "EO [" << exchangeData.orderUUId() << "]"
               << ORLog::send;
    return;
  }

  // TODO kaic: prepareExchOrderState
  MSHashSet<std::string> emptyExecIds; // TODO kaic: populate execIds properly
  oom::ExecutionMap execMap;
  rc = tc.eom().processRecoveredMsg(exchangeData, execMap, *sc, tc, emptyExecIds, /* recovery_ = */ false);
  if(!rc)
  {
    ORlogError << "Failed to process recovered message for EO "
               << "Error [" << rc.asString() << "] "
               << "CO [" << clientData.orderUUId() << "] "
               << "EO [" << exchangeData.orderUUId() << "]"
               << ORLog::send;
    return;
  }

  // XXX HACK calibriate vid caused by reverting the order state
  ets::vx::common::LightStringRef eoUUId(exchangeData.orderUUId().data(), exchangeData.orderUUId().size());
  ets::vx::om::ExchangeOrder* exchangeOrder = tc.eom().findOrder(eoUUId);
  if (!exchangeOrder)
  {
    exchangeOrder = tc.eom().findClosedOrder(eoUUId);
  }
  if (!exchangeOrder)
  {
    ORlogError << "Failed to find recovered EO [" << eoUUId << "] "
               << "CO [" << clientData.orderUUId() << "] "
               << ORLog::send;
    return;
  }
  //exchangeOrder->setOrderVID(exchangeOrder->orderVID() - unbindedExecIds.size() - 1);

  rc = clientOrder->handleRestart(clientData);
  if(!rc)
  {
    ORlogError << "Failed to restart the CO "
               << "Error [" << rc.asString() << "] "
               << "CO [" << clientData.orderUUId() << "] "
               << "EO [" << exchangeData.orderUUId() << "]"
               << ORLog::send;
    return;
  }

  clientOrder->onRecoveryComplete();

  ORlogInfo << "Client / Exchange order states consolidated "
            << "CO [" << clientData.orderUUId() << "] "
            << "EO [" << exchangeData.orderUUId() << "]"
            << ORLog::send;
}

}}}

#endif

Attention:  BaseOrder.H
#pragma once

#include <vector>
#include <list>
#include <queue>
#include "StripeContext.H"
#include "ClientOrderManager.H"
#include "ErrorCode.H"
#include <ets/vx/common/Primitives.H>
#include <ets/vx/common/LightString.H>
#include <ets/vx/common/ReturnCode.H>
#include <ets/vx/msg/ClientRequest.H>
#include <ets/vx/orderProfile/OrderProfile.H>

namespace ets { namespace vx { namespace om {

constexpr EvalTriggerEvents NON_SLICE_TRIGGERS = EvalTriggerEvent::ForceEval
                                                ^ EvalTriggerEvent::SliceRejected
                                                ^ EvalTriggerEvent::SlicePartiallyFilled
                                                ^ EvalTriggerEvent::SliceFullyFilled
                                                ^ EvalTriggerEvent::SliceCanceled
                                                ^ EvalTriggerEvent::SliceCancelRejected
                                                ^ EvalTriggerEvent::SliceReplaced
                                                ^ EvalTriggerEvent::SliceReplaceRejected
                                                ^ EvalTriggerEvent::SliceUnsolCxled
                                                ^ EvalTriggerEvent::SliceTradeCanceled
                                                ^ EvalTriggerEvent::SliceTradeCorrected;

constexpr EvalTriggerEvents FORCE_EVAL_EVENT = EvalTriggerEvent::NewOrderReceived
                                               | EvalTriggerEvent::ReplaceRequestReceived
                                               | EvalTriggerEvent::AdminForceEval
                                               | EvalTriggerEvent::EvalErrorReview
                                               | EvalTriggerEvent::ClosedOrderReopened
                                               | EvalTriggerEvent::ReplaceRequestAcked
                                               | EvalTriggerEvent::ReplaceRejected
                                               | EvalTriggerEvent::EffectiveTimeExpired
                                               | EvalTriggerEvent::SliceRejected
                                               | EvalTriggerEvent::SliceCancelRejected
                                               | EvalTriggerEvent::SliceReplaceRejected;

class BaseOrder
{
public:
  BaseOrder(common::ThreadContext& tc_, char* allocatorStateBuf_ = nullptr, bool noAllocatorStateBuf_ = false);
  ~BaseOrder();
  void setSide(common::Side::Enum side_) { assert(!_side); assert(side_); _side=side_; }
  common::Side::Enum side() const { assert(_side); return _side; }
  bool isBuy() const { assert(_side); return common::isBuy(_side); }

  common::OrdType::Enum ordType() const { return _ordType; }
  void setOrdType(common::OrdType::Enum ordType_) { _ordType = ordType_; }

  Quantity  targetQty()  const {return _targetQty; }


  common::price_t targetPrice()const {return _targetPrice; }

  void setTargetPrice(common::price_t price_) { _targetPrice = price_; }

  common::LightStringRef symbol() const {return _symbol;}

  om::StripeContext& stripeContext() const {assert (_stripeContext); return *_stripeContext; }

  EvalTriggerMask triggerSelfEvalOnBitMask() const { return _triggerSelfEvalOnBitMask; }
  void setTriggerEvalOnBitMask(EvalTriggerMask bitMask_) { _triggerSelfEvalOnBitMask = bitMask_; }

  EvalTriggerMask targetTriggerSelfEvalOnBitMask() const { return _targetTriggerSelfEvalOnBitMask; }
  void setTargetTriggerEvalOnBitMask(EvalTriggerMask bitMask_) { _targetTriggerSelfEvalOnBitMask = bitMask_; }

  // _targetTriggerSelfEvalOnBitMask will take EvalMask from the previous successful, and will not be changed till next Eval.
  void commitTrigerEvalOnBitMask() { _triggerSelfEvalOnBitMask = _targetTriggerSelfEvalOnBitMask; }

  void setProfile(orderProfile::OrderProfile* profile_)
  {
    assert(_allocatorStateBuf);
    if (!_allocatorStateBuf) return;
    if (_profile)
    {
      _profile->_profileType->destroyAllocatorStateBuffer(_allocatorStateBuf);
    }
    _profile=profile_;
    _profile->_profileType->initAllocatorStateBuffer(_allocatorStateBuf);
  }

  common::Side::Enum _side;
  common::OrdType::Enum _ordType;

  Quantity _targetQty;
  common::price_t _targetPrice;

  common::LightStringRef _symbol;

  om::StripeContext* _stripeContext;

  char* _allocatorStateBuf;
  orderProfile::OrderProfile* _profile;
protected:
  EvalTriggerMask _triggerSelfEvalOnBitMask;
  EvalTriggerMask _targetTriggerSelfEvalOnBitMask;

  common::ThreadContext& _tc;

};

class LegOrder : public BaseOrder
{
  friend class NotionalClientOrder;
public:
  typedef fix::bin::RepeatingGroupEntry OrderMessage;
  LegOrder(const msg::ClientLegRequestPtr&, common::ThreadContext& tc_);
  common::OrdStatus::Enum ordStatus() const { /*assert(_ordStatus);*/ return _ordStatus; }
  common::LightStringRef clOrdID() const { return _lastLegUpdateMsgPtr->ClOrdID; }
  const MSUuid& orderUUId() const { return _lastLegUpdateMsgPtr->OrderUUId; }
  msg::ClientLegRequestPtr current() const { return _lastLegUpdateMsgPtr; }
  void addPocketFill(Quantity _cumQty, Amount _cumValue)
  {
    _pocketCumQty += _cumQty;
    _pocketCumValue += _cumValue;
  }
  void removePocketFill(Quantity _cumQty)
  {
    assert(_cumQty > QuantityZero);
    if (_cumQty >= _pocketCumQty)
    {
      _pocketCumQty = QuantityZero;
      _pocketCumValue = AmountZero;
    }
    else
    {
      _pocketCumValue -= _pocketCumValue / _pocketCumQty._val * _cumQty._val;
      _pocketCumQty -= _cumQty;
    }
  }

  Quantity leavesQty() const
  {
    if( _ordStatus==common::OrdStatus::Cancelled || _ordStatus==common::OrdStatus::Rejected )
      return QuantityZero;

    return _currentQty-_cumQty;
  }

  void addFill(Quantity fillQty_, Amount fillValue_)
  {
    _cumQty += fillQty_;
    _cumValue += fillValue_;
  }

  void removeFill(Quantity fillQty_, Amount fillValue_)
  {
    _cumQty -= fillQty_;
    _cumValue -= fillValue_;
  }

  LegId legId() const { return _legId; }

  Quantity pocketCumQty() const { return _pocketCumQty; }
  Quantity  cumQty()     const {return _cumQty; }
  Amount   pocketCumValue() const { return _pocketCumValue; }
  Quantity  pocketQty()  const {return _pocketQty; }
  Quantity  currentQty() const {return _currentQty; }
  Amount    cumValue()   const {return _cumValue; }
  common::price_t currentPrice()const {return _currentPrice; }

  void reducePocketQty(Quantity qty_)  {assert(qty_ >= QuantityZero); _pocketQty -= qty_; }
  void increasePocketQty(Quantity qty_)  {assert(qty_ >= QuantityZero); _pocketQty += qty_; }

  void setOrdStatus(common::OrdStatus::Enum ordStatus_) { _ordStatus = ordStatus_; }
  double avgPx() const { return _cumQty > QuantityZero ? _cumValue._val / stripeContext().priceScalingFactor()._doubleToScale / _cumQty._val : 0.0; }

private:
  // cumqty/value that has NOT been attributed to any clips
  Quantity _pocketCumQty;
  Amount   _pocketCumValue;

  Quantity _currentQty;
  Quantity _pocketQty;
  Quantity _cumQty;
  common::price_t _currentPrice;
  Amount _cumValue;
  LegId  _legId;

  common::OrdStatus::Enum _ordStatus;
  msg::ClientLegRequestPtr _lastLegUpdateMsgPtr;
};


enum Enum
{
  INVALID_CLIP_ID=65535,
  INVALID_LEG_ID =255
};

class NotionalClientOrder;
class LegSlice;
class Clip : public BaseOrder
{
  friend class NotionalClientOrder;
public:
  Clip(NotionalClientOrder* nco_, ClipId id_, common::ThreadContext& tc_, char* allocatorStateBuf_ = nullptr);
  ~Clip();
  ClipId clipId() const { return _clipId; }
  NotionalClientOrder& parent() const { return *_nco; }
  double cumQty() const { return _cumQty; } 
  double maxPossibleCumQty() const { return _maxPossibleCumQty; }
  const std::vector<LegSlice*>& legs() { return _legs; }
  EvalTriggerEvents addLegFill(Quantity fillQty_, Amount fillValue_, LegId legId_,  bool fillFromOwnChild_=true);
  void removeLegFill(Quantity fillQty_, Amount fillValue_, LegId legId_);
  const LegSlice* getLeg(LegId index_) const { return _legs[index_]; }
  LegSlice* getLeg(LegId index_) { return _legs[index_]; }
  void setTargetQty(Quantity qty_);
  Quantity qtyInNotional(LegId index_, Quantity qty_) const { return qty_.multiplyAndRound(_qtyRatio[index_]); }
  double dqtyInNotional(LegId index_, Quantity qty_) const { return qtyToDouble(qty_) * _qtyRatio[index_]; }
  Quantity qtyInLeg(LegId index_, Quantity qty_) const { assert(_qtyRatio[index_]); return qty_.divideAndRound(_qtyRatio[index_]); }
  Quantity dqtyInLeg(LegId index_, double qty_) const { assert(_qtyRatio[index_]); return doubleToQty(qty_ / _qtyRatio[index_]); }
  Quantity pocketQty() const;
  void updateQtyRatio(LegId index_);
  void updateQtyRatioes();
  void setLegTargetQty(LegId index_, Quantity qty_);
  void roundUpLegTargetQty(LegId index_);
  void roundDownLegTargetQty(LegId index_) ;
  void expectMarketDataEvent();
  void performPostEvalActions();
  bool isFinished() const { return doubleToQty(_cumQty) == _targetQty; }

  void commitTrigerEvalOnBitMask();

  
private:
  Clip(ClipId id_, int legsize_, common::ThreadContext& tc_, char* allocatorStateBuf_ = nullptr); // only for unit test

  void updateCumQty();
  void adjustQty();

  common::ReturnCode processEvaluation(std::list<NodeId>& evaluatedNodes_, EvalTriggerEvents event_);
  common::ReturnCode allocate();

  bool shouldSelfEvalOn(EvalTriggerEvents evt_) const;

  double _qtyRatio[MaxNumOfLegs()];
  double _maxPossibleCumQty; 
  double _cumQty;
  NotionalClientOrder* _nco;
  ClipId _clipId;
  std::vector<LegSlice*> _legs;
};

class LegSlice : public BaseOrder
{
  friend class Clip;
  friend class NotionalClientOrder;
public:
  LegSlice(Clip* parent_, ClipId cid_, LegId lid_, common::ThreadContext& tc_, char* allocatorStateBuf_ = nullptr);
  ~LegSlice();
  Clip& parent() const { return *_parent; }
  ClipId clipId() const { return _clipId; }
  LegId  legId() const { return _legId; }
  Quantity qtyToAlloc() const { return _qtyToAlloc; }
  Quantity cumQty() const { return _cumQty; }
  Quantity requiredClipPocketQty() const { return _requiredClipPocketQty; }
  void setQtyToAlloc(Quantity qtyToAlloc_) { _qtyToAlloc = qtyToAlloc_; }
 void setRequiredClipPocketQty(Quantity qty_) { _requiredClipPocketQty = qty_; }

  common::ReturnCode processEvaluation(exch::AllocationEntries& allocationEntries_, std::list<NodeId>& evaluatedNodes, EvalTriggerEvents);
  common::ReturnCode allocate(exch::AllocationEntries& allocationEntries_);
  EvalTriggerEvents addFill(Quantity fillQty_, Amount fillValue_, bool fillFromOwnChild_=true);

  bool shouldSelfEvalOn(EvalTriggerEvents evt_) const ;
  double avgPx() const { return _cumQty > QuantityZero ? _cumValue._val / stripeContext().priceScalingFactor()._doubleToScale / _cumQty._val : 0.0; }
  Amount cumValue() const { return _cumValue; }

  void increaseOpenQty(Quantity delta_) { _openQty += delta_; }
  void reduceOpenQty(Quantity delta_) 
  { 
    _openQty -= delta_;  
    // in such case, delta could greater than _openQty.
    // Clip size 500, leg slice open 500.
    // Clip get amend down to 400 (openQty will be amend to 400), and trigger cancel on open slice.
    // slice cancel succeed, delta is 500.
    if (_openQty<QuantityZero)
      _openQty = QuantityZero;
  }
  Quantity pocketQty() const { return _targetQty - _openQty; }
  uint32_t getUserData() const { return _userData; }
  void setUserData(uint32_t data_) { _userData = data_; }

  Quantity childIOCLeaveQty() const { return _childIOCLeavesQty; }
  void increaseChildIOCLeavesQty(Quantity qty_) { _childIOCLeavesQty += qty_; }
  void reduceChildIOCLeavesQty(Quantity qty_) { _childIOCLeavesQty -= qty_; }
  void expectMarketDataEvent();
  void performPostEvalActions();
  void commitTrigerEvalOnBitMask();

private:
  LegSlice(ClipId cid_, LegId lid_, common::ThreadContext& tc_, char* allocatorStateBuf_ = nullptr);

  void setTargetQty(Quantity qty_);

  Clip* _parent;
  Quantity _openQty;
  Quantity _qtyToAlloc;
  Quantity _childIOCLeavesQty;
  Quantity _requiredClipPocketQty;
  Quantity _cumQty;
  const ClipId _clipId;
  const LegId  _legId;
  Amount _cumValue;
  uint32_t _userData;
};

NodeId createNodeId(ClipId clipId_, LegId legId_);
void parseNodeId(NodeId nodeid_, ClipId& clipId_, LegId& legId_);


}}}

Attention:  ClientOrder.H
#pragma once

#include "ErrorCode.H"
#include "ExchangeSliceOperation.H"
#include "EvalConditionRepository.H"
#include "ReplaceRequestEvaluators.H"
#include "PrePostEvalRepository.H"
#include "ClientOrderManager.H"
#include "PuntToBackupReplaceRequestEvaluator.H"
#include "DeltaEngine.H"
#include <ets/vxperf/xprobes/xprobes.H>
#include <ets/vx/common/FixMsg.H>
#include <ets/vx/common/Transaction.H>
#include <ets/vx/msg/ClientRequest.H>
#include <ets/vx/msg/ClientReport.H>
#include <ets/vx/om/RestateTags.H>
#include <ets/vx/logging/logging.H>
#include <ets/vx/limits/LimitContext.H>
#include "ClientOrderListNode.H"
#include "../common/Primitives.H"
#include "StripeContext.H"
#include "../common/QuantityToAllocate.H"
#include "../timer/TimerManager.H"
#include "../common/LightList.H"
#include "../staticStruct/StaticStruct.H"
#include "../orderProfile/OrderProfileManager.H"
#include "../orderProfile/OrderProfile.H"
#include "Fwd.H"

#include <OR/fixTag/ORFixUserTag.H>
#include <OR/fixMessage/fixMessage/ORFixMessage.H>

#define CONDITIONALLY_SET(bitField, mask, cond) bitField = (bitField & ~mask) | (-cond & mask)

//FIXME: we should figure out a way to set this through orderprofile instead.
#define DEFAULT_EVAL_TRIGGERS (EvalTriggerEvent::SliceTradeCanceled   \
                             | EvalTriggerEvent::SliceTradeCorrected  \
                             | EvalTriggerEvent::SliceRejected        \
                             | EvalTriggerEvent::SliceReplaceRejected \
                              )

namespace ets { namespace vx { namespace om {

DECLARE_FIXEDSIZE_MEMORY_ALLOCATOR(ForceEvalTimer)
DECLARE_FIXEDSIZE_MEMORY_ALLOCATOR(EvalThrottlingTimer)
DECLARE_FIXEDSIZE_MEMORY_ALLOCATOR(EvalErrorReviewTimer)
DECLARE_FIXEDSIZE_MEMORY_ALLOCATOR(EffectiveTimeTimer)
DECLARE_FIXEDSIZE_MEMORY_ALLOCATOR(OrderExpireTimer)

typedef uint32_t LightFilterAttrBitset;

using ets::vx::om::RestateTags;

class ClientOrderGhost;     // forward declaration; defined in ClientOrderManager.H

// ClientOrder
class ClientOrder : public boost::noncopyable
{
    friend class ClientOrderFSM;
    friend class ClientOrderManager;
    friend class AllocationModelTestCase;
    friend class ClientOrderFSMTestCase;
    friend class NetAdminTestCase;
    friend class EvalThrottlingTimer;
    friend class EvalErrorReviewTimer;
    friend class ForceEvalTimer;
    friend class EffectiveTimeTimer;
    friend class OrderExpireTimer;
    friend class PendingRequestClientTimer;

    friend class ExchangeSlicer; // unit testing stub
    friend class AllocatorTestHelper; // for unit testing

    struct Flags
    {
        enum Enum
        {
            TRIGGER_POST_EVENT_EVAL = 0x01,
            OPTIMISTIC_ACK_OVERRIDE = 0x02,
            CXL_ON_EXCHANGE_OUT     = 0x04,
            WAS_REPLACED            = 0x08,
            DEFER_SET_EXPIRE_TIMER  = 0x10,
            MIGRATED                = 0x20,
            LIMIT_BREACHED          = 0x40,
        };
    };

public:
    struct DisableEvalBitMask
    {
        // If any of the these are true eval will be disabled.
        // A single if check of the entire bit mask is used
        // to verify if eval can proceed.
        enum Enum
        {
            IS_FROZEN                  =  0x01,
            IS_THROTTLED               =  0x02,
            IN_PENDING_CXL_STATE       =  0x04,
            IS_CLOSED                  =  0x08,
            FORCE_DISABLED             =  0x10,
            WAITING_FOR_EFFECTIVE_TIME =  0x20,
            ORDER_EXPIRED              =  0x40,
            UNDER_RECOVERY             =  0x80,
            PENDING_PULL_BACK          = 0x100,
            IS_PUNTED                  = 0x200
        };

        static std::string asString(uint32_t) ;
    };

    typedef ReplaceActionEnum (*ClientReplaceRequestEvaluator) (ClientOrderEvent::Enum, ClientOrder&, ExchangeOrder*, common::ReturnCode&, void* pUserData);
    typedef common::ReturnCode (*ClientCancelRequestEvaluator) (ClientOrder&, msg::ClientRequestPtr, void* pUserData, bool admin_);
    typedef fix::bin::Message OrderMessage;

    explicit ClientOrder(common::ThreadContext& tc_, char* allocatorStateBuf_ = nullptr);
    virtual ~ClientOrder();

    virtual void resolveOrderProfile() = 0;

    common::ReturnCode resolveState(const oom::OrderData& orderData_, bool recovery_ = true);
    void onRecoveryComplete();
    bool validateRecoveredState(std::ostringstream& os_, bool alert_);
    common::ReturnCode handleRestart(const ets::oom::OrderData& orderData_);

    void init(StripeContext* sc_, bool isListOrder_, void* clientTransportChannel_);

    bool isListOrder() const { return _isListOrder; }

    const vx::msg::ClientRequestPtr current() const
    {
      assert(_lastOrderUpdateMsgPtr.isValid());
      return _lastOrderUpdateMsgPtr;
    }
    //TODO: consider remembering this through a pointer.
    const vx::msg::ClientRequestPtr target() const
    {
      if( _pendingReplaceRequestMsgPtr ) //?? set current message as pending replace like we do in EO? Remove if?
        return _pendingReplaceRequestMsgPtr;
      return _lastOrderUpdateMsgPtr;
    }
    const vx::msg::ClientRequestPtr pendingReplaceRequest() const
    {
      assert(_pendingReplaceRequestMsgPtr.isValid());
      return _pendingReplaceRequestMsgPtr;
    }
    const vx::msg::ClientRequestPtr pendingCancelRequest() const
    {
      assert(_pendingCancelRequestMsgPtr.isValid());
      return _pendingCancelRequestMsgPtr;
    }
    StripeContext& stripeContext() const {assert (_stripeContext); return *_stripeContext; }
    // return the legStripeContext if CO is ListOrder, otherwise same as CO stripeContext
    StripeContext& stripeContextForEO(const ExchangeOrder& eo_) const 
    {
      return isListOrder() ? stripeContext().getLegStripeContext(eo_.current().legId()) : stripeContext();
    }

    common::ReturnCode puntToBackup(const common::LightStringRef& str, bool adminTriggered_);
    bool isPunted() const;

    void forceEval();
    void handleEvalError(common::ReturnCode err);
    virtual void handleEvalErrorImpl(common::ReturnCode err);

    //IMPORTANT: pocketQty may exceed leavesQty temporarily in the event of a slice overfill
    //However, overfills will always trigger an eval, and the deltaEngine will send cancels for the overfilled slices
    Quantity  pocketQty()  const {return _pocketQty; }
    // This method required by ExchangeSliceOperation & ExchangeOrderManager::replaceExchangeOrder for sanity check
    // The name can NOT be pocketQty otherwise calvin binding will fail
    Quantity  getPocketQty(const exch::AllocationEntry& ae_) const;
    Quantity  allocatableQty()  const {return _pocketQty + std::min(_targetQty - _currentQty, QuantityZero); }
    void reducePocketQty(Quantity qty_, ExchangeOrder&);
    void increasePocketQty(Quantity qty_, ExchangeOrder&);

    Quantity currentQty() const { return _currentQty; }//??rename to currentOrderQty, targetOrderQty

//    vx::common::price_t getPriceField(const vx::msg::ExchangeRequestPtr& msgPtr_, int tag_) const;
    common::LightStringRef symbol() const { return _lastOrderUpdateMsgPtr->Symbol(); }
    common::LightStringRef clOrdID() const { return _lastOrderUpdateMsgPtr->ClOrdID(); }
    const MSUuid& orderUUId() const { return _lastOrderUpdateMsgPtr->OrderUUId; }
    common::TimeInForce::Enum timeInForce() const { return _lastOrderUpdateMsgPtr->TimeInForce; }

    void setSide(common::Side::Enum side_) { assert(!_side); assert(side_); _side=side_; }
    common::Side::Enum side() const { assert(_side); return _side; }
    bool isBuy() const { assert(_side); return common::isBuy(_side); }
    common::price_t targetPrice() const { return _targetPrice; }
    common::price_t currentPrice() const { return _currentPrice; }
    common::price_t tradeablePrice() const
    {
      if( !isPendingReplace() )
        return _currentPrice;
  
      //Client may change order type
      if (current()->OrdType.isMarketOrderType())
        return _targetPrice;

      //Client may change order type
      if (target()->OrdType.isMarketOrderType())
        return _currentPrice;

      return isBuy() ?
          std::min(_targetPrice, _currentPrice): 
          std::max(_targetPrice, _currentPrice);
    }
    common::OrdType tradeableOrdType() const 
    {
      if (!isPendingReplace())
        return current()->OrdType;
      // limit order type has higher priority than market order type
      // target order type has higher priority than current order type
      if (current()->OrdType.isMarketOrderType())
        return target()->OrdType;

      if (target()->OrdType.isMarketOrderType())
        return current()->OrdType;

      return target()->OrdType;
    }

    bool isClosed() const;

    bool wasReplaced() const;
    bool isPendingNew() const;
    bool isPendingCancel() const;
    bool isPendingReplace() const;
    bool hasPendingCancelRequest() const { return _pendingCancelRequestMsgPtr.isValid(); }
    bool hasPendingOperations() const    { return _pendingOperationsRoot.node() != NULL; }

    double avgPx() const { return(_cumQty > QuantityZero ? (_cumValue/_cumQty).toDouble() : 0.0); }
    Quantity cumQty() const { return _cumQty; }
    Amount cumValue() const { return _cumValue; }

    // below three methods are only used by ClientOrderFSM 
    bool hasFills() const;
    bool isCurrentFullyFilled() const;
    bool willTargetFullyFilled() const;

    Quantity targetQty() const { return _targetQty; }
    Quantity leavesQty() const
    {
      if( _ordStatus==common::OrdStatus::Cancelled || _ordStatus==common::OrdStatus::Rejected )
        return QuantityZero;

      return _currentQty-_cumQty;
    }
    // This method only required by ExchangeSliceOperation for validation
    // The name can NOT be leavesQty otherwise calvin binding will fail
    Quantity getLeavesQty(const exch::AllocationEntry& ae_) const;
    
    common::OrdStatus::Enum ordStatus() const { assert(_ordStatus); return _ordStatus; }
    ClientOrderState::Enum placementState() const { assert(_placementState!=ClientOrderState::Last); return _placementState; }

    void setBadPriceThreshold(vx::common::price_t price_) { _badPriceThreshold = price_; }
    vx::common::price_t badPriceThreshold() const { return _badPriceThreshold; }

    void addEvalCondition(EvalCondition::Type type_, int64_t data_);

    bool reportNMS() const { return _reportNMS; }
    void setReportNMS(bool val_) { _reportNMS = val_; }

    int64_t lastEvalTime() const { return _lastEvalTime; }
    int64_t processOperationTime() const { return _processOperationTime; }
    uint16_t numSuccessfulAllocs() const { return _numSuccessfulAllocs; }

    Quantity childPinnedQty() const { assert(_childPinnedQty == calculateChildPinnedQty()); return _childPinnedQty; }
    void reduceChildPinnedQty(Quantity qty_, ExchangeOrder&);
    void increaseChildPinnedQty(Quantity qty_, ExchangeOrder&);
    void unpinAllSlices();
    bool hasPendingPinnedSlices();
    Quantity childIOCLeavesQty() const { assert(_childIOCLeavesQty == calculateChildIOCLeavesQty()); return _childIOCLeavesQty; }
    void reduceChildIOCLeavesQty(Quantity qty_, ExchangeOrder&);
    void increaseChildIOCLeavesQty(Quantity qty_, ExchangeOrder&);
    //IMPORTANT:: DO NOT CALL THIS, for childIOCLeaves, please call childIOCLeavesQty. this function is used in asserts to ensure the correctness of the running total.
#ifndef NDEBUG
    Quantity calculateChildIOCLeavesQty() const;
    Quantity calculateChildPinnedQty() const;
#endif
    Quantity calculateChildLeavesQty() const;

    EvalTriggerEvents addFill(Quantity fillQty_, Amount fillValue_, ExchangeOrder&);
    void removeFill(Quantity fillQty_, Amount fillValue_, ExchangeOrder&);

    void addChildOrder(ExchangeOrder* eo_);
    void addConditionalChildOrder(ExchangeOrder*);
    void closeChildOrder(ExchangeOrder* eo_);
    void evictPendingFirmUpRequest(ExchangeOrder*);

    //const AllocationEntries& pendingAllocations() const { return _pendingAllocations; }
    //AllocationEntries& pendingAllocations() { return _pendingAllocations;}
    //bool hasPendingAllocationRequests() const {return !_pendingAllocations.empty();}
    void setReplaceRequestEvaluator(ClientReplaceRequestEvaluator ev_, void* pUserData_);
    void setCancelRequestEvaluator(ClientCancelRequestEvaluator ev_, void* pUserData_);

    EvalTriggerMask triggerEvalOnBitMask() const { return _triggerEvalOnBitMask; }
    void setTriggerEvalOnBitMask(EvalTriggerMask bitMask_) { _triggerEvalOnBitMask = bitMask_; }
    bool shouldEvalOn(EvalTriggerEvents events_) const { return _triggerEvalOnBitMask & events_; }

    bool eventOccuredSinceLastEval(EvalTriggerEvent::Type evt_) {return _eventsSinceLastEval & evt_; }
    EvalTriggerEvents eventsSinceLastEval() const { return _eventsSinceLastEval; }

    void userDefinedEventOccur() { _eventsSinceLastEval |= EvalTriggerEvent::UserDefinedEvent; }

    bool shouldTriggerPostEventEval() {return _flags & Flags::TRIGGER_POST_EVENT_EVAL; }
    void forcePostEventEval() {_flags |= Flags::TRIGGER_POST_EVENT_EVAL; }
    void clearPostEventEval() {_flags &= ~Flags::TRIGGER_POST_EVENT_EVAL; }

    uint32_t numChildren() { return _numChildren; }
    uint32_t numConditionalChildren() const { return _numConditionalChildren; }
     
    void enableOptimisticAck();
    void disableOptimisticAck();
    bool shouldOptimisticAck() const;

    void setCancelOnExchangeOut(bool b);
    void enableCancelOnExchangeOut();
    void disableCancelOnExchangeOut();

    bool shouldCancelOnExchangeOut() const;

    bool canEval() const;
    void disableEvalState(std::string&) const;
    void freeze(const std::string& reason_);
    void unfreeze();
    bool isFrozen() const;
    bool isUnderRecovery() const;
    bool isThrottled() const;
    void purgePendingOperationsForEO(const ExchangeOrder* pEo_);
    void purgePendingOperations();
    void performPostEventActions();

    template <typename AlertT>
    void raiseAlert(const std::string& reason_) const; 
    template<typename Alert>
    void clearAlert() const;
    uint32_t alerts() const { return _alerts; }

    void cancelSlice(ExchangeOrder& eo_, CancelFlag::Enum = CancelFlag::AllowQue);
    void cancelConditionalSlice(ExchangeOrder&);
    common::ReturnCode adminCancelSlice(ExchangeOrder& eo_, CancelFlag::Enum);
    void cancelAllSlices(CancelFlag::Enum = CancelFlag::AllowQue);
    void cancelAllConditionalSlices();
    
    bool hasOpenSlices();
    bool hasOpenConditionalSlices() const;
    
    bool hasClosedSlices();
    const ExchangeOrder* lastClosedSlice() const;
    // The last updated EO will be only set when there's EO response received
    // it will be reset after the evaluation
    void setLastUpdatedEO(ExchangeOrder*);
    const ExchangeOrder* lastUpdatedEO() const;

    common::ReturnCode enterPendingNew();
    common::ReturnCode enterPendingReplace();

    common::ReturnCode accept();
    common::ReturnCode unsolicitedCancel(
        common::ReturnCode errCode_,
        common::LightStringRef text_ = common::LightStringRef{"", 0});
    common::ReturnCode reject(
        common::ReturnCode errCode_,
        common::LightStringRef text_ = common::LightStringRef{"", 0});
    common::ReturnCode restate(common::ReturnCode errCode_);

    common::ReturnCode onSlicePartiallyFilled(ExchangeOrder& eo_);
    common::ReturnCode onSliceFullyFilled(ExchangeOrder& eo_);
    common::ReturnCode onSliceReplaced(ExchangeOrder& eo_);
    common::ReturnCode onSliceCanceled(ExchangeOrder& eo_);
    common::ReturnCode onSliceUnsolicitedCancel(ExchangeOrder& eo_);
    common::ReturnCode onSliceCreateAccepted(ExchangeOrder& eo_);
    common::ReturnCode onSliceCreateRejected(ExchangeOrder& eo_);
    common::ReturnCode onSliceReplaceRejected(ExchangeOrder& eo_);
    common::ReturnCode onSliceCancelRejected(ExchangeOrder& eo_);
    common::ReturnCode onSliceTradeCancel(ExchangeOrder& eo_);
    common::ReturnCode onSliceTradeCorrect(ExchangeOrder& eo_);
    // these methods should be invoked when the EO is already closed before the execution report is received. 
    common::ReturnCode onSliceLateFilled(ExchangeOrder& eo_);
    common::ReturnCode onSliceLateTradeCancel(ExchangeOrder& eo_);
    common::ReturnCode onSliceLateTradeCorrect(ExchangeOrder& eo_);
    
    common::ReturnCode onConditionalSliceRejected(ExchangeOrder& eo_);
    common::ReturnCode onConditionalSliceReplaceRejected(ExchangeOrder& eo_);
    common::ReturnCode onConditionalSliceUnsolicitedCancel(ExchangeOrder& eo_);
    common::ReturnCode onConditionalSliceFirmedUp(ExchangeOrder& eo_);

    common::ThreadContext& threadContext() { return _tc; }
    const common::ThreadContext& threadContext() const { return _tc; }

    void setProfile(orderProfile::ProfileStorage* storage)
    {
      assert(_allocatorStateBuf);
      if (_profile)
      {
        _profile->_profileType->destroyAllocatorStateBuffer(_allocatorStateBuf);
      }
      _profile=storage->_defaultProfile;

      assert(_tc.orderProfileAccessor().maxStateBufSize() >= _profile->_profileType->requiredStateBufferSize());
      _profile->_profileType->initAllocatorStateBuffer(_allocatorStateBuf);
    }
    void setProfileBackup(orderProfile::ProfileStorage* storage)
    {
      // No need to allocate buffer for allocator states, as the buffer will be allocated when switching
      _profileBackup=storage->_defaultProfile;
    }

    common::ReturnCode allocate(exch::AllocationEntries* allocationEntries_);
    void evalErrorReview();
    void clearErrorReview();
    void evalExchangeExclTimer();

    bool setForceEvalTimer(uint32_t delay);

    bool setEffectiveTime(uint32_t delay_, bool useHRTimer);
    void resetEffectiveTime();
    void onEffectiveTime();
    void onOrderExpired();
    uint64_t engineLocalTimestamp() const { return _engineLocalTimestamp; }
    void setEngineLocalTimestamp(uint64_t engineLocalTimestamp) { _engineLocalTimestamp=engineLocalTimestamp; }

    common::ReturnCode recoverCurrent(const oom::OrderData& orderData_);
    void adminRemove();

    void setMigrated();
    bool isMigrated() const;
    bool isForceBadPriceThresholdCalc() const {return _forceBadPriceThresholdCalc;}
    void setForceBadPriceThresholdCalc(bool v_) {_forceBadPriceThresholdCalc = v_;}
    bool isForceBadPriceReferenceCalc() const {return _forceBadPriceReferenceCalc;}
    void setForceBadPriceReferenceCalc(bool v_) {_forceBadPriceReferenceCalc = v_;}

    void setLimitBreached(uint64_t limitCheckSummary_)  { _limitCheckSummary = limitCheckSummary_; _flags |= Flags::LIMIT_BREACHED; }
    bool isLimitBreached() const                        { return(_flags & Flags::LIMIT_BREACHED); }
    uint64_t limitCheckSummary() const                  { return _limitCheckSummary; }

    bool isPuntCompleted() const; 
    void switchProfile(orderProfile::OrderProfile*);

    void* clientTransportChannel() { return _clientTransportChannel; }

protected:
    void doCancelSlice(ExchangeOrder& eo_, CancelFlag::Enum);
    void initializeBackupAllocationModel();
    void onEvalThrottlingTimeExpired();
    void checkEvalFrequency();
    void checkEvalCount();
    void acceptReplaceRequest();
    void rejectReplaceRequest();
    void acceptCancelRequest();

    ExchangeSliceOperation::Status processExchangeSliceOperations();
    bool validateExchangeSliceOperations();
    bool hasEnoughAllocatableQty(const ExchangeSliceOperation&) const;

    // Param events_ is NOT always same as _eventsSinceLastEval.
    // In allocation model, the logic should rely on _eventsSinceLastEval 
    // This events_ just give the CO a hint if a fully evaluation is required (for Notional order, since it has multiple level allocation models)
    common::ReturnCode processEvaluation(EvalTriggerEvents events_);
    void performPreEvalActions();
    void performPostEvalActions();

    void closeAllChildOrders();

    void onOrderClosed();
    void onEnterPendingCancelState();
    void onEnterPendingReplaceState();
    void onEnterStableState();
    void onTransactionCompleted();

    void setExpireTimer();

    Quantity sumChildCumQty() const;

    void deferSetExpireTimer(bool b);
    bool shouldSetExpireTimer() const;

    void onPendingRequestClientTimer();
    bool setPendingRequestClientTimer();

public:
    orderProfile::OrderProfile* _profile;
    orderProfile::OrderProfile* _profileBackup;//??? Do we need it
    char* _allocatorStateBuf;
    LightFilterAttrBitset _watchAttrs;
    ClientOrderListNode _orderListNode;

    common::LightDoubleLinkedListRoot<ExchangeOrder> _openChildOrdersRoot;
    common::LightDoubleLinkedListRoot<ExchangeOrder> _openConditionalChildOrdersRoot;
    common::LightDoubleLinkedListRoot<ExchangeOrder> _closedChildOrdersRoot;
    common::LightSingleLinkedListRoot<ExchangeSliceOperation> _pendingOperationsRoot;
    common::LightSingleLinkedListRoot<EvalCondition> _evalConditionsRoot;
    common::LightDoubleLinkedListRoot<ExchangeOrder> _pendingFirmUpRequests;

    // write this client order to the log
    void log() const;

    const vx::common::MSUuidPair& lastEvalId() const { return _lastEvalId; }

    bool pendingRestate() const
    {
      return _restateTags != NULL;
    }
    void clearRestateTags() 
    {
      delete _restateTags;
      _restateTags = NULL;
    }
    bool forceEvalExpectedQ() const
    {
      return (_forceEvalTimer != NULL  &&  _forceEvalTimer->isWaiting());
    }

    // ghost of this order; survives order eviction and deletion of ClientOrder
    // note: may be null in some short-lived ClientOrder objects that are dropped soon after creation,
    //       and only maintained for orders created for/by/through ClientOrderManager
    ClientOrderGhost* ghost() const   { return _ghost; }
    
protected:
    ClientOrderGhost* _ghost;
    friend class ClientOrderGhost;    // ghost will provide handlers to control the relationship btwn CO & Ghost

    RestateTags* _restateTags;

    void setUnsolCxlReason(
        common::ReturnCode reason_,
        common::LightStringRef text_ = common::LightStringRef{"", 0})
    {
      _unsolCxlReason = reason_;
      _unsolCxlReasonText.assign(text_._buf, text_._sz);
    }

    common::LightStringRef unsolCxlReasonText() const
    {
      return _unsolCxlReasonText.empty()
        ? _unsolCxlReason.asStringRef()
        : common::LightStringRef(_unsolCxlReasonText.c_str(),
                                 _unsolCxlReasonText.size());
    }

    vx::msg::ClientRequestPtr _lastOrderUpdateMsgPtr;
    vx::msg::ClientRequestPtr _pendingReplaceRequestMsgPtr;
    vx::msg::ClientRequestPtr _pendingCancelRequestMsgPtr;

    mutable uint32_t _alerts;

    void* _pReplaceRequestEvaluatorUserData;
    ClientReplaceRequestEvaluator _evaluateReplaceRequest;

    void* _pCancelRequestEvaluatorUserData;
    ClientCancelRequestEvaluator _evaluateCancelRequest;

    common::Side::Enum _side;
    ClientOrderState::Enum _placementState;
    Quantity _pocketQty;
    Quantity _cumQty;
    Amount _cumValue;
    Quantity _childPinnedQty;
    Quantity _childIOCLeavesQty;
    Quantity _targetQty;
    Quantity _currentQty;
    vx::common::price_t _targetPrice;
    vx::common::price_t _currentPrice;

    common::OrdStatus::Enum _ordStatus;

    EvalTriggerMask _triggerEvalOnBitMask;
    EvalTriggerEvents _eventsSinceLastEval;

    uint32_t _flags;
    uint32_t _disableEvalBitMask;
    uint16_t _numAllocsInWindow;
    uint32_t _evalCount;
    uint16_t _numSuccessfulAllocs;  //vx-1553
    int64_t  _evalFreqWindowStartTime;
    int64_t  _lastEvalTime;
    int64_t  _processOperationTime;
    int64_t  _expireTimeInMS;
    uint64_t _limitCheckSummary = 0;

    bool _reportNMS;
    uint64_t _seed;

    uint32_t _numChildren; // dead or alive
    uint32_t _numConditionalChildren = 0;

    //TODO move this field to an allocator state vx-1191
    vx::common::price_t _badPriceThreshold;

    // TODO TimerManager should own the timer lifecyle (create/release)
    // TODO all timers should be the same class <type, invoke_fn>
    //      no need to create distinctive Timer and Factory for different purposes,
    //      neither to friend each Timer class
    timer::TimerBase* _forceEvalTimer;
    timer::TimerBase* _evalThrottlingTimer;
    timer::TimerBase* _evalErrorReviewTimer;
    timer::TimerBase* _effectiveTimeTimer;
    timer::TimerBase* _orderExpireTimer;
    timer::TimerBase* _pendingRequestClientTimer;

    StripeContext* _stripeContext;
    common::ThreadContext& _tc;

    bool _isListOrder = false;
    void* _clientTransportChannel;

    common::ReturnCode _unsolCxlReason;
    std::string _unsolCxlReasonText;
    uint64_t _engineLocalTimestamp;
    bool _forceBadPriceThresholdCalc;
    bool _forceBadPriceReferenceCalc;

    ExchangeOrder* _lastUpdatedEO = nullptr;
    ets::vx::common::MSUuidPair _lastEvalId;
};

//
// ClientOrder implementation
//

template <class Timer>
bool addTimer(ClientOrder& co_, Timer* timer_, uint32_t delayInMillis_)
{
  if (!co_.threadContext().timerManager().addTimer(timer_, delayInMillis_))
  {
    std::ostringstream os;
    os << "Failed to add " << Timer::name();
    co_.raiseAlert<om::alert::TimerError>(os.str());
    return false;
  }

  return true;
}

template <class Timer>
bool addTimerHR(ClientOrder& co_, Timer* timer_, uint32_t delayInMillis_)
{
  if (!co_.threadContext().hrTimerManager().addTimer(timer_, delayInMillis_))
  {
    std::ostringstream os;
    os << "Failed to add " << Timer::name();
    co_.raiseAlert<om::alert::TimerError>(os.str());
    return false;
  }

  return true;
}

class EvalThrottlingTimer : public timer::TimerBaseT<EvalThrottlingTimer>
{
public:
  EvalThrottlingTimer( ClientOrder& co_ )
  :
    _co(co_)
  {
  }

  static const char* name() { return "EvalThrottingTimer"; }

  static void release( EvalThrottlingTimer* obj )
  {
    if(obj->_co._evalThrottlingTimer == obj)
    {  
      obj->_co._evalThrottlingTimer=NULL;
    }
    getEvalThrottlingTimerFactory().release(obj);
  }

  static void onTimerExpired( EvalThrottlingTimer* obj )
  {
    ClientOrder& co = obj->_co;

    co._evalThrottlingTimer=NULL;
    co.onEvalThrottlingTimeExpired();
    co.threadContext().com().onPostEvent(&co);
  }

private:
  ClientOrder& _co;
};

class EvalErrorReviewTimer : public timer::TimerBaseT<EvalErrorReviewTimer>
{
public:
  EvalErrorReviewTimer( ClientOrder& co_ )
  :
    _co(co_), _invokedByTimer(false)
  {
  }

  static const char* name() { return "EvalErrorReviewTimer"; }

  static void release( EvalErrorReviewTimer* obj )
  {
    if(obj->_invokedByTimer)
    {
      obj->_invokedByTimer = false;
    }
    else
    {
      obj->_co._evalErrorReviewTimer=NULL;
    }

    getEvalErrorReviewTimerFactory().release(obj);
  }

  static void onTimerExpired( EvalErrorReviewTimer* obj )
  {
    ClientOrder& co = obj->_co;

    co._evalErrorReviewTimer=NULL;
    obj->_invokedByTimer = true;
    co.evalErrorReview();
    co.threadContext().com().onPostEvent(&co);
  }

private:
  ClientOrder& _co;
  bool _invokedByTimer;
};

//Timer call forceEval. If different components can want share same times, may be we want add delay as timer property
class ForceEvalTimer : public timer::TimerBaseT<ForceEvalTimer>
{
public:
  ForceEvalTimer( ClientOrder& co_ )
  :
    _co(co_)
  {
  }

 static const char* name() { return "ForceEvalTimer"; }

  static void release( ForceEvalTimer* obj )
  {
    if(obj->_co._forceEvalTimer == obj)
    {  
      obj->_co._forceEvalTimer=NULL;
    }
    getForceEvalTimerFactory().release(obj);
  }

  static void onTimerExpired( ForceEvalTimer* obj )
  {
    ClientOrder& co = obj->_co;

    co._forceEvalTimer=NULL;
    co.forceEval();
    co.threadContext().com().onPostEvent(&co);
  }

private:
  ClientOrder& _co;
};

class EffectiveTimeTimer : public timer::TimerBaseT<EffectiveTimeTimer>
{
public:
  EffectiveTimeTimer( ClientOrder& co_ )
  :
    _co(co_)
  {
  }

  static const char* name() { return "EffectiveTimeTimer"; }

  static void release( EffectiveTimeTimer* obj )
  {
    if(obj->_co._effectiveTimeTimer == obj)
    {  
      obj->_co._effectiveTimeTimer=NULL;
    }
    getEffectiveTimeTimerFactory().release(obj);
  }

  static void onTimerExpired( EffectiveTimeTimer* obj )
  {
    ClientOrder& co = obj->_co;

    co._effectiveTimeTimer=NULL;
    co.onEffectiveTime();
    co.threadContext().com().onPostEvent(&co);
  }

private:
  ClientOrder& _co;
};

class OrderExpireTimer : public timer::TimerBaseT<OrderExpireTimer>
{
public:
  OrderExpireTimer( ClientOrder& co_ )
  :
    _co(co_)
  {
  }

  static const char* name() { return "OrderExpireTimer"; }

  static void release( OrderExpireTimer* obj )
  {
    if(obj->_co._orderExpireTimer == obj)
    {  
      obj->_co._orderExpireTimer=NULL;
    }
    getOrderExpireTimerFactory().release(obj);
  }

  static void onTimerExpired( OrderExpireTimer* obj )
  {
    ClientOrder& co = obj->_co;

    co._orderExpireTimer=NULL;
    if (co._evaluateCancelRequest)
    {
      common::ReturnCode rc = co._evaluateCancelRequest(co, vx::msg::ClientRequestPtr(), co._pCancelRequestEvaluatorUserData, false);
      if (!rc){ return;  }
    }
    co.onOrderExpired();
    co.threadContext().com().onPostEvent(&co);
  }

private:
  ClientOrder& _co;
};

inline void ClientOrder::init(StripeContext* sc_, bool isListOrder_, void* clientTransportChannel_)
{
  assert(sc_);
  assert(clientTransportChannel_);
  _stripeContext = sc_;
  _isListOrder = isListOrder_;
  _clientTransportChannel = clientTransportChannel_;
  _stripeContext->activeOrders().pushFront(&_orderListNode);
}

inline bool ClientOrder::isClosed() const
{
    return (_disableEvalBitMask & DisableEvalBitMask::IS_CLOSED);
}

inline void ClientOrder::unpinAllSlices()
{
  ExchangeOrder* eo = _openChildOrdersRoot.node();
  while(eo)
  {
    if(eo->isPinned())
    {
      eo->unpin();
    }
    eo=eo->next();
  }
  _childPinnedQty = QuantityZero;

}
inline bool ClientOrder::hasPendingPinnedSlices()
{
  ExchangeOrder* eo = _openChildOrdersRoot.node();
  while(eo)
  {
    if(eo->isPending() && eo->isPinned()) return true;
    eo=eo->next();
  }
  return false;
}

#ifndef NDEBUG
// IMPORTANT: below two methods are used for sanity check, they should not be used for any other purpose
inline Quantity ClientOrder::calculateChildIOCLeavesQty() const
{
    Quantity sum = QuantityZero;
    const ExchangeOrder* eo=_openChildOrdersRoot.node();
    while( eo )
    {
        if( !eo->isClosed() && eo->current().timeInForce() == common::TimeInForce::ImmediateOrCancel )
        {
            Quantity qty=eo->currentLeavesQty();
            sum += std::max(qty, QuantityZero);
        }
        eo=eo->next();
    }

    return sum;
}

inline Quantity ClientOrder::calculateChildPinnedQty() const
{
    Quantity sum = QuantityZero;
    const ExchangeOrder* eo=_openChildOrdersRoot.node();
    while( eo )
    {
        if( !eo->isClosed() && eo->isPinned() )
        {
            Quantity qty=eo->currentLeavesQty();
            sum += std::max(qty, QuantityZero);
        }
        eo=eo->next();
    }

    return sum;
}
#endif

inline Quantity ClientOrder::calculateChildLeavesQty() const
{
    Quantity sum = QuantityZero;
    const ExchangeOrder* eo=_openChildOrdersRoot.node();
    while( eo )
    {
        Quantity qty=eo->currentLeavesQty();
        sum += std::max(qty, QuantityZero);
        eo=eo->next();
    }

    return sum;
}

//this should only be called during recovery
inline Quantity ClientOrder::sumChildCumQty() const
{
  Quantity sum = QuantityZero;
  const ExchangeOrder* eo = _openChildOrdersRoot.node();
  while( eo )
  {
    sum += eo->cumQty();
    eo = eo->next();
  }
  eo = _closedChildOrdersRoot.node();
  while( eo )
  {
    sum += eo->cumQty();
    eo = eo->next();
  }

  return sum;
}

inline void ClientOrder::setReplaceRequestEvaluator(ClientReplaceRequestEvaluator ev_, void* pUserData_)
{
    _evaluateReplaceRequest = ev_;
    _pReplaceRequestEvaluatorUserData = pUserData_;
}

inline void ClientOrder::setCancelRequestEvaluator(ClientCancelRequestEvaluator ev_, void* pUserData_)
{
    _evaluateCancelRequest = ev_;
    _pCancelRequestEvaluatorUserData = pUserData_;
}

inline common::ReturnCode ClientOrder::accept()
{
     assert(isPendingNew());
    ClientEventArgs eventArgs(*this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::AcceptOrder, eventArgs);
}

inline common::ReturnCode ClientOrder::unsolicitedCancel(common::ReturnCode rc_, common::LightStringRef text_)
{
    if (_unsolCxlReason)
      setUnsolCxlReason(rc_, text_);
    purgePendingOperations();
    ClientEventArgs eventArgs(*this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::UnsolicitedCancelOrder, eventArgs);
}

inline common::ReturnCode ClientOrder::reject(common::ReturnCode rc_, common::LightStringRef text_)
{
    if (_unsolCxlReason)
      setUnsolCxlReason(rc_, text_);
    purgePendingOperations();
    ClientEventArgs eventArgs(*this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::RejectOrder, eventArgs);
}

inline common::ReturnCode ClientOrder::restate(common::ReturnCode rc_)
{
    ClientEventArgs eventArgs(*this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::RestateOrder, eventArgs);
}

inline common::ReturnCode ClientOrder::onSlicePartiallyFilled(ExchangeOrder& eo_)
{
    onSliceCreateAccepted(eo_); // exchange might fill without ACK, ignore ReturnCode as we have to pass back fill

    ClientEventArgs eventArgs(&eo_, *this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::SlicePartiallyFilled, eventArgs);
}

inline common::ReturnCode ClientOrder::onSliceFullyFilled(ExchangeOrder& eo_)
{
    onSliceCreateAccepted(eo_); // exchange might fill without ACK, ignore ReturnCode as we have to pass back fill

    ClientEventArgs eventArgs(&eo_, *this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::SliceFullyFilled, eventArgs);
}

inline common::ReturnCode ClientOrder::onSliceCanceled(ExchangeOrder& eo_)
{
    //we update pocketQty in closeChildOrder function.
    ClientEventArgs eventArgs(&eo_, *this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::SliceCancelSucceeded, eventArgs);
}

inline common::ReturnCode ClientOrder::onSliceReplaced(ExchangeOrder& eo_)
{
    ClientEventArgs eventArgs(&eo_, *this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::SliceReplaceSucceeded, eventArgs);
}

//This includes IOC outs as well.
inline common::ReturnCode ClientOrder::onSliceUnsolicitedCancel(ExchangeOrder& eo_)
{
    //AllocationModel should set UnsolCxled as a trigger event on nonIOC AEs.

    ClientEventArgs eventArgs(&eo_, *this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::SliceUnsolicitedCancel, eventArgs);
}

inline void ClientOrder::cancelSlice(ExchangeOrder& eo_, CancelFlag::Enum cxlFlag_)
{
    purgePendingOperations(); // admins could also cause new allocations 
                              // TODO Fix: This function should call purgePendingOperationsForEO
    doCancelSlice(eo_, cxlFlag_);
}

inline void ClientOrder::cancelAllSlices(CancelFlag::Enum cxlFlag_)
{
  purgePendingOperations();
  for (ExchangeOrder* eo = _openChildOrdersRoot.node(); eo; eo = eo->next())
  {
    doCancelSlice(*eo, cxlFlag_);
  }
}

inline void ClientOrder::cancelAllConditionalSlices()
{
  ExchangeOrder* eo = _openConditionalChildOrdersRoot.node();
  while(eo)
  {
    ExchangeOrder* tmp = eo;
    eo = eo->next();
    cancelConditionalSlice(*tmp);
  }
}

inline bool ClientOrder::hasOpenSlices()
{
  return _openChildOrdersRoot.node() != NULL;
}

inline bool ClientOrder::hasOpenConditionalSlices() const
{
  return _openConditionalChildOrdersRoot.node() != nullptr;
}

inline bool ClientOrder::hasClosedSlices()
{
  return _closedChildOrdersRoot.node() != NULL;
}

inline const ExchangeOrder* ClientOrder::lastClosedSlice() const
{
  return _closedChildOrdersRoot.node();
}

inline void ClientOrder::setLastUpdatedEO(ExchangeOrder* eo_) 
{ 
  _lastUpdatedEO = eo_; 
}

inline const ExchangeOrder* ClientOrder::lastUpdatedEO() const 
{ 
  return _lastUpdatedEO;
}

inline common::ReturnCode ClientOrder::onSliceCreateAccepted(ExchangeOrder& eo_)
{
  if (isPendingNew() && !shouldOptimisticAck())
  {
    return accept();
  }

  return ErrorCode::SUCCESS;
}

inline common::ReturnCode ClientOrder::onSliceCreateRejected(ExchangeOrder& eo_)
{
    purgePendingOperations();
    ClientEventArgs eventArgs(&eo_, *this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::SliceCreateRejected, eventArgs);
}

inline common::ReturnCode ClientOrder::onSliceReplaceRejected(ExchangeOrder& eo_)
{
    //don't need to purge here because replace rejects always trigger a forced eval.
    ClientEventArgs eventArgs(&eo_, *this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::SliceReplaceRejected, eventArgs);
}

inline common::ReturnCode ClientOrder::onSliceCancelRejected(ExchangeOrder& eo_)
{
    purgePendingOperations();
    ClientEventArgs eventArgs(&eo_, *this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::SliceCancelRejected, eventArgs);
}


inline common::ReturnCode ClientOrder::onSliceTradeCancel(ExchangeOrder& eo_)
{
    purgePendingOperations();
    ClientEventArgs eventArgs(&eo_, *this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::SliceTradeCancel, eventArgs);
}

inline common::ReturnCode ClientOrder::onSliceTradeCorrect(ExchangeOrder& eo_)
{
    purgePendingOperations();
    ClientEventArgs eventArgs(&eo_, *this);
    return _tc.com().fsm().dispatch(ClientOrderEvent::SliceTradeCorrect, eventArgs);
}

inline common::ReturnCode ClientOrder::onSliceLateFilled(ExchangeOrder& eo_)
{
  purgePendingOperations();
  common::ReturnCode rc = onSliceFullyFilled(eo_);
  if (rc)
  {
    Quantity fillQty = eo_.lastExchangeMessage()->LastShares;
    reducePocketQty(fillQty, eo_);
    forcePostEventEval();
  }
  return rc;
}

inline common::ReturnCode ClientOrder::onSliceLateTradeCancel(ExchangeOrder& eo_)
{
  common::ReturnCode rc = onSliceTradeCancel(eo_);
  if (rc)
  {
    Quantity prevFillQty = eo_.lastExchangeMessage()->RefLastShares;
    increasePocketQty(prevFillQty, eo_);
  }
  return rc;
}

inline common::ReturnCode ClientOrder::onSliceLateTradeCorrect(ExchangeOrder& eo_)
{
  common::ReturnCode rc = onSliceTradeCorrect(eo_);
  if (rc)
  {
    Quantity newFillQty = eo_.lastExchangeMessage()->LastShares;
    Quantity prevFillQty = eo_.lastExchangeMessage()->RefLastShares; 
    increasePocketQty(prevFillQty, eo_);
    reducePocketQty(newFillQty, eo_);
  }
  return rc;
}

inline common::ReturnCode ClientOrder::onConditionalSliceRejected(ExchangeOrder& eo_)
{
  ClientEventArgs eventArgs(&eo_, *this);
  return _tc.com().fsm().dispatch(ClientOrderEvent::ConditionalSliceRejected, eventArgs);
}

inline common::ReturnCode ClientOrder::onConditionalSliceReplaceRejected(ExchangeOrder& eo_)
{
  ClientEventArgs eventArgs(&eo_, *this);
  return _tc.com().fsm().dispatch(ClientOrderEvent::ConditionalSliceReplaceRejected, eventArgs);
}

inline common::ReturnCode ClientOrder::onConditionalSliceUnsolicitedCancel(ExchangeOrder& eo_)
{
  ClientEventArgs eventArgs(&eo_, *this);
  return _tc.com().fsm().dispatch(ClientOrderEvent::ConditionalSliceUnsolicitedCancel, eventArgs);
}

inline common::ReturnCode ClientOrder::onConditionalSliceFirmedUp(ExchangeOrder& eo_)
{
  ClientEventArgs eventArgs(&eo_, *this);
  return _tc.com().fsm().dispatch(ClientOrderEvent::ConditionalSliceFirmedUp, eventArgs);
}

inline void ClientOrder::addConditionalChildOrder(ExchangeOrder* eo_)
{
  assert(eo_);
  assert(eo_->isConditional());  
  _openConditionalChildOrdersRoot.pushFront(eo_);
  ++_numConditionalChildren;
}

inline bool ClientOrder::validateExchangeSliceOperations()
{
    checkPoint;
    ExchangeSliceOperation* eso=_pendingOperationsRoot.node();
    while( eso )
    {
        if( !eso->isValid() )
            return false;
        eso=eso->next();
    }
    checkPoint;

    return true;
}

inline void ClientOrder::performPostEventActions()
{
    if (shouldTriggerPostEventEval())
    {
        checkPoint;
        common::ReturnCode rc = processEvaluation(_eventsSinceLastEval);
        if (!rc && rc != ErrorCode::EVAL_DISABLED)
        {
          handleEvalError(rc);
        }
        return;
    }

    om::EvalCondition* ec=_evalConditionsRoot.node();
    while( ec )
    {
        checkPoint;
        if( _tc.evalConditionRepository().checkCondition(*this, *ec) )
        {
            checkPoint;
            common::ReturnCode rc = processEvaluation(EvalTriggerEvent::ForceEval);
            if (!rc && rc != ErrorCode::EVAL_DISABLED)
            {
              handleEvalError(rc);
            }
            return;
        }
        checkPoint;
        ec=ec->next();
    }

    //if nobody wanted to force an eval, we should send out whatever we have cached.
    if( _pendingOperationsRoot.node() )
    {
        //only use these operations when they're valid.
        //an operation can become invalid when the replace down request cannot be satisfied due to fills while pending
        //this is only an issue when we're already in pending mode as a decrease in quantity doesnt require additional
        //pocketQty.
        if (validateExchangeSliceOperations())
        {
            //since we're bypassing an eval, we need to reset the time here.
            _processOperationTime = ets::utility::MicroTime::now();
            checkPoint;
            ExchangeSliceOperation::Status status = processExchangeSliceOperations();//??check status?
        }
        else //if any operation is invalid, we should call eval again.
        {
            checkPoint;
            common::ReturnCode rc = processEvaluation(EvalTriggerEvent::ForceEval);
            if (!rc && rc != ErrorCode::EVAL_DISABLED)
            {
              handleEvalError(rc);
            }
        }
    }
}

inline void ClientOrder::switchProfile(orderProfile::OrderProfile* profile_)
{
    assert (_profile != profile_);

    if (_profile != profile_) //defensive check for 2nd attempt
    {
      _disableEvalBitMask &= ~DisableEvalBitMask::WAITING_FOR_EFFECTIVE_TIME;
      _disableEvalBitMask &= ~DisableEvalBitMask::IS_THROTTLED;
    }

    // switch profile
    _profile->_profileType->destroyAllocatorStateBuffer(_allocatorStateBuf);
    _profile = profile_;
    _profile->_profileType->initAllocatorStateBuffer(_allocatorStateBuf);

    setReplaceRequestEvaluator(&puntToBackupClientReplaceRequestEvaluator, NULL);
    setCancelRequestEvaluator(NULL, NULL);

    orderProfile::OMAttributes& om_attr = _profile->_omAttributes;

    om::EvalCondition* ec=_evalConditionsRoot.node();
    while( ec )
    {
        om::EvalCondition* tmp=ec;
        ec=ec->next();
        getEvalConditionFactory().release(tmp);
    }
    _evalConditionsRoot.reset(NULL);

    addEvalCondition(EvalCondition::PercentOfLeavesInPocket, om_attr.minEvalPocketQty);
}

inline void ClientOrder::initializeBackupAllocationModel()
{
  switchProfile(_profileBackup);
}

inline void ClientOrder::forceEval()
{
  common::ReturnCode rc = processEvaluation(EvalTriggerEvent::ForceEval);
  if (!rc && rc != ErrorCode::EVAL_DISABLED)
  {
    handleEvalError(rc);
  }
  vx::logging::endTransaction(_stripeContext->logSenderPtr(), _stripeContext->bucketNum(), orderUUId(), currentTransaction().getCurrentEvalId());
}

inline void ClientOrder::enableOptimisticAck()
{
    _flags |= Flags::OPTIMISTIC_ACK_OVERRIDE;
} 

inline void ClientOrder::disableOptimisticAck()
{
    _flags &= ~Flags::OPTIMISTIC_ACK_OVERRIDE;
} 

inline bool ClientOrder::shouldOptimisticAck() const
{
    return _profile->_omAttributes.optimisticAck || (_flags & Flags::OPTIMISTIC_ACK_OVERRIDE);
}

inline void ClientOrder::setCancelOnExchangeOut(bool b)
{
    CONDITIONALLY_SET(_flags, Flags::CXL_ON_EXCHANGE_OUT, b);
}

inline bool ClientOrder::shouldCancelOnExchangeOut() const
{
    return _flags & Flags::CXL_ON_EXCHANGE_OUT;
}

inline void ClientOrder::enableCancelOnExchangeOut()
{
    _flags |= Flags::CXL_ON_EXCHANGE_OUT;
}

inline void ClientOrder::disableCancelOnExchangeOut()
{
    _flags &= ~Flags::CXL_ON_EXCHANGE_OUT;
}
inline bool ClientOrder::wasReplaced() const
{
    return _flags & Flags::WAS_REPLACED;
}

inline void ClientOrder::deferSetExpireTimer(bool b)
{
      CONDITIONALLY_SET(_flags, Flags::DEFER_SET_EXPIRE_TIMER, b);
}

inline bool ClientOrder::shouldSetExpireTimer() const
{
      return _flags & Flags::DEFER_SET_EXPIRE_TIMER;
}

inline void ClientOrder::freeze(const std::string& reason_)
{
    _disableEvalBitMask |= DisableEvalBitMask::IS_FROZEN;
    //IMPORTANT: We cannot purge operations here.
    raiseAlert<om::alert::OrderFrozen>(reason_);
    ORlogError << "Order frozen. Reason:" << reason_ << ORLog::send;
}

inline void ClientOrder::unfreeze()
{
    _disableEvalBitMask &= ~DisableEvalBitMask::IS_FROZEN;

    clearAlert<om::alert::OrderFrozen>();

    // reset
    _evalCount = 0;

    forceEval();
}

inline bool ClientOrder::isFrozen() const
{
    return _disableEvalBitMask & DisableEvalBitMask::IS_FROZEN;
}

inline bool ClientOrder::isUnderRecovery() const
{
    return _disableEvalBitMask & DisableEvalBitMask::UNDER_RECOVERY;
}

inline bool ClientOrder::isThrottled() const
{
    return _disableEvalBitMask & DisableEvalBitMask::IS_THROTTLED;
}

template <typename AlertT>
void ClientOrder::raiseAlert(const std::string& reason_) const
{
  if (!(_alerts & AlertT::mask) && alert::raiseOrderAlert<AlertT>(*this, reason_))
  {
    _alerts |= AlertT::mask;
  }
}

template<typename AlertT>
void ClientOrder::clearAlert() const
{
  if( _alerts & AlertT::mask )
  {
    _alerts &= ~AlertT::mask;
    alert::clearOrderAlert<AlertT>(*this);
  }
}

inline void ClientOrder::purgePendingOperationsForEO(const ExchangeOrder* pEo_)
{
  ExchangeSliceOperation* eso=_pendingOperationsRoot.node();
  while (eso && eso->exchOrder() != pEo_) eso = eso->next(); //TODO: polish the iterator and use std::find()
  if (eso) // found
  {
    purgePendingOperations(); //TODO Fix: It should not purge all all EOs operations
    forcePostEventEval();
  }
}

inline void ClientOrder::purgePendingOperations()
{
  checkPoint;
  ExchangeSliceOperation* eso = _pendingOperationsRoot.node();
  while (eso)
  {
    ExchangeSliceOperation* tmp = eso;
    eso = eso->next();
    ExchangeSliceOperation::release(*tmp);
  }
  _pendingOperationsRoot.reset(0);
  checkPoint;
}

inline bool ClientOrder::isPendingNew() const
{
  return _placementState == ClientOrderState::PendingNew || _placementState == ClientOrderState::PendingNewPendingCancel;
}

inline bool ClientOrder::isPendingCancel() const
{
    return _placementState == ClientOrderState::PendingCancel ||
      _placementState == ClientOrderState::PendingReplacePendingCancel ||
      _placementState == ClientOrderState::PendingNewPendingCancel;
}

inline bool ClientOrder::isPendingReplace() const
{
    return _placementState == ClientOrderState::PendingReplace || _placementState == ClientOrderState::PendingReplacePendingCancel;
}

inline bool ClientOrder::canEval() const
{
    return _disableEvalBitMask == 0;
}

inline void ClientOrder::onOrderClosed()
{
    _disableEvalBitMask |= DisableEvalBitMask::IS_CLOSED;
    purgePendingOperations();
}

inline void ClientOrder::onEnterPendingCancelState()
{
    _disableEvalBitMask |= DisableEvalBitMask::IN_PENDING_CXL_STATE;
    setPendingRequestClientTimer();
}

inline void ClientOrder::onEnterPendingReplaceState()
{
    setPendingRequestClientTimer();
}

inline void ClientOrder::onEnterStableState()
{
    if( !_pendingRequestClientTimer )
    {
      clearAlert<om::alert::PendingRequest>();
    }
    _disableEvalBitMask &= ~DisableEvalBitMask::IN_PENDING_CXL_STATE;
}

inline bool ClientOrder::isPunted() const
{
    return _profile->_omAttributes.puntModeEnabled;
}

inline bool ClientOrder::isPuntCompleted() const
{
  ExchangeOrder* eo = _openChildOrdersRoot.node();
  if(eo)
  {
    if( eo->next() )
    {
      // There's more than one open order. 
      return false;
    }
    // Only one open order and is routed as pipe.
    return eo->isRoutedAsPipe();
  }
  return false;
}

inline void ClientOrder::performPreEvalActions()
{
    _tc.preEvalRepository().invoke(*this);

    //book the eval id in client order for later use
    _lastEvalId = currentTransaction().evalId();

    checkPoint;
    _lastEvalTime = ets::utility::MicroTime::now();
    checkPoint;
}

inline void ClientOrder::onEvalThrottlingTimeExpired()
{
    _disableEvalBitMask &= ~DisableEvalBitMask::IS_THROTTLED;
    _numAllocsInWindow = 0;
    _evalFreqWindowStartTime = 0;
    forceEval();
}

inline void ClientOrder::evalErrorReview()
{
  _eventsSinceLastEval |= EvalTriggerEvent::EvalErrorReview;
  forceEval();
}

inline void ClientOrder::clearErrorReview()
{
  if( _evalErrorReviewTimer )
  {
    _evalErrorReviewTimer->release();
  }
}

inline void ClientOrder::evalExchangeExclTimer()
{
  _eventsSinceLastEval |= EvalTriggerEvent::ExchangeExclTimer;
  forceEval();
  _tc.com().onPostEvent(this);
}

inline void ClientOrder::setExpireTimer()
{
  deferSetExpireTimer(false);

  if(_orderExpireTimer)
  {
    _orderExpireTimer->release();
  }

  int64_t lifeTime;
  if(timeInForce() == common::TimeInForce::ImmediateOrCancel)
  {
    lifeTime = _profile->_omAttributes.iocLifeTime;
  }
  else
  {
    if(!_expireTimeInMS)
    {
      return;
    }
    lifeTime = _expireTimeInMS - threadContext().timerManager().time();
  }

  if(lifeTime > 0)
  {
    OrderExpireTimer* timer = getOrderExpireTimerFactory().create(*this);
    _orderExpireTimer = timer;
    if (!addTimer(*this, timer, lifeTime))
    {
      ORlogError << "Failed to add OrderExpireTimer for [" << lifeTime << "] milliseconds. Defaulting to oneshot" << ORLog::send;
      onOrderExpired();
    }
  }
  else
  {
    onOrderExpired();
  }
}

inline void ClientOrder::onTransactionCompleted()
{
  if (!_profile->_omAttributes.optimisticReplaceAck && isPendingReplace())
  {
    // The only current use case to fire this event to the FSM is if we
    // are pending a pessimistic replace. This may change in the future.
    ClientEventArgs eventArgs(*this);
    _tc.com().fsm().dispatch(ClientOrderEvent::TransactionCompleted, eventArgs);
    performPostEventActions();
  }
}

}}}

#define ALLOCATOR(PROFILE_TYPE) ALLOCATOR_T(PROFILE_TYPE, ::ets::vx::om::ClientOrder)

#define ALLOCATOR_WITH_HANDLE_EVENT(PROFILE_TYPE) ALLOCATOR_WITH_HANDLE_EVENT_T(PROFILE_TYPE, ::ets::vx::om::ClientOrder)

#include "ClientOrderImpl.H"

Attention:  ClientOrderFSM.H
#ifndef ets_vx_om_ClientOrderFSM_H
#define ets_vx_om_ClientOrderFSM_H
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#include "ClientOrderFsmTypes.H"
#include <ets/vxperf/xprobes/xprobes.H>
#include <ets/vx/om/Fwd.H>
#include "AlertTypes.H"
#include <OR/fixMessage/fixMessage/ORFixMessage.H>
#include <ets/vx/msg/ClientReport.H>
#include <ets/vx/om/EventHooks.H>
#include <ets/vx/app/Intercepts.H>
#include <ets/vx/common/StringSet.H>

namespace ets { namespace vx { namespace common {
  class FixMsgFactory;
}}}

namespace ets { namespace vx { namespace om {

struct ClientTransport
{
  typedef MSHashMap<common::LightStringRef, void*> ChannelCache;

  ClientTransport(
    bool (*send_)(vx::msg::ClientReport&, void*, const vx::msg::ClientRequestPtr&),
    bool (*sendRestate_)(const ClientOrder&, vx::msg::ClientReport&, void*),
    void* (*getChannel_)(const common::LightStringRef returnAddress))
  :
    _send(send_),
    _sendRestate(sendRestate_),
    _getChannel(getChannel_)
  {
    assert(_send); assert(_getChannel);
  }

  bool send(vx::msg::ClientReport& msg, void* clientChannel, const vx::msg::ClientRequestPtr &req, const ets::vx::om::ClientOrder* const co_);

  bool sendRestate(const ClientOrder& co, vx::msg::ClientReport& msg, void* clientChannel)
  {
    assert(_sendRestate);
    assert(_getChannel);
    assert(clientChannel);
    return _sendRestate(co, msg, clientChannel);
  }

  void* getChannel(const common::LightStringRef& returnAddress)
  {
    assert(_send);
    assert(_getChannel);

    if (_cache == 0) {
      _cache = new ChannelCache();
    }

    ChannelCache::iterator iter = _cache->find(returnAddress);
    if (iter != _cache->end())
    {
      return iter->second;
    }
    else
    {
      void* channel = _getChannel(returnAddress);

      checkPoint;
      char* addr = new char[returnAddress._sz];
      memcpy(addr, returnAddress._buf, returnAddress._sz);
      (*_cache)[common::LightStringRef(addr, returnAddress._sz)] = channel;
      checkPoint;
      return channel;
    }
  }

  void clear()
  {
    if (_cache)
    {
      _cache->clear();
    }
  }

private:
  bool (*_send)(vx::msg::ClientReport&, void*, const vx::msg::ClientRequestPtr&);
  bool (*_sendRestate)(const ClientOrder&, vx::msg::ClientReport&, void*);
  void* (*_getChannel)(const common::LightStringRef returnAddress);
  static __thread ChannelCache* _cache;
};

typedef common::ReturnCode (*ClientRequestPreprocessorFunctionPtr) (ClientOrder&, void*);
typedef void (*RecoveredOrderPreprocessorFunctionPtr) (ClientOrder&, void*);
typedef common::ReturnCode (*SecondaryMsgValidateAndPrepareFunctionPtr)
  (ClientOrder& co_, const vx::msg::ClientRequestPtr& msgPtr_, void* userData_);

void handle_unexpected_message(ClientOrderEvent::Enum eventID, ClientEventArgs& event_, ClientEventContext& context_);

inline common::OrdRejReason getOrdRejReason(common::ReturnCode rc_)
{
 switch (rc_.value())
  {
    case ErrorCode::DUPLICATE_CLORDID:
    case ErrorCode::DUPLICATE_ORDERUUID:
      return common::OrdRejReason::DuplicateOrder;

    case ErrorCode::INVALID_PRODUCT:
      return common::OrdRejReason::UnknownSymbol;

    case ErrorCode::VGLM_LIMIT_BREACH:
      return common::OrdRejReason::ExceedsLimit;

    default:
      return common::OrdRejReason::Invalid;
  }
}

class ClientOrderFSM : public EventHooksMgr<bool (*) (const ClientOrder &, void *), ClientOrderEvent>
{
  friend class ClientOrderManager;
public:
  typedef void (*EventCallback)(const ClientOrder &, void *);
public:
    ClientOrderFSM(ClientRequestPreprocessorFunctionPtr preprocessor_,
                   RecoveredOrderPreprocessorFunctionPtr preprocessRecoveredOrder_,
                   SecondaryMsgValidateAndPrepareFunctionPtr validateAndPreprocessSM_,
                   void* pPreprocessorUserData_,
                   ClientTransport clientTransport_,
                   ExchangeOrderManager& exchangeOrderManager_);
    ~ClientOrderFSM();

    common::ReturnCode dispatch(ClientOrderEvent::Enum event_, ClientEventArgs& eventArgs_);

    common::ReturnCode dispatch(const vx::msg::ClientRequestPtr& msgPtr_, ClientOrder& co_); //?inline

    common::ReturnCode validateClOrdID(const vx::msg::ClientRequestPtr& msg_);
    void removeClOrdID(const std::string&);
    bool validateClOrdID(const common::LightStringRef& id_);
    bool validateOrigClOrdID(const vx::msg::ClientRequestPtr& targetMsgPtr_, const vx::msg::ClientRequestPtr& currentMsgPtr_);

    ClientTransport clientTransport() const { return _clientTransport; }

    void sendPrimaryMessageRejectToClient(
      common::FixMsgFactory& fixMsgFactory_,
      const vx::msg::ClientRequestPtr& clientMsg,
      const std::string& symbol_,
      void* clientTransportChannel_,
      uint64_t limitCheckSummary_,         // tag13845
      const common::LightStringRef& text_, // tag58
      const common::OrdRejReason& rejReason_ = common::OrdRejReason::Invalid); // tag103

    void sendSecondaryMessageRejectToClient(
      common::FixMsgFactory& fixMsgFactory_,
      const vx::msg::ClientRequestPtr& clientMsg_,
      const std::string& symbol_,
      void* clientTransportChannel_,
      const common::CxlRejResponseTo::Enum respondTo_,
      uint64_t limitCheckSummary_,         // tag13845
      const common::LightStringRef& text_, // tag58
      const common::CxlRejReason& rejReason_ = common::CxlRejReason::Invalid); // tag102

    void sendRestateToClient(const ClientOrder& co_);

    void setDestinationID(const common::LightStringRef& destinationID_) { _destinationID = destinationID_; }

private:
    bool sendPrimaryMessageRejectToClient(
      common::FixMsgFactory& fixMsgFactory_,
      const vx::msg::ClientRequestPtr& clientMsg,
      void* clientTransportChannel_,
      uint64_t limitCheckSummary_,             // tag13845
      const common::LightStringRef& text_,     // tag58
      const common::OrdRejReason& rejReason_); // tag103

    bool sendSecondaryMessageRejectToClient(
      common::FixMsgFactory& fixMsgFactory_,
      const vx::msg::ClientRequestPtr& clientMsg_,
      void* clientTransportChannel_,
      const common::CxlRejResponseTo::Enum respondTo_, // tag434
      uint64_t limitCheckSummary_,                     // tag13845
      const common::LightStringRef& text_,             // tag58
      const common::CxlRejReason& rejReason_);         // tag102

    void rejectPrimaryRequest(
      const ClientOrder& co_,
      const vx::msg::ClientRequestPtr& clientMsg,
      common::ReturnCode,
      const common::LightStringRef& text_);
    void rejectSecondaryRequest(
      const ClientOrder& co_,
      const vx::msg::ClientRequestPtr& clientMsg_,
      const common::CxlRejResponseTo::Enum respondTo_,
      common::ReturnCode rc_,
      const common::CxlRejReason& rejReason_);
    void sendNewOrderAckToClient(const ClientOrder& co_);
    void sendOrderReplaceAckToClient(const ClientOrder& co_);
    void sendOrderCancelAckToClient(ClientEventArgs& eventArgs_, ClientEventContext& context_);
    void sendOrderUnsolicitedCancelToClient(ClientOrder& co_, ClientEventContext& context_);
    void sendOrderCancelReplaceRejectToClient(
      const ClientOrder&,
      const vx::msg::ClientRequestPtr&,
      const common::CxlRejResponseTo::Enum,
//      const ORFixCancelRejectReason&,
      const common::LightStringRef text_);

    void sendOrderFillToClient(
      const ClientEventArgs& event_,
      const common::ExecType::Enum,
      const common::ExecTransType::Enum);

    void sendSingleOrderFillToClient(
      const ClientEventArgs& event_,
      const common::ExecType::Enum,
      const common::ExecTransType::Enum);

    void sendChildFillToClient(
      const ClientEventArgs& event_,
      const common::ExecType::Enum,
      const common::ExecTransType::Enum);

    void initial_new_order_request(ClientEventArgs& event_, ClientEventContext& context_);
    void initial_state_client_replace_order(ClientEventArgs& event_, ClientEventContext& context_);
    void initial_state_client_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);

    template<ClientOrderEvent::Enum EventN>
    void handle_unexpected_message(ClientEventArgs& event_, ClientEventContext& context_)
    {
      om::handle_unexpected_message(EventN, event_,context_);
    }

    // Default Handlers
    void default_client_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void default_unsolicited_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void default_force_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);

    void default_slice_replace_succeeded(ClientEventArgs& event_, ClientEventContext& context_);
    void default_slice_cancel_succeeded(ClientEventArgs& event_, ClientEventContext& context_);
    void default_slice_create_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void default_slice_replace_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void default_slice_cancel_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void default_slice_unsolicited_cancel(ClientEventArgs& event_, ClientEventContext& context_);
    void default_engine_restarted(ClientEventArgs& event_, ClientEventContext& context_);
    
    void default_conditional_slice_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void default_conditional_slice_replace_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void default_conditional_slice_unsolicited_cancel(ClientEventArgs& event_, ClientEventContext& context_);
    void default_conditional_slice_firmedUp(ClientEventArgs& event_, ClientEventContext& context_);

    void duplicate_orderuuid_recvd(ClientEventArgs& event_, ClientEventContext& context_);

    void pending_state_slice_trade_cancel(ClientEventArgs& event_, ClientEventContext& context_);

    void filled_state_slice_partially_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void filled_state_slice_fully_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void filled_state_slice_canceled(ClientEventArgs& event_, ClientEventContext& context_);
    void filled_state_slice_replace_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void filled_state_slice_trade_cancel(ClientEventArgs& event_, ClientEventContext& context_);
    void filled_state_slice_trade_correct(ClientEventArgs& event_, ClientEventContext& context_);
    void filled_state_client_replace_order(ClientEventArgs& event_, ClientEventContext& context_);
    void filled_state_client_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void closed_state_slice_unsolicited_cancel(ClientEventArgs& event_, ClientEventContext& context_);
    void closed_state_slice_filled(ClientEventArgs& event_, ClientEventContext& context_);

    void pending_new_state_client_replace_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_new_state_client_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_new_state_force_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);

    void pending_new_state_slice_create_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_new_state_internal_reject_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_new_state_internal_accept_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_new_state_unsolicited_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_new_state_engine_restarted(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_new_state_slice_partially_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_new_state_slice_fully_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_new_state_slice_unsolicited_cancel(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_new_state_slice_force_cancelled(ClientEventArgs& event_, ClientEventContext& context_);

    void new_state_client_replace_order(ClientEventArgs& event_, ClientEventContext& context_);
    void new_state_slice_partially_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void new_state_slice_fully_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void new_state_slice_replace_succeeded(ClientEventArgs& event_, ClientEventContext& context_);

    void partially_filled_state_client_replace_order(ClientEventArgs& event_, ClientEventContext& context_);
    void partially_filled_state_slice_partially_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void partially_filled_state_slice_fully_filled(ClientEventArgs& event_, ClientEventContext& context_);

    void partially_filled_state_slice_trade_cancel(ClientEventArgs& event_, ClientEventContext& context_);
    void partially_filled_state_slice_trade_correct(ClientEventArgs& event_, ClientEventContext& context_);

    void pending_replace_state_client_replace_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_client_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_slice_cancel_succeeded(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_slice_partially_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_slice_fully_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_slice_unsolicited_cancel(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_slice_create_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_slice_replace_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_slice_cancel_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_slice_replace_succeeded(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_force_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_unsolicited_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_slice_trade_correct(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_engine_restarted(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_replace_state_txn_completed(ClientEventArgs& event_, ClientEventContext& context_);

    void pending_cancel_state_client_replace_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_cancel_state_client_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_cancel_state_default_slice_closed(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_cancel_state_slice_fully_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_cancel_state_slice_partially_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_cancel_state_slice_replace_succeeded(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_cancel_state_slice_replace_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_cancel_state_slice_cancel_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_cancel_state_force_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_cancel_state_unsolicited_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_cancel_state_slice_trade_correct(ClientEventArgs& event_, ClientEventContext& context_);
    void pending_cancel_state_engine_restarted(ClientEventArgs& event_, ClientEventContext& context_);

    void prpl_pcxl_state_client_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void prpl_pcxl_state_slice_cancel_succeeded(ClientEventArgs& event_, ClientEventContext& context_);
    void prpl_pcxl_state_slice_partially_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void prpl_pcxl_state_slice_fully_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void prpl_pcxl_state_slice_create_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void prpl_pcxl_state_slice_replace_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void prpl_pcxl_state_slice_cancel_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void prpl_pcxl_state_slice_replace_succeeded(ClientEventArgs& event_, ClientEventContext& context_);
    void prpl_pcxl_force_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void prpl_pcxl_state_unsolicited_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);
    void prpl_pcxl_state_slice_trade_correct(ClientEventArgs& event_, ClientEventContext& context_);
    void prpl_pcxl_state_engine_restarted(ClientEventArgs& event_, ClientEventContext& context_);
    void prpl_pcxl_state_txn_completed(ClientEventArgs& event_, ClientEventContext& context_);

    void pnew_pcxl_state_internal_accept_order(ClientEventArgs& event_, ClientEventContext& context_);
    void pnew_pcxl_state_force_cancel_order(ClientEventArgs& event_, ClientEventContext& context_);

    void pnew_pcxl_state_slice_partially_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void pnew_pcxl_state_slice_fully_filled(ClientEventArgs& event_, ClientEventContext& context_);
    void pnew_pcxl_state_slice_unsolicited_cancel(ClientEventArgs& event_, ClientEventContext& context_);
    void pnew_pcxl_state_slice_create_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void pnew_pcxl_state_slice_cancel_succeeded(ClientEventArgs& event_, ClientEventContext& context_);
    void pnew_pcxl_state_slice_cancel_rejected(ClientEventArgs& event_, ClientEventContext& context_);
    void pnew_pcxl_state_slice_force_cancelled(ClientEventArgs& event_, ClientEventContext& context_);
    void pnew_pcxl_state_engine_restarted(ClientEventArgs& event_, ClientEventContext& context_);

    void on_effective_time_expired(ClientEventArgs& event_, ClientEventContext& context_);

    void cancelled_state_slice_trade_cancel(ClientEventArgs& event_, ClientEventContext& context_);
    void cancelled_state_slice_trade_correct(ClientEventArgs& event_, ClientEventContext& context_);

    static void onEnterPendingNewState(ClientEventArgs& event_, ClientEventContext& context_);
    static void onEnterRejectedState(ClientEventArgs& event_, ClientEventContext& context_);
    static void onEnterNewState(ClientEventArgs& event_, ClientEventContext& context_);
    static void onEnterFilledState(ClientEventArgs& event_, ClientEventContext& context_);
    static void onEnterPartiallyFilledState(ClientEventArgs& event_, ClientEventContext& context_);
    static void onEnterPendingReplaceState(ClientEventArgs& event_, ClientEventContext& context_);
    static void onEnterPendingCancelState(ClientEventArgs& event_, ClientEventContext& context_);
    static void onEnterPendingReplacePendingCancelState(ClientEventArgs& event_, ClientEventContext& context_);
    static void onEnterPendingNewPendingCancelState(ClientEventArgs& event_, ClientEventContext& context_);
    static void onEnterCancelledState(ClientEventArgs& event_, ClientEventContext& context_);

    void initStateMachine();

    static bool process_bust(ClientEventArgs& event_, ClientEventContext& context_);
    static bool process_correction(ClientEventArgs& event_, ClientEventContext& context_);
    bool process_recovered_pending_cancel(ClientEventArgs& event_, ClientEventContext& context_);
    bool process_recovered_pending_replace(ClientEventArgs& event_, ClientEventContext& context_);

    static void commit_pending_replace_request(ClientOrder& co_);
    static void prepare_replace_ack(vx::msg::ExchangeRequestPtr& msg_, ClientOrder& co_);

    common::ReturnCode process_client_replace_order(const vx::msg::ClientRequestPtr& msgPtr_, ClientOrder& co_);

    void reevaluate_prpl_request(ClientOrderEvent::Enum eventType_, ClientOrder& co_, ExchangeOrder* eo_, ClientEventContext& context_);
   void reevaluate_prpl_pcxl_request(ClientOrderEvent::Enum eventType_, ClientEventArgs& event_,ClientEventContext& context_);
    static void resolveStableState(ClientOrder& co_, ClientEventContext& context_);

    static common::ReturnCode process_effective_time(const vx::msg::ClientRequestPtr& msgPtr_, ClientOrder& co_, const common::LightStringRef& effectiveTime, bool useHRTimer_);
    static common::ReturnCode process_effective_time(const vx::msg::ClientRequestPtr& msgPtr_, ClientOrder& co_);
    static common::ReturnCode process_expire_time(const vx::msg::ClientRequestPtr& msgPtr_, ClientOrder& co_);

    common::ReturnCode preprocess(ClientOrder& co_);
    void processRecoveredOrder(ClientOrder& co_);
    void reOpenClosedOrder(ClientOrder& co_);
    void cancelReopenedOrder(ClientOrder& co_, ClientEventContext& context_, common::ReturnCode rc_);

private:
    typedef void (ClientOrderFSM::*EventHandlerFunction) (ClientEventArgs&, ClientEventContext&);

    common::StringSet _clordIdSet;

    ClientRequestPreprocessorFunctionPtr _preprocess;
    RecoveredOrderPreprocessorFunctionPtr _preprocessRecoveredOrder;
    SecondaryMsgValidateAndPrepareFunctionPtr _validateAndPreprocessSM;
    void* _pPreprocessorUserData;

    ClientTransport _clientTransport;

    ExchangeOrderManager& _exchangeOrderManager;
    EventHandlerFunction _eventHandlers[ClientOrderState::Last][ClientOrderEvent::Last];//??review +1 (do we access by index Last?

    // for backward compatible reason, this attribute being set as "SORT"
    // it's only used by setting the tag DestinationID(10010) in the client report
    common::LightStringRef _destinationID = common::CreateFromConstLiteralString("SORT");

};

}}}

#endif
Attention:  ClientOrderFactoryImpl.H
#pragma once

#include <cassert>
#include <memory>
#include <ets/vx/common/ObjectPool.H>
#include "ClientOrder.H"

namespace ets { namespace vx { namespace om {

template <typename ClientOrderType>
class ClientOrderInstantiator
{
public:
  static constexpr bool isRecyclable() { return false; }

  bool initialize(common::ThreadContext& tc_)
  {
    _tc = &tc_;
    return true;
  }

  void create(ClientOrderType& order_)
  {
    assert(_tc);
    new (&order_) ClientOrderType(*_tc);
    order_.setProfileBackup(_tc->orderProfileAccessor().backupProfile());
    order_.setProfile(_tc->orderProfileAccessor().primaryProfile());
  }

  void recycle(ClientOrderType& order_) {}

  void destroy(ClientOrderType& order_)
  {
    order_.~ClientOrderType();
  }

private:
  common::ThreadContext* _tc = nullptr;
};

template <typename ClientOrderType> using ClientOrderObjectPool = common::ObjectPool<ClientOrderType, ClientOrderInstantiator<ClientOrderType>>;

template <typename ClientOrderType>
class ClientOrderFactoryImpl
{
public:
  ClientOrderFactoryImpl(const std::shared_ptr<ClientOrderObjectPool<ClientOrderType>>& pool_ = std::make_shared<ClientOrderObjectPool<ClientOrderType>>())
    :_pool(pool_)
  {
  }

  bool initialize(common::ThreadContext& tc_, size_t initSize_, size_t increaseSize_)
  {
    if (!_pool)
    {
      ORlogError << "ClientOrderObjectPool is not instantiated" << ORLog::send;
      return false;
    }
    if (!_pool->instantiator().initialize(tc_))
    {
      ORlogError << "ClientOrderInstantiator failed to initialize" << ORLog::send;
      return false;
    }
    if (!_pool->initialize(initSize_, increaseSize_))
    {
      ORlogError << "ClientOrderObjectPool failed to initialize" << ORLog::send;
      return false;
    }
    return true;
  }

  ClientOrderFactory get()
  {
    assert(_pool);
    return ClientOrderFactory(createClientOrder, releaseClientOrder, _pool.get());
  }

  ClientOrderObjectPool<ClientOrderType>& pool() { assert(_pool); return *_pool; }
  const ClientOrderObjectPool<ClientOrderType>& pool() const { assert(_pool); return *_pool; }

private:
  VX_HOT_FLATTEN
  static ClientOrder* createClientOrder(common::ThreadContext& tc_, StripeContext& sc_, bool isListOrder_, void* sender_, void* pool_)
  {
    assert(sender_);
    assert(pool_);
    ClientOrderObjectPool<ClientOrderType>& pool = *static_cast<ClientOrderObjectPool<ClientOrderType>*>(pool_);
    ClientOrderType* co = pool.get();
    co->init(&sc_, isListOrder_, sender_);
    return co;
  }

  VX_HOT_FLATTEN
  static void releaseClientOrder(ClientOrder* co_, void* pool_)
  {
    ClientOrderObjectPool<ClientOrderType>& pool = *static_cast<ClientOrderObjectPool<ClientOrderType>*>(pool_);
    pool.destroy(static_cast<ClientOrderType*>(co_));
  }

private:
  std::shared_ptr<ClientOrderObjectPool<ClientOrderType>> _pool;
};

}}}

Attention:  ClientOrderFsmTypes.H
#pragma once

#include "ErrorCode.H"

#include <ets/vx/em/ExchangeDefs.H>
#include <ets/vx/common/Enums.H>
#include <ets/vx/om/Fwd.H>

#include <ets/oom/OrderData.H>
#include <OR/fr/fix/FixRouter.H>

#ifndef NDEBUG
#include <boost/static_assert.hpp>
#ifndef VX_ENUM_CASE
#define VX_ENUM_CASE(x) case x: return #x
#define VX_ENUM_DEFAULT(x) default: return #x
#endif
#endif

namespace ets { namespace vx { namespace om {

struct CancelFlag
{
  enum Enum 
  {
    AllowQue     = 0x01,            // queue cxl if certain exchange can not handle
    DisableQue   = AllowQue << 1,   // force cxl to be sent even if downstream might not handle
    Forced       = DisableQue << 1, // bypass the cancel request evaluator
    Applied      = Forced << 1,     // change order state to cancelled immediately 
    ForceApplied = Forced | Applied  
  };

  static inline bool isForced(Enum e_) 
  {
    return e_ & Forced;
  }

  static inline bool isApplied(Enum e_)
  {
    return e_ & Applied;
  }
};

struct ClientOrderEvent
{
//If add event, add handle_unexpected_message in initStateMachine
  enum Enum
  {
    /* Client Initiated Events */
    ClientNewOrder=0, //0
    ClientReplaceOrder, // 1
    ClientCancelOrder, // 2

    /* Exchange Initiated Events */
    SliceCreateSucceeded, // 3
    SliceReplaceSucceeded, // 4
    SliceCancelSucceeded, // 5
    SlicePartiallyFilled, // 6
    SliceFullyFilled, // 7
    SliceUnsolicitedCancel, // 8
    SliceTradeCancel, // 9
    SliceTradeCorrect, // 10
    SliceCreateRejected, // 11
    SliceReplaceRejected, // 12
    SliceCancelRejected, // 13
    ConditionalSliceRejected, // 14
    ConditionalSliceReplaceRejected, // 15
    ConditionalSliceUnsolicitedCancel, // 16
    ConditionalSliceFirmedUp, // 17

    /* Internal Events */
    SliceForceCanceled, // 18
    RejectOrder, // 19
    AcceptOrder, // 20
    ForceCancelOrder, // 21
    UnsolicitedCancelOrder, // 22
    EffectiveTime, // 23
    Restart, // 24
    RestateOrder, // 25
    TransactionCompleted, // 26
    
    Last // Always have this as the last element
  };

  static Enum eventType(const common::MsgType::Enum msgType)
  {
    switch(msgType)
    {
      case common::MsgType::OrderSingle:               return ClientNewOrder;
      case common::MsgType::OrderMultileg:             return ClientNewOrder;
      case common::MsgType::OrderCancelReplaceRequest: return ClientReplaceOrder;
      case common::MsgType::OrderMultilegAmend:        return ClientReplaceOrder;
      case common::MsgType::OrderCancelRequest:        return ClientCancelOrder;
    }

    ORlogError << "MsgType [" << msgType << "] not supported by sort OM" << ORLog::send;
    assert(false);
    return Last;
  };

#ifndef NDEBUG
  static const char* asString(const Enum event_)
  {
    BOOST_STATIC_ASSERT(Last == 27);
    switch(event_)
   {
      VX_ENUM_CASE(ClientNewOrder);
      VX_ENUM_CASE(ClientReplaceOrder);
      VX_ENUM_CASE(ClientCancelOrder); 
      VX_ENUM_CASE(SliceCreateSucceeded);
      VX_ENUM_CASE(SliceReplaceSucceeded);
      VX_ENUM_CASE(SliceCancelSucceeded);
      VX_ENUM_CASE(SlicePartiallyFilled);
      VX_ENUM_CASE(SliceFullyFilled);
      VX_ENUM_CASE(SliceUnsolicitedCancel);
      VX_ENUM_CASE(SliceTradeCancel);
      VX_ENUM_CASE(SliceTradeCorrect);
      VX_ENUM_CASE(SliceCreateRejected);
      VX_ENUM_CASE(SliceReplaceRejected);
      VX_ENUM_CASE(SliceCancelRejected);
      VX_ENUM_CASE(SliceForceCanceled);
      VX_ENUM_CASE(ConditionalSliceRejected);
      VX_ENUM_CASE(ConditionalSliceReplaceRejected);
      VX_ENUM_CASE(ConditionalSliceUnsolicitedCancel);
      VX_ENUM_CASE(ConditionalSliceFirmedUp);
      VX_ENUM_CASE(RejectOrder);
      VX_ENUM_CASE(AcceptOrder);
      VX_ENUM_CASE(ForceCancelOrder);
      VX_ENUM_CASE(UnsolicitedCancelOrder);
      VX_ENUM_CASE(EffectiveTime);
      VX_ENUM_CASE(Restart);
      VX_ENUM_CASE(RestateOrder);
      VX_ENUM_CASE(TransactionCompleted);
      VX_ENUM_DEFAULT(Invalid);
    }
  }
#endif
};

//Caution: State value is different from Fix tag value
struct ClientOrderState
{
  enum Enum
  {
    New = 0, //0
    PartiallyFilled, // 1
    Filled, // 2
    Cancelled, // 3
    Rejected, // 4
    PendingNew, // 5
    PendingCancel, // 6
    PendingReplace, // 7
    PendingReplacePendingCancel, // 8
    PendingNewPendingCancel, // 9
    Initial, // 10
    Last // 11
  };
#ifndef NDEBUG
  static const char* asString(const Enum state_)
  {
    BOOST_STATIC_ASSERT(Last == 11);
    switch(state_)
    {
      VX_ENUM_CASE(New);
      VX_ENUM_CASE(PartiallyFilled);
      VX_ENUM_CASE(Filled); 
      VX_ENUM_CASE(Cancelled);
      VX_ENUM_CASE(Rejected);
      VX_ENUM_CASE(PendingNew);
      VX_ENUM_CASE(PendingCancel);
      VX_ENUM_CASE(PendingReplace);
      VX_ENUM_CASE(PendingReplacePendingCancel);
      VX_ENUM_CASE(PendingNewPendingCancel);
      VX_ENUM_CASE(Initial);
      VX_ENUM_DEFAULT(Invalid);
    }
  }
#endif
};

struct ClientEventArgs
{
  ClientEventArgs(ClientOrder& co_)
  : _co(co_),
    _msgPtr(NULL),
    _eo(NULL),
    _pOrderData(NULL)
  {}

  ClientEventArgs(const vx::msg::ClientRequestPtr& msg_, ClientOrder& co_)
  : _co(co_),
  _msgPtr(msg_),
  _eo(NULL),
  _pOrderData(NULL)
  {}

  ClientEventArgs(ExchangeOrder* eo_, ClientOrder& co_)
  : _co(co_),
    _msgPtr(NULL),
    _eo(eo_),
    _pOrderData(NULL)
  {}

  ClientEventArgs(ClientOrder& co_, const ets::oom::OrderData* pOrderData_)
  : _co(co_),
    _msgPtr(NULL),
    _eo(NULL),
    _pOrderData(pOrderData_)
  {}

  ClientOrder& _co;
  vx::msg::ClientRequestPtr _msgPtr;
  ExchangeOrder* _eo;
  const ets::oom::OrderData* _pOrderData;
};

class ClientEventContext
{
public:
  typedef void(*StateEntryFunction)(ClientEventArgs& args_, ClientEventContext& context);

  ClientEventContext(ClientOrderState::Enum prevState_)
  : _prevState(prevState_),
    _newState(prevState_),
    _dispatchErrorCode(ErrorCode::SUCCESS),
    _previousActionResult(ErrorCode::SUCCESS),
    _newStateEntryFunction(NULL)
  {}

  bool hasStateChanged() const { return _newState != _prevState; }
  StateEntryFunction newStateEntryFunction() const { return _newStateEntryFunction; }
  ClientOrderState::Enum newState() const { return _newState; }
  ClientOrderState::Enum prevState() const { return _prevState; }
  common::ReturnCode dispatchError() const { return _dispatchErrorCode; }
  common::ReturnCode previousActionResult() const { return _previousActionResult; }

  void setDispatchError(common::ReturnCode errorCode_) { _dispatchErrorCode = errorCode_;}
  void setResult(common::ReturnCode errorCode_) { _previousActionResult = errorCode_;}

  void apply(ClientOrderState::Enum state_, StateEntryFunction entry_)
  {
    _newState = state_;
    _newStateEntryFunction = entry_;
  }

  void apply(ClientOrderState::Enum state_, StateEntryFunction entry_, common::ReturnCode result)
  {
    _previousActionResult = result;
    apply(state_, entry_);
  }

private:
  StateEntryFunction _newStateEntryFunction;
  common::ReturnCode _dispatchErrorCode;
  common::ReturnCode _previousActionResult;
  ClientOrderState::Enum _prevState;
  ClientOrderState::Enum _newState;
};

}}}

Attention:  ClientOrderImpl.H
#pragma once

#include "ExchangeOrder.H"
#include "NotionalClientOrder.H"

#include <ets/vx/common/MemoryAllocator.H>
#include <ets/vx/common/Transaction.H>
#include <ets/vx/logging/logging.H>
#include <ets/oom/OrderData.H>
#include <boost/foreach.hpp>

#include "RecoveryUtil.H"
#include "ExchangeOrderManager.H"

#include <ets/vx/em/ExchangeFactory.H>
#include <ets/vx/em/AllocationEntries.H>

namespace ets { namespace vx { namespace om {

inline common::ReturnCode ClientOrder::enterPendingNew()
{
  _currentPrice = _targetPrice = _lastOrderUpdateMsgPtr->Price;
  _currentQty = _targetQty = _pocketQty = _lastOrderUpdateMsgPtr->OrderQty;

  return isListOrder() ? static_cast<NotionalClientOrder&>(*this).notionalEnterPendingNew() : common::ReturnCode::SUCCESS;
}

inline common::ReturnCode ClientOrder::enterPendingReplace()
{
  _targetPrice=_pendingReplaceRequestMsgPtr->Price;
  _targetQty=_pendingReplaceRequestMsgPtr->OrderQty;
  if(isPunted() || !_profile->_omAttributes.optimisticReplaceAck)
  {
    _pocketQty += _targetQty - _currentQty;
  }
  return isListOrder() ? static_cast<NotionalClientOrder&>(*this).notionalEnterPendingReplace() : common::ReturnCode::SUCCESS;
}

inline void ClientOrder::acceptReplaceRequest()
{
  assert(_pendingReplaceRequestMsgPtr.isValid());
  _lastOrderUpdateMsgPtr = _pendingReplaceRequestMsgPtr;

  _pendingReplaceRequestMsgPtr.reset();
  _flags |= Flags::WAS_REPLACED;
  _eventsSinceLastEval |= EvalTriggerEvent::ReplaceRequestAcked;

  if(!isPunted() && _profile->_omAttributes.optimisticReplaceAck)
  {
    _pocketQty += _targetQty - _currentQty;
  }
  _currentPrice = _targetPrice;
  _currentQty = _targetQty;

  if (isListOrder())
  {
    static_cast<NotionalClientOrder&>(*this).notionalAcceptReplaceRequest();
  }
}

inline void ClientOrder::rejectReplaceRequest()
{
  if(isPunted() || !_profile->_omAttributes.optimisticReplaceAck)
  {
    // the pocket qty will only be updated before if order hits this condition.
    _pocketQty -= _targetQty - _currentQty;
  }
  _targetPrice = _currentPrice;
  _targetQty = _currentQty;

  if (isListOrder())
  {
    static_cast<NotionalClientOrder&>(*this).notionalRejectReplaceRequest();
  }
}

inline void ClientOrder::acceptCancelRequest()
{
  if (_pendingCancelRequestMsgPtr.isValid())
  {
    _lastOrderUpdateMsgPtr = _pendingCancelRequestMsgPtr;
    _pendingCancelRequestMsgPtr.reset();
  }
}

inline EvalTriggerEvents ClientOrder::addFill(Quantity fillQty_, Amount fillValue_, ExchangeOrder& eo_)
{
  if (isListOrder())
  {
    return static_cast<NotionalClientOrder&>(*this).notionalAddFill(fillQty_, fillValue_, eo_);
  }
  else
  {
    _cumQty += fillQty_;
    _cumValue += fillValue_;
    return EvalTriggerEvent::None;
  }
}

inline void ClientOrder::removeFill(Quantity fillQty_, Amount fillValue_, ExchangeOrder& eo_)
{
  if (isListOrder())
  {
    static_cast<NotionalClientOrder&>(*this).notionalRemoveFill(fillQty_, fillValue_, eo_);
  }
  else
  {
    _cumQty -= fillQty_;
    _cumValue -= fillValue_;
  }
}

inline void ClientOrder::reducePocketQty(Quantity qty_, ExchangeOrder& eo_)
{
  assert(qty_ >= QuantityZero);
  _pocketQty -= qty_;

  if (isListOrder())
  {
    static_cast<NotionalClientOrder&>(*this).notionalReducePocketQty(qty_, eo_);
  }
}

inline void ClientOrder::increasePocketQty(Quantity qty_, ExchangeOrder& eo_)
{
  assert(qty_ >= QuantityZero);
  _pocketQty += qty_;

  if (isListOrder())
  {
    static_cast<NotionalClientOrder&>(*this).notionalIncreasePocketQty(qty_, eo_);
  }
}

inline void ClientOrder::reduceChildIOCLeavesQty(Quantity qty_, ExchangeOrder& eo_)
{
  _childIOCLeavesQty -= qty_;
  assert(_childIOCLeavesQty >= QuantityZero);

  if (isListOrder())
  {
    static_cast<NotionalClientOrder&>(*this).notionalReduceChildIOCLeavesQty(qty_, eo_);
  }
}

inline void ClientOrder::increaseChildIOCLeavesQty(Quantity qty_, ExchangeOrder& eo_)
{
  _childIOCLeavesQty += qty_;
  assert(_childIOCLeavesQty >= QuantityZero);

  if (isListOrder())
  {
    static_cast<NotionalClientOrder&>(*this).notionalIncreaseChildIOCLeavesQty(qty_, eo_);
  }
}

inline void ClientOrder::reduceChildPinnedQty(Quantity qty_, ExchangeOrder& eo_)
{
  _childPinnedQty -= qty_;
  assert(_childPinnedQty >= QuantityZero);

  if (isListOrder())
  {
    static_cast<NotionalClientOrder&>(*this).notionalReduceChildPinnedQty(qty_, eo_);
  }
}

inline void ClientOrder::increaseChildPinnedQty(Quantity qty_, ExchangeOrder& eo_)
{
  _childPinnedQty += qty_;
  assert(_childPinnedQty >= QuantityZero);

  if (isListOrder())
  {
    static_cast<NotionalClientOrder&>(*this).notionalIncreaseChildPinnedQty(qty_, eo_);
  }
}

// below three methods are only used by ClientOrderFSM
inline bool ClientOrder::hasFills() const
{
  return _cumQty != QuantityZero || isListOrder() && static_cast<const NotionalClientOrder&>(*this).hasLegFills();
}

inline bool ClientOrder::isCurrentFullyFilled() const
{
  return isListOrder() ? static_cast<const NotionalClientOrder&>(*this).isNotionalCurrentFullyFilled() : _cumQty >= _currentQty;
}

inline bool ClientOrder::willTargetFullyFilled() const
{
  return isListOrder() ? static_cast<const NotionalClientOrder&>(*this).willNotionalTargetFullyFilled() : _cumQty >= _targetQty;
}

inline Quantity ClientOrder::getPocketQty(const exch::AllocationEntry& ae_) const
{
  return isListOrder() ? static_cast<const NotionalClientOrder&>(*this).clipLegPocketQty(ae_) : pocketQty();
}

inline Quantity ClientOrder::getLeavesQty(const exch::AllocationEntry& ae_) const
{
  return isListOrder() ? static_cast<const NotionalClientOrder&>(*this).clipLegLeavesQty(ae_) : leavesQty();
}

inline bool ClientOrder::hasEnoughAllocatableQty(const ExchangeSliceOperation& op_) const
{
  if (!isListOrder())
  {
    return allocatableQty() >= op_.qtyRequiredFromPocket();
  }
  else
  {
    return static_cast<const NotionalClientOrder&>(*this).clipHasEnoughAllocatableQty(op_);
  }
}

inline void ClientOrder::addChildOrder(ExchangeOrder* eo_)
{
  assert(eo_);
  Quantity childQty = eo_->current().orderQty();
  _pocketQty -= childQty;

  if (eo_->current().timeInForce() == common::TimeInForce::ImmediateOrCancel)
  {
    increaseChildIOCLeavesQty(std::max(childQty - eo_->cumQty(), QuantityZero), *eo_);
  }
  else if (eo_->isPinned())
  {
    increaseChildPinnedQty(std::max(childQty - eo_->cumQty(), QuantityZero), *eo_);
  }

  _openChildOrdersRoot.pushFront(eo_);
  ++_numChildren;

  if (isListOrder())
  {
    static_cast<NotionalClientOrder&>(*this).onChildOrderAdded(eo_);
  }
}

inline ExchangeSliceOperation::Status ClientOrder::processExchangeSliceOperations()
{
    XPROBEGUARD(ClientOrder_processExchangeSliceOperations);

    if (isListOrder())
    {
      return static_cast<NotionalClientOrder&>(*this).notionalProcessExchangeSliceOperations();
    }
    
    //mark the current transaction as part of a previous transaction
    //so this will make message sent to downstream take the 
    //eval id booked in client order which is left from 
    //last evaluation instead of using the one from tls 
    //transaction object
    currentTransaction().setEval(&_lastEvalId);
    
    stripeContext().prepLimitChecks();  // queue market data snap, before exchange slices are processed & evaluated
    exch::RoutingStrategy routingStrategy;
    common::LightSingleLinkedListRemoveIterator<ExchangeSliceOperation> it(_pendingOperationsRoot);
    while( it.node() )
    {
        checkPoint;
        ExchangeSliceOperation* pEso=it.node();

        if(pEso->allocationEntry())
        {
          checkPoint;
          pEso->allocationEntry()->log(stripeContext().priceScalingFactor()._n);
        }

        if (pEso->qtyRequiredFromPocket()==QuantityZero || hasEnoughAllocatableQty(*pEso))
        {
            checkPoint;
            ExchangeSliceOperation::Status status = pEso->apply();
            // isValid check should be called before processing cached ExchangeSliceOperations.
            switch (status)
            {
                case ExchangeSliceOperationStatus::SUCCESS:
                    routingStrategy = pEso->exchOrder()->routingInfo().routingStrategy;
                    _reportNMS = _reportNMS
                                 || ((routingStrategy == exch::RoutingStrategy::ISO || routingStrategy == exch::RoutingStrategy::DIRECTED_ISO) 
                                     && pEso->allocationEntry() && ! pEso->allocationEntry()->skipNMSReporting());

                    checkPoint;
//                    SORTLOG._printProtectedColumnInBook = _reportNMS;  // TODO?
                    checkPoint;
                    ExchangeSliceOperation::release( *it.remove() );
                    break;
                 
                case ExchangeSliceOperationStatus::CONDITIONAL_ORDER_CXL_SUCCESS:
                    //Once a conditional order is cancelled it is evicted from memory
                    //therefore we can't access EO information such as routingInfo.
                    //If that needs to be added in the future we can always move the logic
                    //inside the apply() function
                    ExchangeSliceOperation::release(*it.remove());
                    break;

                case ExchangeSliceOperationStatus::DEFER:
                    it.next();

                    break;
                case ExchangeSliceOperationStatus::ERROR:

                    checkPoint;
                    purgePendingOperations();
                    checkPoint;
                    return status;
            }
        }
        else
        {
            it.next();
        }
    }
    checkPoint;

    return ExchangeSliceOperationStatus::SUCCESS;
}

inline bool ClientOrder::validateRecoveredState(std::ostringstream& os_, bool alert_)
{
  if (isListOrder())
    return static_cast<NotionalClientOrder&>(*this).notionalValidateRecoveredState(os_, alert_);

  const MSHashSet<common::LightStringRef>& unprocessedExecIds = _tc.eom().unProcessedExecIds(this);

  if (!unprocessedExecIds.empty())
  {
    os_ << "still has unprocessed ExecIds";
    BOOST_FOREACH(common::LightStringRef execId, unprocessedExecIds)
    {
      os_ << "\n" << execId;
    }
    if (alert_)
    {
      raiseAlert<om::alert::OrderInconsistent>("Having unprocessed executions");
    }
    return false;
  }

  Quantity childCum = sumChildCumQty();
  // Ignore pricision loss in sum of child quantity
  if( childCum > _cumQty && (childCum - _cumQty) > Quantity(QtyScalingFactor._intToScale) ||
      childCum < _cumQty && (_cumQty - childCum) > Quantity(QtyScalingFactor._intToScale))
  {
    os_ << "sum of child cumQty (" << qtyToDouble(childCum) << ") != parent cumQty (" << qtyToDouble(_cumQty) << ")";
    if (alert_)
    {
      raiseAlert<om::alert::OrderInconsistent>("CumQty is not in sync with sum of child cumQty");
    }
    return false;
  }

  const ExchangeOrder* eo = _openChildOrdersRoot.node();

  int numInvalidChildren = 0;
  while (eo)
  {
    switch(eo->placementState())
    {
    case ExchangeOrderState::Filled:
    case ExchangeOrderState::Cancelled:
    case ExchangeOrderState::Rejected:
    case ExchangeOrderState::DoneForDay:
      {
        os_ << "\n" << "Exchange Order " << eo->orderUUIDStr()
            << " was recovered in closed state [" << eo->ordStatus() <<
            "] but did not receive terminal message." ;
        ++numInvalidChildren;
      }
      break;
    };

    eo = eo->next();
  }

  if (numInvalidChildren)
  {
    os_ << "\n" << numInvalidChildren << " child order(s) in inconsistent state";
    if (alert_)
    {
      raiseAlert<om::alert::OrderInconsistent>("Having closed child order without recieving terminal message");
    }
    return false;
  }
  return true;
}


}}}

Attention:  ClientOrderListNode.H
#ifndef vx_om_ClientOrderListNode_H
#define vx_om_ClientOrderListNode_H

///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#include <ets/vx/common/LightList.H>

namespace ets { namespace vx { namespace om {

class ClientOrder;

class ClientOrderListNode : public common::LightDoubleLinkedListNode<ClientOrderListNode>, public boost::noncopyable
{
  public:
    ClientOrderListNode(ClientOrder& co_) : _co(co_) {}
        
    ClientOrder& _co;
};

}}}

#endif
Attention:  ClientOrderManager.H
#pragma once

#include "ClientOrderFSM.H"
#include "ClientOrderFsmTypes.H"
#include "EvalTriggers.H"

#include <boost/noncopyable.hpp>
#include <ets/vx/common/ReturnCode.H>
#include <ets/vx/om/Fwd.H>

#include <ets/oom/RecoveryClient.H>

#include <unordered_map>
#include <boost/functional/hash.hpp>

namespace ets { namespace vx { namespace om {

// ClientOrderGhost
//   minimal client order details, which survive even the eviction of an order
class ClientOrderGhost : public boost::noncopyable
{
protected:
    enum State { Empty = 0, Current, Evicted, Deleted };
public:
    ClientOrderGhost()
        : _uuid(true)
        , _co(0)                                 // saving a pointer; this will be nulled out when evicted
        , _last(common::OrdStatus::Invalid)      // set & valid only after order is evicted
        , _state(Empty)
    { }
    ~ClientOrderGhost() { _state = Deleted; }    // just an aid for debugging

    ClientOrder*  co() const   { return _co; }   // pointer to client order; null IFF order has been evicted and destroyed
    const MSUuid& uuid() const { return _uuid; } // order's uuid

    common::OrdStatus::Enum ordStatus() const;   // last order status; from order when live, from saved value after order expires

    bool isEvicted() const { return _state == Evicted; }   // true IFF ghost was attached to now-evicted order
    bool isEmpty()   const { return _state == Empty; }     // fresh, uninitialized ghost
    bool isListOrder() const { return _isListOrder; }

protected:
    MSUuid                  _uuid;               // order's ms uuid; available from construction
    ClientOrder*            _co;                 // non-null once order accepted, until order evicted
    common::OrdStatus::Enum _last;               // last order status, defined once order is evicted
    State                   _state;              // internal state of the ghost and referenced order
    bool                    _isListOrder = false;// single order or multileg order

    void init(const MSUuid&, ClientOrder&);      // link our ghost to it's order
    void expire();                               // kill an order being evicted
    void revive();                               // prep evicted order for resurrection (reuse, for single-order voom recovery)

    friend class ClientOrder;                    // ClientOrder will sever connection to ghost as it dies
    friend class ClientOrderManager;             // COM will associate orders and their ghosts, as appropriate
};

// ClientOrderFactory
//   interface masking parametized allocate/deallocate functions for ClientOrder objects
struct ClientOrderFactory
{
    typedef ClientOrder* (*ClientOrderAllocFuncPtr)(common::ThreadContext&, om::StripeContext&, bool /*isListOrder_*/, void*, void*);
    typedef void (*ClientOrderDeallocFuncPtr)(ClientOrder*, void*);

    ClientOrderFactory (ClientOrderAllocFuncPtr create_, ClientOrderDeallocFuncPtr release_, void* userData_)
      : _create(create_),
        _release(release_),
        _userData(userData_)
    {}

    ClientOrder* create(common::ThreadContext& tc_, om::StripeContext& sc_, bool isListOrder_, void* channel_)
    {
        return _create(tc_, sc_, isListOrder_, channel_, _userData);
    }

    void release(ClientOrder* co_)
    {
        _release(co_, _userData);
    }

private:
    void* _userData;
    ClientOrderAllocFuncPtr _create;
    ClientOrderDeallocFuncPtr _release;
};

struct ClientOrderEvictionPolicy : boost::noncopyable
{
    typedef bool (*Function)(const ClientOrder* co_, void* userData_);

    ClientOrderEvictionPolicy(Function func_, void* userData_)
      :_func(func_), _userData(userData_)
    {
        assert(_func);
    }

    bool operator()(const ClientOrder* co_)
    {
        return _func(co_, _userData);
    }

private:
    Function _func;
    void* _userData;
};

class ClientOrderManager
{
public:
    ClientOrderManager(ClientRequestPreprocessorFunctionPtr preprocessor_,
                       RecoveredOrderPreprocessorFunctionPtr preprocessRecoveredOrder_,
                       SecondaryMsgValidateAndPrepareFunctionPtr validateAndPreprocessSM_,
                       void* pPreprocessorUserData_,
                       bool (*send_)(vx::msg::ClientReport&, void*, const vx::msg::ClientRequestPtr&),
                       bool (*sendRestate_)(const ClientOrder&, vx::msg::ClientReport&, void*),
                       void* (*getChannel_)(const common::LightStringRef topic),
                       ExchangeOrderManager& exchangeOrderManager_,
                       ClientOrderFactory orderFactory_);
    ~ClientOrderManager();


    ClientOrderFSM& fsm() {return _fsm;}

    // find active (non-evicted) order; return null if no sure (active) order
    ClientOrder*  findOrder(const MSUuid& orderUUID_);               // lookup order by UUID; returns non-evicted orders only
   ClientOrder*  findOrder(const common::LightStringRef& uuidStr);  // lookup order by UUID str; NB: more expensive than above
    // find any order's ghost, active or evicted; return null if UUID has never been seen
    ClientOrderGhost* findOrderGhost(const MSUuid& orderUUID_);      // lookup order ghost; ghosts are never evicted

    void processFixMessage(
      const vx::msg::ClientRequestPtr& msg_,
      om::StripeContext& stripeContext_,
      common::ThreadContext& tc_);

    common::ReturnCode processRecoveredMsg(
       const oom::OrderData& orderData_,
       om::StripeContext& sc_,
       common::ThreadContext& tc_,
       ClientOrder*& pOrderRef_,
       bool migrated_,
       bool recovery_ = true);

    common::ReturnCode processAdminCancel(ClientOrder* co_, CancelFlag::Enum);
    common::ReturnCode processAdminCancel(ExchangeOrder* eo_, CancelFlag::Enum);

    void processAdminRemove(ClientOrder*);

    void processEvictedOrderIds(const ets::oom::OrderIDMap& evictedOrderIds_);

    void onPostEvent(ClientOrder* co_); // Function can release co_

    void disableEval();
    void enableEval();
    bool isEvalDisabled() const { return _forceDisableEval; }

    typedef std::unordered_map<const MSUuid, ClientOrderGhost, boost::hash<const boost::uuids::uuid>> OrderMap;
    const OrderMap& orders() const { return _orders; }

    typedef MSHashSet<std::string> PuntTNLSet;
    const PuntTNLSet& puntTNLSet() const { return _puntTNLSet; }
    PuntTNLSet& puntTNLSet() { return _puntTNLSet; }

    void setEvictionPolicy(ClientOrderEvictionPolicy* evictionPolicy_)   { _evictionPolicy = evictionPolicy_; }

    bool initAllocationEntries(); 
    exch::AllocationEntries& allocationEntries() { assert(_allocationEntries); return *_allocationEntries; }
    exch::AllocationEntries& legAllocationEntries(LegId legId_);
    exch::AllocationEntries** legAllocationEntries() { return _legAllocationEntries; }
    
private:
    void evictClientOrder( ClientOrder* co_ ); // Function can release co_

    void* getOrderChannel(const vx::msg::ClientRequestPtr& msgPtr_);

    ClientOrderFactory _orderFactory;
    OrderMap _orders;
    std::unordered_map<MSUuid /* LegOrderUUID */, MSUuid /* NotionalOrderUUID */, boost::hash<const boost::uuids::uuid>> _legOrderIds;
    PuntTNLSet _puntTNLSet;
    ClientOrderFSM _fsm;
    uint8_t _forceDisableEval;

    ClientOrderEvictionPolicy* _evictionPolicy;

    exch::AllocationEntries* _allocationEntries = nullptr;
    exch::AllocationEntries* _legAllocationEntries[MaxNumOfLegs()] = {};
};

// find orders and order ghosts
inline ClientOrderGhost* ClientOrderManager::findOrderGhost(const MSUuid& orderUUId)
{
    OrderMap::iterator it = _orders.find(orderUUId);
    if (it != _orders.end())                  // if we found it
        return &(it->second);                 //  return as a pointer

    if (!_legOrderIds.empty())
    {
      const auto& find = _legOrderIds.find(orderUUId);
      if (find != _legOrderIds.end())
      {
        it = _orders.find((*find).second);
        if (it != _orders.end())
        {
          return &(it->second);
        }
      }
    }
    return nullptr;
}

inline ClientOrder* ClientOrderManager::findOrder(const MSUuid& orderUUId)
{
    ClientOrderGhost* ghost = findOrderGhost(orderUUId);
    return ghost ? ghost->co() : nullptr;     // ghost->co() will also be NULL if the order has been evicted
}

inline ClientOrder* ClientOrderManager::findOrder(const common::LightStringRef& uuidStr_)
{
    MSUuid uuid(true);
    if (!MSUuid::fromString(uuid, uuidStr_._buf, uuidStr_._sz))
        return nullptr;
    return findOrder(uuid);
}

inline exch::AllocationEntries& ClientOrderManager::legAllocationEntries(LegId legId_)
{
  assert(legId_ < MaxNumOfLegs());
  assert(_legAllocationEntries[legId_]);
  return *_legAllocationEntries[legId_];
}

}}}

Attention:  DefaultReplaceRequestEvaluator.H
#ifndef ets_vx_om_DefaultReplaceRequestEvaluator_H
#define ets_vx_om_DefaultReplaceRequestEvaluator_H

///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////
#include "ReplaceRequestEvaluators.H"
#include "ClientOrder.H"

#include "../common/ReturnCode.H"

namespace ets { namespace vx { namespace om {

ReplaceActionEnum defaultReplaceRequestEvaluator(
  ClientOrderEvent::Enum event_, 
  ClientOrder& co_, 
  ExchangeOrder* eo_,
  common::ReturnCode& rc_, 
  void* pUserData_); //ClientReplaceRequestEvaluator

}}}

#endif
Attention:  DeltaEngine.H
#ifndef vx_om_DeltaEngine_H
#define vx_om_DeltaEngine_H
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#include <ets/vx/common/MemoryAllocator.H>
#include <ets/vx/common/LightList.H>
#include <ets/vx/om/Fwd.H>

namespace ets { namespace vx { namespace om {

class DeltaEngine
{
public:
  static void computeDelta(ClientOrder* co_, common::ThreadContext& tc_, exch::AllocationEntry** base_, common::LightSingleLinkedListRoot<ExchangeSliceOperation>& result_, bool unpinAll_);
  static void computeDelta(ClientOrder* co_, common::ThreadContext& tc_, exch::AllocationEntry** base_, common::LightSingleLinkedListRoot<ExchangeSliceOperation>& result_, const std::function<bool(const ExchangeOrder&)>& predicate_);
};

}}}
#endif
Attention:  DeltaEngineImpl.H
#ifndef vx_om_DeltaEngineImpl_H
#define vx_om_DeltaEngineImpl_H

#include <OR/utility/core/CompilerBuiltins.H>

namespace ets { namespace vx { namespace om {

struct DefaultPredicate
{
  template <typename ExchangeOrder>
  bool operator()(const ExchangeOrder& eo_) const 
  {
    return true;
  }
};

template <typename ExchangeOrder>
inline bool mustRetainEO(const ExchangeOrder& eo_, bool unpinAll_);

// return true if  EO is keepable
// return false if EO needs to checked again by delta
template <typename ExchangeMgr, typename ExchangeOrder, typename AllocationEntries>
inline bool mustRetainEO(const ExchangeMgr& em_, const ExchangeOrder& eo_, AllocationEntries& all_, bool unpinAll_);

//assumes everything is ammendable except for Exchange/TIF/Side/Symbol/RoutingInfo
template <typename ExchangeMgr, typename ExchangeOrder, typename AllocationEntries, typename Operation>
inline void computeDeltaForEO(const ExchangeMgr& em_, ExchangeOrder& eo_, AllocationEntries& all_, common::LightSingleLinkedListRoot<Operation>& result_, bool unpinAll_);

template <typename ExchangeMgr, typename ClientOrder, typename AllocationEntries, typename Operation, typename Predicate = DefaultPredicate>
inline void computeDeltaForCO(const ExchangeMgr& em_, ClientOrder& co_, AllocationEntries& all_, common::LightSingleLinkedListRoot<Operation>& result_, bool unpinAll_ = false, const Predicate& predicate_ = Predicate());

template <typename ExchangeOrder> ALWAYS_INLINE
bool mustRetainEO(const ExchangeOrder& eo_, bool unpinAll_) 
{
  if (!unpinAll_ && eo_.isPinned()) return true;
  // nothing can be done to a slice in pending cancel or the replace down will effectively close the order.
  return eo_.isPendingCancel() || (eo_.isPendingReplace() && eo_.target().orderQty() <= eo_.cumQty());
}

template <typename ExchangeMgr, typename ExchangeOrder, typename AllocationEntries> ALWAYS_INLINE
bool mustRetainEO(const ExchangeMgr& em_, const ExchangeOrder& eo_, AllocationEntries& all_, bool unpinAll_) 
{
  assert(!eo_.isClosed());

 if (mustRetainEO(eo_, unpinAll_))
    return true;

  if (eo_.currentLeavesQty() > QuantityZero)
  {
    uint8_t exchId = em_.getExchId(eo_);
    assert(em_.isValid(exchId));
    auto exchangeEntries = all_.getExchangeAllocationEntries(exchId);
    while (exchangeEntries.isCurrentValid()) 
    {
      auto& entry = exchangeEntries.current();
      if (entry.price () == eo_.target().price () ) 
      {
        assert(entry.side() == common::Side::Buy || 
               entry.side() == common::Side::Sell || 
               entry.side() == common::Side::SellShort || 
               entry.side() == common::Side::SellShortExempt);
        if (em_.getExchange(exchId).getReplaceability(eo_, entry) == ExchangeMgr::Replaceability::DoNothing)
        {
          exchangeEntries.releaseCurrent();
          return true;
        }
      }
      exchangeEntries.next();
    }
  }
  return false;
}

template <typename ExchangeMgr, typename ExchangeOrder, typename AllocationEntries, typename Operation> ALWAYS_INLINE
inline bool mustUpdateEO(const ExchangeMgr& em_, ExchangeOrder& eo_, AllocationEntries& all_, common::LightSingleLinkedListRoot<Operation>& result_) 
{
  assert(!eo_.isClosed());

  if (eo_.currentLeavesQty() > QuantityZero)
  {
    uint8_t exchId = em_.getExchId(eo_);
    assert(em_.isValid(exchId));
    auto exchangeEntries = all_.getExchangeAllocationEntries(exchId);
    while (exchangeEntries.isCurrentValid()) 
    {
      auto& entry = exchangeEntries.current();
      if (entry.price () == eo_.target().price () ) 
      {
        assert(entry.side() == common::Side::Buy || 
            entry.side() == common::Side::Sell || 
            entry.side() == common::Side::SellShort || 
            entry.side() == common::Side::SellShortExempt);
        if (em_.getExchange(exchId).getReplaceability(eo_, entry) == ExchangeMgr::Replaceability::DoUpdate)
        {
          Operation* op = Operation::updateOrder(eo_, *exchangeEntries.removeCurrent());
          result_.pushFront(op);
          return true;
        }
      }
      exchangeEntries.next();
    }
  }
  return false;
}

template <typename ExchangeMgr, typename ExchangeOrder, typename AllocationEntries, typename Operation> 
void computeDeltaForEO(const ExchangeMgr& em_, ExchangeOrder& eo_, AllocationEntries& all_, common::LightSingleLinkedListRoot<Operation>& result_, bool unpinAll_)
{
  assert(!eo_.isClosed());

  if (mustRetainEO(eo_, unpinAll_))
    return;

  //if we have a slice with negative / 0 leaves, it has been/ will be overfilled, we need to cancel this slice out.
  if (eo_.currentLeavesQty() > QuantityZero)
  {
    uint8_t exchId = em_.getExchId(eo_);
    assert(em_.isValid(exchId));

    auto exchangeEntries = all_.getExchangeAllocationEntries(exchId);
    while (exchangeEntries.isCurrentValid())
    {
      auto& entry = exchangeEntries.current();
      assert(entry.side() == common::Side::Buy || 
             entry.side() == common::Side::Sell || 
             entry.side() == common::Side::SellShort || 
             entry.side() == common::Side::SellShortExempt);
      switch (em_.getExchange(exchId).getReplaceability(eo_, entry))
      {
        case ExchangeMgr::Replaceability::Replaceable:
        {
          Operation* op = Operation::replaceOrder(eo_, *exchangeEntries.removeCurrent());
          result_.pushFront(op);
          return;
        }
        case ExchangeMgr::Replaceability::DoUpdate:
        {
          Operation* op = Operation::updateOrder(eo_, *exchangeEntries.removeCurrent());
          result_.pushFront(op);
          return;
        }
        case ExchangeMgr::Replaceability::DoNothing:
        {
          exchangeEntries.releaseCurrent();
          return;
        }
      }
      exchangeEntries.next();
    }
  }

  //dont need to do anything for iocs.
  if (eo_.target().timeInForce() != common::TimeInForce::ImmediateOrCancel)
  {
    //need to simulate a replace
    Operation* op = Operation::cancelOrder(eo_);
    result_.pushFront(op);
  }
}


template <typename ExchangeMgr, typename ClientOrder, typename AllocationEntries, typename Operation, typename Predicate>
void computeDeltaForAllEO(const ExchangeMgr& em_, ClientOrder& co_, AllocationEntries& all_, common::LightSingleLinkedListRoot<Operation>& result_, bool unpinAll_, const Predicate& predicate_)
{
  auto eo = co_._openChildOrdersRoot.node();
  size_t i = 0;
  uint64_t  bitMap = 0;

  /* Size of bitMap limits mustRetainEO for only the first 64 open orders.
   * The remaining open orders fall into the existing logic,which is, finding
   * cancel/replace in ae and eo list by the order they appear. */

  //regular orders 
  while (eo && i < CHAR_BIT*sizeof(bitMap))
  {
    if (predicate_(*eo))
    {
      if (mustRetainEO(em_, *eo, all_, unpinAll_))
      { 
        bitMap |= 1<<i;
      }
      else if (mustUpdateEO(em_, *eo, all_, result_))
      {
        bitMap |= 1<<i;
      }
      ++i;
    }
    eo = eo->next();
  }

  eo = co_._openChildOrdersRoot.node();
  i = 0;

  while (eo)
  {
    if (!predicate_(*eo))
    {
      eo = eo->next();
      continue;
    }

    if (!(bitMap & 1<<i))   // keep
    {
      computeDeltaForEO(em_, *eo, all_, result_, unpinAll_);
    }
    ++i;
    eo = eo->next();
  }
  
  //conditional orders
  eo = co_._openConditionalChildOrdersRoot.node();
  i = 0;
  bitMap = 0;
  
  while (eo && i < CHAR_BIT*sizeof(bitMap))
  {
    if (mustRetainEO(em_, *eo, all_, unpinAll_))
    {
      bitMap |= 1<<i;
    }
    eo = eo->next();
    ++i;
  }
  
  eo = co_._openConditionalChildOrdersRoot.node();
  i = 0;

  while (eo)
  {
    if (!(bitMap & 1<<i))   // keep
    {
      computeDeltaForEO(em_, *eo, all_, result_, unpinAll_);
    }
    ++i;
    eo = eo->next();
  }
}


template <typename ExchangeMgr, typename ClientOrder, typename AllocationEntries, typename Operation, typename Predicate> ALWAYS_INLINE
void computeDeltaForCO(const ExchangeMgr& em_, ClientOrder& co_, AllocationEntries& all_, common::LightSingleLinkedListRoot<Operation>& result_, bool unpinAll_, const Predicate& predicate_)
{
  common::LightSingleLinkedListRoot<Operation> rootNonIOC;

  computeDeltaForAllEO(em_, co_, all_, rootNonIOC, unpinAll_, predicate_);

  Operation* lastOpIOC = NULL;
  //New Slice
  for (uint8_t exchId = 0; exchId < em_.NumExch(); ++exchId)
  {
    auto exchangeEntries = all_.getExchangeAllocationEntries(exchId);
    while (exchangeEntries.isCurrentValid())
    {
      auto& entry = exchangeEntries.current();

      Operation* op = Operation::createNewOrder(co_, entry);
      //FIXME: Add flag on AllocationEntry for the AllocationModel to tell the DeltaEngine that this AE should be allocated from pocket(push_front)
      //For now, use IOC since the only thing that cares about this is pooltake when not marketable.
      if (entry.timeInForce() == common::TimeInForce::ImmediateOrCancel)
      {
        if (!lastOpIOC) 
          lastOpIOC = op;
        result_.pushFront(op);
      }
      else
      {
        rootNonIOC.pushFront(op);
      }
      exchangeEntries.next();
    }
    all_.clearExchangeAllocationEntries(exchId);
  }

  //Join ioc list first, then non-ioc
  if (rootNonIOC.node())
  {
    if (lastOpIOC)
    {
      assert(lastOpIOC->next() == NULL);
      lastOpIOC->pushBack(rootNonIOC.node());
    }
    else
    {
      result_.reset(rootNonIOC.node());
    }
  }
}

}}}

#endif // vx_om_DeltaEngineImpl_H

Attention:  DropMessage.H
#pragma once

#include <ets/vx/common/ReturnCode.H>

namespace ets { 
  
namespace fix { namespace bin {
class Message;
}}

namespace vx { namespace om {

void dropMessageImpl(vx::common::ReturnCode rc_, const ets::fix::bin::Message& msg_);

void dropMessage(vx::common::ReturnCode rc_, const ets::fix::bin::Message& msg_);

using DropMessageFunction = std::function<void(vx::common::ReturnCode, const ets::fix::bin::Message&)>;

void setDropMessageOverride(const DropMessageFunction&);

}}}

Attention:  ErrorCode.H
#pragma once
#ifndef ets_vx_om_ErrorCode_H
#define ets_vx_om_ErrorCode_H

///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2013 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#include "../common/ReturnCode.H"

namespace ets { namespace vx { namespace om {

// Example to extend application specific ErrorCode:
//
// struct AppErrorCode : common::ErrorCodeT<AppErrorCode, om::ErrorCode>
// {
//   Enum enum 
//   {
//     NEW_CODE = om::ErrorCode::LAST;
//     ...
//   }
//
//  protected: 
//   friend class common::ErrorCodeT<AppErrorCode, om::ErrorCode>;
//   static void registerCodes()
//   {
//     addCode(NEW_CODE, "NEW_CODE", "description");
//   }
// };


struct ErrorCode : common::ErrorCodeT<ErrorCode, common::ReturnCode>
{
    enum Enum
    {
        // basic alloc
        EVAL_DISABLED = common::ReturnCode::LAST,
        NOTHING_ALLOCATED,
        TRADING_SUSPENDED,
        ALLOCATION_FAILURE,
        DIRECTED_ISO_FAILURE,
        ALL_DESTINATIONS_REJECTED,

        // basic allocation, consider moving this to vxbiz ?
        REPLACE_ON_IOC_NOT_ALLOWED,
        SHORT_SELL_RESTRICTION_IS_ON,
        TRADE_HALTED,
        PRIMARY_NOT_OPEN,
        RESTRICTED_SYMBOL,
        NO_VALID_QUOTE,
        BAD_PRICE_BREACH,
        BAD_PRICE_BREACH_REJECT,
        MAX_QTY_BREACH,
        ORDER_NOT_MARKETABLE,
        NO_AVAILABLE_DESTINATIONS,
        TOO_MANY_NOFILL_ALLOCS,
        ALREADY_PUNTED_TO_BACKUP,
        CANCEL_ON_BUST,

        // TODO: move to vx only 
        // need namespace change to differentiate vx::ErrorCode (base)
        // and ets::vx::ErrorCode (derived)
        POOLTAKE_ALLOCATED,
        POOLTAKE_DISABLED,
        POOLTAKE_NOT_ALLOCATED,
        POOL_NOT_REACHABLE,
        PRIMARY_NOT_REACHABLE,

        SESSION_REJECT,
        KEEP_CURRENT_ALLOCATION,
        KEEP_CURRENT_LEVEL_ALLOCATION,
        BAD_PRICE_MISSING_INPUT,
        UNKNOWN_TRADESTATUS,

        INVALID_PIPE_DESTINATION,
        PIPE_DESTINATION_UNAVAILABLE,

        MARKET_CLOSED,
        OPENING_AUCTION_DISABLED,
        CXL_OPENING_AUCTION_RESIDUAL,
        TOO_LATE_FOR_AUCTION,
        CXL_ON_TRADE_HALT,
        VGLM_LIMIT_BREACH,
        FEATURE_NOT_SUPPORTED,
        
        ADMIN_CXL_CLOSE_AUCTION_ORDERS,
        PAST_CUTOFF,
        AUCTION_DESTINATION_NOT_REACHABLE,
        AUCTION_ORDER_EXPIRED,
        UNABLE_TO_REPLACE,
        ALLOCATOR_COMPUTED_DELTA,
        LAST // ALWAYS KEEP THIS AS THE LAST ITEM
    };

protected:
    friend class common::ErrorCodeT<ErrorCode, common::ReturnCode>;
    static void registerCodes();

private:
    ErrorCode() {} // users should use ReturnCode for simplicity
};

}}}

namespace ets { namespace vx { namespace common {

template <>
struct IsReturnCodeEnum<ets::vx::om::ErrorCode::Enum> : public std::true_type
{
};

}}}

#endif
Attention:  EvalConditionRepository.H
#ifndef vx_om_EvalConditionRepository_H
#define vx_om_EvalConditionRepository_H

///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#include "EvalTriggers.H"

namespace ets { namespace vx { namespace om {


bool checkPercentOfLeavesInPocket (const ClientOrder& co_, int64_t maxPocketPct, const Quantity& pocketQty);


class EvalConditionRepository
{
public:
    typedef bool (* CheckEvalConditionFunction)(const ClientOrder&, const EvalCondition& cond_);

public:
    EvalConditionRepository();

public:
    inline bool checkCondition(const ClientOrder& co_, const EvalCondition& cond_) const;

    void install(CheckEvalConditionFunction func_, const EvalCondition::Type type_);
    
private:
    CheckEvalConditionFunction  _evalConditionFunctions[EvalCondition::Last];
};

inline bool EvalConditionRepository::checkCondition(const ClientOrder& co_, const EvalCondition& cond_) const
{
    return _evalConditionFunctions[cond_._type](co_, cond_);
}

}}}

#endif // vx_om_EvalConditionRepository_H
Attention:  EvalTriggers.H
#pragma once

#include <ets/vx/common/LightList.H>
#include <ets/vx/common/BitmaskEnum.H>
#include <ets/vx/common/MemoryAllocator.H>

namespace ets { namespace vx { namespace om {

DECLARE_FIXEDSIZE_MEMORY_ALLOCATOR(EvalCondition)

using EvalTriggerEvents = uint64_t;
using EvalTriggerMask = uint64_t;

struct EvalTriggerEvent
{
    enum Type : uint64_t {
      None = 0,
      BITMASK_ENUM(
        (SliceRejected)
        (SlicePartiallyFilled)
        (SliceFullyFilled) 
        (SliceCanceled)
        (SliceCancelRejected)
        (SliceReplaced)
        (SliceReplaceRejected)
        (SliceUnsolCxled) //includes IOC outs
        (SliceTradeCanceled) 
        (SliceTradeCorrected) 
        (NewOrderReceived)
        (ReplaceRequestReceived)
        (ReplaceRequestAcked)
        (ExchangeExclTimer)
        (AdminForceEval)
        (EvalErrorReview)
        (PopReceived)
        (TradeHaltUpdate)
        (TradeHaltTypeUpdate)
        (ShortSellRestrictionUpdate)
        (ShortSellExemptUpdate)
        (RestrictionUpdate)
        (RestrictionTypeUpdate)
        (ConditionalSliceRejected)
        (ConditionalSliceReplaceRejected)
        (ConditionalSliceUnsolCxled)
        (ConditionalSliceFirmedUp)
        (ClosedOrderReopened)
        (ReplaceRejected)
        (EffectiveTimeExpired)
        (ClipPartiallyFilled)
        (ClipFullyFilled)
        (LegSlicePartiallyFilled)
        (LegSliceFullyFilled)
        (LegSliceOverFilled) 
        (MarketDataTriggered) 
        (UserDefinedEvent)
      ),
      ForceEval = 0xffffffffffffffff 
    };
};

struct SliceEvalTriggerEvent
{
  // other events should be triggered on the CO
  // no Cancel Request Ack / Replace Request Ack 
  // because the requests are initiated by DeltaEngine
  // Allocation Model should only know about fills/unsolcxls
  enum Type : uint64_t {
    BITMASK_ENUM(
      (PartiallyFilled)
      (FullyFilled)
      (UnsolCxled) //includes IOC outs
      (Rejected)
      (ReplaceRejected)
    )
  };
};

struct EvalTriggerReason
{
  inline static bool isNewlyInvoked(EvalTriggerEvents events_)
  {
    return EvalTriggerEvent::NewOrderReceived & events_;
  }

  inline static bool isClientReplaceRequested(EvalTriggerEvents events_)
  {
    return EvalTriggerEvent::ReplaceRequestReceived & events_ ;
  }

  inline static bool isClientReplaceCommitted(EvalTriggerEvents events_)
  {
    return EvalTriggerEvent::ReplaceRequestAcked & events_ ;
  }
};

struct EvalCondition : public common::LightSingleLinkedListNode<EvalCondition>, public boost::noncopyable
{
    enum  Type {
        PercentOfLeavesInPocket = 0,
        MaxEvalWaitTime,
        HasPocketQty,
        Last // always keep this the last element.
    };

    EvalCondition(Type type_, int64_t data_)
    : 
        _type(type_),
        _data(data_)
    {
    }

    Type _type;
    int64_t _data;
};

}}}

Attention:  EventHooks.H
#ifndef vx_om_EventHooks_H
#define vx_om_EventHooks_H

///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2014 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#include <ets/vx/om/Fwd.H>
#include <set>

namespace ets { namespace vx { namespace om {

template<class H, class E>
class EventHooks
{
public:
    typedef H Hook;
    typedef E Event;

    bool addEventHook(typename Event::Enum event_, Hook hook_, void* userData_);
    void removeEventHook(typename Event::Enum event_, Hook hook_, void *userData_);
    template<class OrderT>
    void notifyEventObservers(typename Event::Enum event_, OrderT& eo_) const;
private:
    struct Data
    {
        Data(Hook hook_, void* userData_)
            : _hook(hook_),
              _userData(userData_)
        {}

        struct Less : public std::binary_function<Data, Data, bool>
        {
            bool operator()(const Data &x, const Data &y) const
            {
                if (x._hook < y._hook) return true;
                if (x._hook > y._hook) return false;
                return x._userData < y._userData;
            }
        };

        Hook _hook;
        void* _userData;
    };

    typedef std::set<Data, typename Data::Less> Hooks;
    Hooks _hooks[Event::Last];
};

template<class H, class E, template<class, class> class EH = EventHooks>
class EventHooksMgr
{
public:
    typedef EH<H, E> EventHooksT;
    typedef typename EventHooksT::Event Event;
    typedef typename EventHooksT::Hook Hook;

    bool addPreEventHook(typename Event::Enum event_, Hook hook_, void* userData_);
    bool addPostEventHook(typename Event::Enum event_, Hook hook_, void* userData_);

    void removePreEventHook(typename Event::Enum event_, Hook hook_, void *userData_);
    void removePostEventHook(typename Event::Enum event_, Hook hook_, void *userData_);

protected:
    template<class OrderT>
    void notifyPreEventObservers(typename Event::Enum event_, OrderT& order_) const;
    template<class OrderT>
    void notifyPostEventObservers(typename Event::Enum event_, OrderT& order_) const;
private:
    EventHooksT _preEventHooks;
    EventHooksT _postEventHooks;
};

}}} // namespace ets::vx::om

namespace ets { namespace vx { namespace om {

template<class H, class E>
bool EventHooks<H, E>::addEventHook(typename Event::Enum event_, Hook hook_, void* userData_)
{
    return _hooks[event_].insert(Data(hook_, userData_)).second;
}

template<class H, class E>
void EventHooks<H, E>::removeEventHook(typename Event::Enum event_, Hook hook_, void *userData_)
{
    Hooks &hooks = _hooks[event_];
    hooks.erase(Data(hook_, userData_));
}

template<class H, class E>
template<class OrderT>
void EventHooks<H, E>::notifyEventObservers(typename Event::Enum event_, OrderT& order_) const
{
    const Hooks &hooks = _hooks[event_];
    for (auto& data : hooks)
    {
      data._hook(order_, data._userData);
    }
}

template<class H, class E, template<class, class> class EH>
template<class OrderT>
void EventHooksMgr<H, E, EH>::notifyPreEventObservers(typename Event::Enum event_, OrderT& order_) const
{
    _preEventHooks.notifyEventObservers(event_, order_);
}

template<class H, class E, template<class, class> class EH>
template<class OrderT>
void EventHooksMgr<H, E, EH>::notifyPostEventObservers(typename Event::Enum event_, OrderT& order_) const
{
    _postEventHooks.notifyEventObservers(event_, order_);
}

template<class H, class E, template<class, class> class EH>
bool EventHooksMgr<H, E, EH>::addPreEventHook(typename Event::Enum event_, Hook hook_, void* userData_)
{
    return _preEventHooks.addEventHook(event_, hook_, userData_);
}

template<class H, class E, template<class, class> class EH>
bool EventHooksMgr<H, E, EH>::addPostEventHook(typename Event::Enum event_, Hook hook_, void* userData_)
{
    return _postEventHooks.addEventHook(event_, hook_, userData_);
}

template<class H, class E, template<class, class> class EH>
void EventHooksMgr<H, E, EH>::removePreEventHook(typename Event::Enum event_, Hook hook_, void* userData_)
{
    _preEventHooks.removeEventHook(event_, hook_, userData_);
}

template<class H, class E, template<class, class> class EH>
void EventHooksMgr<H, E, EH>::removePostEventHook(typename Event::Enum event_, Hook hook_, void* userData_)
{
    _postEventHooks.removeEventHook(event_, hook_, userData_);
}

}}} // namespace ets::vx::om

#endif /* EVENTHOOKS_H_ */
Attention:  ExchangeOrder.H
#ifndef ets_vx_om_ExchangeOrder_H
#define ets_vx_om_ExchangeOrder_H

///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////
#include "ExchangeSliceOperationStatus.H"
#include "ExchangeOrderFSM.H"
#include "EvalTriggers.H"
#include <ets/vx/em/ExchangeDefs.H>
#include "RemoteQueryProxy.H"
#include <ets/vx/em/Util.H>
#include <ets/vx/common/Enums.H>
#include <ets/vx/common/ThreadContext.H>
#include <ets/vx/common/FixMsg.H>
#include <ets/vx/common/LightString.H>
#include <ets/vx/msg/ExchangeReport.H>
#include <ets/vx/msg/ExchangeRequest.H>
#include <ets/vx/om/AlertTypes.H>
#include <ets/vx/timer/TimerManager.H>
#include <ets/vxperf/xprobes/xprobes.H>
#include <ets/vx/common/MSUuidPool.H>
#include <ets/vx/em/AllocationEntry.H>
#include <MSTools/MSUuid.H>
#include <OR/etsRouter/UMPDestination.H>
#include <OR/fixMessage/fixMessage/ORFixTime.H>
#include <ets/vx/em/UMPBFixSender.H>

namespace ets { namespace oom {
class OrderData;
}}

namespace ets { namespace router { 
template<class T> class UMPDestination;
}}

namespace ets { namespace vx { namespace om {

class ExchangeOrder : public common::LightDoubleLinkedListNode<ExchangeOrder>, public boost::noncopyable
{
  friend class ExchangeOrderFSM;
  friend class ExchangeOrderManager;
  friend class ExchangeSliceOperation;
  friend class QueCancelTimer;
  friend class PendingRequestTimer;
  friend class CancelRetryTimer;

public:
  typedef exch::AllocationEntry OrderMessage;
  enum { UUID_SIZE = MSUuid::BASE64_LEGACY_SIZE };

  ExchangeOrder();
  ~ExchangeOrder();

  void init(ClientOrder& co_, exch::AllocationEntry* ae_);
  void setTarget(exch::AllocationEntry* ae_)
  {
   assert(_target==_current);
    assert(ae_->ordType().isValid());
    assert(!ae_->clOrdID().empty());
    assert(ae_->orderQty()!=QuantityZero);
    assert(ae_->side().isValid());
    assert(ae_->routingInfo().exchId!=exch::INVALID_ID);
    _target = ae_;
  }

  // definition not provided in header to prevent people from getting nullptr
  template<class EncodingSenderType>
  EncodingSenderType* getEncodingSender(std::string& errInfo);

  template<class SenderType>
  SenderType* get(common::OrderType orderType = common::OrderType::NEW);

  void closeOrder();

  Quantity addFill(Quantity fillQty_, Amount fillValue_); // return a possibly rounded Quantity
  void removeFill(Quantity fillQty_, Amount fillValue_);

  const exch::AllocationEntry& current() const { return *_current; }
  const exch::AllocationEntry& target() const { return *_target; }

  Quantity currentLeavesQty() const { return  current().orderQty() - _cumQty; } //CAUTION: need to check isClosed()
  Quantity targetLeavesQty() const { return target().orderQty() - _cumQty; } //CAUTION: need to check isClosed()

  ClientOrder& parent() const { return *_co; }
  const exch::RoutingInfo& routingInfo() const { return current().routingInfo(); }
  const MSUuid& orderUUId() const { return _orderUUIDPair.uuid(); }
  const common::LightStringRef orderUUIDStr() const { return _orderUUIDPair.l_str(); }

  ExchangeOrderState::Enum placementState() const { return _placementState; }

  bool shouldEvalOn(SliceEvalTriggerEvent::Type evt_) const { return current().triggerEvalOnBitMask() & evt_; }

  bool isClosed() const { return _isClosed; }
  bool isPendingReplace() const { return _placementState == ExchangeOrderState::PendingReplace; }
  bool isPendingNew() const { return _placementState == ExchangeOrderState::PendingNew; }
  bool isPendingCancel() const { return _placementState == ExchangeOrderState::PendingCancel || _hasQueuedPendingCxl; }
  bool isPending() const
  {
    return(_placementState == ExchangeOrderState::PendingNew
        || _placementState == ExchangeOrderState::PendingReplace
        || _placementState == ExchangeOrderState::PendingCancel); //?? ||_hasQueuedPendingCxl?
  }

  bool isPinned() const { return target().isPinned(); }
  void unpin() { _target->setPinned(false); }

  // This queues a cancel with a delay if exchange
  // can not handle multiple-pending state
  ExchangeSliceOperationStatus::Enum cancelWithQue();
  void releaseCxlInQue();

  void setPendingRequestTimer();
 void setCancelRetryTimer();

  Quantity cumQty() const { return _cumQty; }
  Amount cumValue() const { return _cumValue; }
  common::LightStringRef creationTimeStr() const { return common::LightStringRef{_creationTimeStr, _creationTimeStrLen}; }
  uint64_t creationTime() const { return _creationTime; }

  common::Side::Enum side() const { return current().side(); }

  void setLastExchangeMessage(ets::vx::msg::ExchangeReportPtr msgPtr_) { _lastExchMsgPtr = msgPtr_; setOrderID(_lastExchMsgPtr); }
  ets::vx::msg::ExchangeReportPtr lastExchangeMessage() const { assert(_lastExchMsgPtr.isValid()); return _lastExchMsgPtr; }

  common::ReturnCode recoverFrom( const ets::oom::OrderData& orderData_, 
                                  const fix::bin::Message& currentMsg_, 
                                  const StripeContext& sc_,
                                  const Quantity cumQty_, 
                                  const Amount cumAmount_
                                 );

  virtual void enrichRecoveredExchangeOrder(const ets::oom::OrderData& orderData_,
      const fix::bin::Message& currentMsg_, const StripeContext& sc_, Quantity& cumQuantity )
  {
    //nothing by default
  }

  common::OrdStatus::Enum ordStatus() const;
  bool isRoutedAsPipe() const;
  const std::string& symbol() const { return _tag_ORFixTag_Symbol; }
  void setSymbol(const std::string& val_) { _tag_ORFixTag_Symbol=val_; }
  void setSymbol(std::string&& val_) { _tag_ORFixTag_Symbol=std::move(val_); }
  void setSymbol(const common::LightStringRef val_) { _tag_ORFixTag_Symbol.assign(val_._buf, val_._sz); }
  const std::string& symbolSfx() const { return _tag_ORFixTag_SymbolSfx; }
  void setSymbolSfx(const std::string& val_) { _tag_ORFixTag_SymbolSfx=val_; }
  const std::string& orderID() const { return _tag_ORFixTag_OrderID; }
  template <typename AlertT>
  void raiseAlert(const std::string& reason_);
  template<typename Alert>
  void clearAlert();

  vx::om::RemoteQueryProxy::QueryTaskQueue*  pendingMessageQueue() const { return _pendingMessageQueue; }
  vx::om::RemoteQueryProxy::QueryTaskQueue*& pendingMessageQueue()       { return _pendingMessageQueue; }

  uint32_t alertFlags() const { return _alerts; }

  void checkParentRecoveryState();
  
  /**
   * Initialized when a NewOrder is sent.
   * All secondary requests will be send via the same destination.
   */
  ets::router::UMPDestination<fix::bin::MessagePtr>* _cached_destination = nullptr; // not owned by this class
  uint32_t _cached_lnf_handler_value = 0;

  /**
   * Checks the status of the underlying routing strategy for the exchange where this order would be sent.
   * If that strategy says that a valid destination(order router) exists, then this API returns TRUE.
   * Note: A race condition needs to be taken into account. (ie. sendNewOrder or sendSecondaryRequest can still fail even this returns TRUE)
   * @return TRUE if calls to sendNewOrder or sendSecondaryRequest would succeed. (see Note above)
   */
  bool wouldSendRequestSucceed();

  /**
   * Sends a NewOrder BFIX. This method initialize the _destination
   * which is then used by 'sendSecondaryRequest(...)'.
   * @param message
   * @return        'true' on success
   */
  bool sendNewOrder(fix::bin::Message& message);

  /**
   * Sends BFIX cancel using the "_cached_destination" computed by "sendNewOrder".
   * @param message
   * @return        'true' on success
   */
  bool sendCancel(fix::bin::Message& message);

  bool sendReplace(fix::bin::Message& message);

  bool isConditional() const {return _isConditional;}
  bool isFirmedUp() const {return _isFirmedUp;}
  void setIsFirmedUp(bool isFirmedUp_)  { _isFirmedUp = isFirmedUp_;}
  bool isFirmUpExchangeOrder() const {return _isFirmUpExchangeOrder;}
  uint16_t orderVId() const {return _nextMsgId;}

private:
  // this method will check if the order will be fully filled by the latest execution. 
  // since the downsteam may not stamp tag 150 correctly, we can't rely on it.
  bool willFullyFill(const ets::vx::msg::ExchangeReportPtr& fill_) const; 

  void setOrderID(ets::vx::msg::ExchangeReportPtr msgPtr_);

  common::ReturnCode resolveState(const ets::oom::OrderData& orderData_, bool hasUnprocessedFills_ = false);
  void pendingRequestCB();

  ets::vx::common::MSUuidPair _orderUUIDPair;

  ClientOrder* _co;
  std::string _tag_ORFixTag_OrderID; //37
  std::string _tag_ORFixTag_Symbol; //55
  std::string _tag_ORFixTag_SymbolSfx; //65
  char _creationTimeStr[ORFixTime::BufferSize];
  size_t _creationTimeStrLen;
  uint64_t _creationTime;

  exch::AllocationEntry* _current;
  exch::AllocationEntry* _target;
  ets::vx::msg::ExchangeReportPtr _lastExchMsgPtr;

  Quantity _cumQty;
  Amount _cumValue;
  ExchangeOrderState::Enum _placementState;

  uint16_t _nextMsgId;

  bool _isClosed;
  bool _hasQueuedPendingCxl;//??make it part of _placementState

  timer::TimerBase* _queCxlTimer;
  timer::TimerBase* _pendingRequestTimer;
  timer::TimerBase* _cancelRetryTimer;
  uint32_t _cancelRetryCount;
  uint32_t _alerts;

  vx::om::RemoteQueryProxy::QueryTaskQueue* _pendingMessageQueue;

  // this flag will be turn on when processing an execution which is in the _unProcessedExecIds
  bool _shouldCheckParentRecoveryState = false;

protected:
  // TODO implement DummyExchangeOrderFactory and remove this
  bool _useMemPool = true;
  bool _isConditional = false;
  bool _isFirmedUp = false;
  bool _isFirmUpExchangeOrder = false;

};

template<>
exch::UMPBFixSender<>* ExchangeOrder::getEncodingSender<exch::UMPBFixSender<>>(std::string& errInfo);

fix::bin::Message& currentMsgSlow(vx::msg::ExchangeRequestPtr);

template <typename AlertT>
void ExchangeOrder::raiseAlert(const std::string& reason_)
{
  if (!(_alerts & AlertT::mask) && alert::raiseOrderAlert<AlertT>(*this, reason_))
  {
    _alerts |= AlertT::mask;
  }
}

template<typename AlertT>
void ExchangeOrder::clearAlert()
{
  if( _alerts & AlertT::mask )
  {
    _alerts &= ~AlertT::mask;
    alert::clearOrderAlert<AlertT>(*this);
  }
}

inline bool ExchangeOrder::willFullyFill(const ets::vx::msg::ExchangeReportPtr& fill_) const
{
  Quantity orderQty = isPendingReplace() && fill_->ClOrdID() == target().clOrdID() ? target().orderQty() : current().orderQty();
  return cumQty() + fill_->LastShares >= orderQty;
}

inline void ExchangeOrder::setOrderID(ets::vx::msg::ExchangeReportPtr msgPtr_)
{
  common::LightStringRef orderId;
  if (!msgPtr_->getOrderID(orderId))
    return;
  _tag_ORFixTag_OrderID.assign(std::move(orderId.asString()));
}

}}}

#endif // vx_om_ExchangeOrder_H
Attention:  ExchangeOrderFSM.H
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef ets_vx_om_ExchangeOrderFSM_H
#define ets_vx_om_ExchangeOrderFSM_H

#include <ets/vx/common/CompletionList.H>
#include <ets/vx/common/ReturnCode.H>
#include <ets/vx/common/MemoryAllocator.H>

#include <boost/static_assert.hpp>

#ifndef VX_ENUM_CASE_EOFSM
#define VX_ENUM_CASE_EOFSM(x) case x: return #x
#define VX_ENUM_DEFAULT_EOFSM(x) default: return #x
#endif

namespace ets { namespace vx { namespace om {

DECLARE_FIXEDSIZE_MEMORY_ALLOCATOR(CancelExchangeOrderCompletion)

class ExchangeEventContext;
class ExchangeOrder;

struct ExchangeOrderEvent
{
  enum Enum
  {
    ExchangeOrderNew=0, // 0
    ExchangeOrderReplace, // 1
    ExchangeOrderCancel, // 2
    ExchangeOrderForceCancel, // 3
    ExchangeOrderAccepted, // 4
    ExchangeOrderReplaced, // 5
    ExchangeOrderCanceled, // 6
    ExchangeOrderRejected, // 7
    ExchangeOrderDoneForDay, // 8
    ExchangeOrderPartiallyFilled, // 9
    ExchangeOrderFilled, // 10
    ExchangeOrderReplaceRejected, // 11
    ExchangeOrderCxlRejected, // 12
    ExchangeTradeCancel, // 13
    ExchangeTradeCorrect, // 14
    ExchangeOrderExpired, // 15

    ConditionalOrderAcked, //16
    ConditionalOrderNew, //17
    ConditionalOrderReplace, //18
    ConditionalOrderCancel, //19
    ConditionalOrderFirmedUp, //20
    ConditionalOrderRejected, //21
    ConditionalOrderReplaceRejected, //22
    ConditionalOrderCxlRejected, //23
    ConditionalOrderCancelled, //24

    Last // 25 Always have this as the last element
  };
  static const char* asString(Enum event_)
  {
    BOOST_STATIC_ASSERT(Last == 25);
    switch(event_)
    {
      VX_ENUM_CASE_EOFSM(ExchangeOrderNew);
      VX_ENUM_CASE_EOFSM(ExchangeOrderReplace);
      VX_ENUM_CASE_EOFSM(ExchangeOrderCancel);
      VX_ENUM_CASE_EOFSM(ExchangeOrderForceCancel);
      VX_ENUM_CASE_EOFSM(ExchangeOrderAccepted);
      VX_ENUM_CASE_EOFSM(ExchangeOrderReplaced);
      VX_ENUM_CASE_EOFSM(ExchangeOrderCanceled);
      VX_ENUM_CASE_EOFSM(ExchangeOrderRejected);
      VX_ENUM_CASE_EOFSM(ExchangeOrderDoneForDay);
      VX_ENUM_CASE_EOFSM(ExchangeOrderPartiallyFilled);
      VX_ENUM_CASE_EOFSM(ExchangeOrderFilled);
      VX_ENUM_CASE_EOFSM(ExchangeOrderReplaceRejected);
      VX_ENUM_CASE_EOFSM(ExchangeOrderCxlRejected);
      VX_ENUM_CASE_EOFSM(ExchangeTradeCancel);
      VX_ENUM_CASE_EOFSM(ExchangeTradeCorrect);
      VX_ENUM_CASE_EOFSM(ExchangeOrderExpired);
             
      VX_ENUM_CASE_EOFSM(ConditionalOrderAcked);
      VX_ENUM_CASE_EOFSM(ConditionalOrderNew);
      VX_ENUM_CASE_EOFSM(ConditionalOrderReplace);
      VX_ENUM_CASE_EOFSM(ConditionalOrderCancel);
      VX_ENUM_CASE_EOFSM(ConditionalOrderFirmedUp);
      VX_ENUM_CASE_EOFSM(ConditionalOrderRejected);
      VX_ENUM_CASE_EOFSM(ConditionalOrderReplaceRejected);
      VX_ENUM_CASE_EOFSM(ConditionalOrderCxlRejected);
      VX_ENUM_CASE_EOFSM(ConditionalOrderCancelled);
      
      VX_ENUM_DEFAULT_EOFSM(Invalid);
    }
  }
};

//Caution: State value is different from Fix tag value
struct ExchangeOrderState
{
  enum Enum
  {
    New = 0, //0
    PartiallyFilled, // 1
    Filled, // 2
    Cancelled, // 3
    Rejected, // 4
    PendingNew, // 5
    PendingCancel, // 6
    PendingReplace, // 7
    DoneForDay, //8

    Last // 9
  };
  static const char* asString(Enum state_)
  {
    BOOST_STATIC_ASSERT(Last == 9);
    switch(state_)
    {
      VX_ENUM_CASE_EOFSM(New);
      VX_ENUM_CASE_EOFSM(PartiallyFilled);
      VX_ENUM_CASE_EOFSM(Filled);
      VX_ENUM_CASE_EOFSM(Cancelled);
      VX_ENUM_CASE_EOFSM(Rejected);
      VX_ENUM_CASE_EOFSM(PendingNew);
      VX_ENUM_CASE_EOFSM(PendingCancel);
      VX_ENUM_CASE_EOFSM(PendingReplace);
      VX_ENUM_CASE_EOFSM(DoneForDay);
      VX_ENUM_DEFAULT_EOFSM(Invalid);
    }
  }
};

struct ExchangeEventArgs
{
  const ExchangeOrderEvent::Enum _event;
  ExchangeOrder& _eo;
};

class ExchangeOrderFSM : public boost::noncopyable
{
    typedef void (ExchangeOrderFSM::*EventHandlerFunction)(const ExchangeEventArgs&, ExchangeEventContext&);

public:
    ExchangeOrderFSM();

    common::ReturnCode dispatch(ExchangeEventArgs& eventArgs_);

private:
    void handle_unexpected_message(const ExchangeEventArgs& event_, ExchangeEventContext& context_);

    void default_exchange_dfd_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void default_trade_correct(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void default_trade_cancel(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void default_exchange_reject_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void ignore_exchange_response(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void ignore_retransmit_message(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void ignore_ack(const ExchangeEventArgs& event_, ExchangeEventContext& context_);

    void pending_new_state_exchange_order_ack_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void default_exchange_partial_fill_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void default_exchange_full_fill_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);

    void pending_replace_state_exchange_dfd_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void pending_replace_state_exchange_partial_fill_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void pending_replace_state_exchange_full_fill_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void pending_replace_state_replace_ack_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void pending_replace_state_replace_rejected(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void pending_replace_state_cancel_ack_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void pending_replace_state_cancel_rejected(const ExchangeEventArgs& event_, ExchangeEventContext& context_);

    void pending_cancel_state_exchange_order_ack_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void pending_cancel_state_exchange_dfd_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void pending_cancel_state_exchange_partial_fill_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void pending_cancel_state_exchange_full_fill_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void pending_cancel_state_cancel_ack_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void pending_cancel_state_cancel_rejected(const ExchangeEventArgs& event_, ExchangeEventContext& context_);

    void partially_filled_state_exchange_bust_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);

    void closed_state_ignore_exchange_response(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void closed_state_exchange_partial_fill_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void closed_state_exchange_full_fill_recvd(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void closed_state_trade_correct(const ExchangeEventArgs& event_, ExchangeEventContext& context_);
    void closed_state_trade_cancel(const ExchangeEventArgs& event_, ExchangeEventContext& context_);

    void handle_replace_ack(ExchangeOrder& eo_);
  
    void initStateMachine();

private:
    EventHandlerFunction _eventHandlers[ExchangeOrderState::Last][ExchangeOrderEvent::Last];
    common::CompletionList _postDispatchCompletionList;
};

}}}

#endif

Attention:  ExchangeOrderFactoryImpl.H
#pragma once

#include <cassert>
#include <memory>
#include <ets/vx/common/ObjectPool.H>
#include "ExchangeOrder.H"

namespace ets { namespace vx { namespace om {

template <typename ExchangeOrderType> using ExchangeOrderObjectPool = common::ObjectPool<ExchangeOrderType>;

template <typename ExchangeOrderType>
class ExchangeOrderFactoryImpl 
{
public:
  ExchangeOrderFactoryImpl(const std::shared_ptr<ExchangeOrderObjectPool<ExchangeOrderType>>& pool_ = std::make_shared<ExchangeOrderObjectPool<ExchangeOrderType>>())
    :_pool(pool_)
  {
  }

  bool initialize(size_t initSize_, size_t increaseSize_)
  {
   if (!_pool) 
    {
      ORlogError << "ExchangeOrderObjectPool is not instantiated" << ORLog::send;
      return false;
    }
    if (!_pool->initialize(initSize_, increaseSize_))
    {
      ORlogError << "ExchangeOrderObjectPool failed to initialize" << ORLog::send;
      return false;
    }
    return true;
  }

  ExchangeOrderFactory get()
  {
    assert(_pool);
    return ExchangeOrderFactory(createExchangeOrder, releaseExchangeOrder, _pool.get());
  }

  ExchangeOrderObjectPool<ExchangeOrderType>& pool() { assert(_pool); return *_pool; }
  const ExchangeOrderObjectPool<ExchangeOrderType>& pool() const { assert(_pool); return *_pool; }

private:
  VX_HOT_FLATTEN
  static ExchangeOrder* createExchangeOrder(ClientOrder* co_, exch::AllocationEntry* ae_, void* pool_)
  {
    assert(co_);
    assert(ae_);
    assert(pool_);
    ExchangeOrderObjectPool<ExchangeOrderType>& pool = *static_cast<ExchangeOrderObjectPool<ExchangeOrderType>*>(pool_);
    ExchangeOrderType* eo = pool.get();
    eo->init(*co_, ae_);
    return eo;
  }

  VX_HOT_FLATTEN
  static void releaseExchangeOrder(ExchangeOrder* eo_, void* pool_)
  {
    ExchangeOrderObjectPool<ExchangeOrderType>& pool = *static_cast<ExchangeOrderObjectPool<ExchangeOrderType>*>(pool_);
    pool.destroy(static_cast<ExchangeOrderType*>(eo_));
  }

private:
  std::shared_ptr<ExchangeOrderObjectPool<ExchangeOrderType>> _pool;
};

}}}

Attention:  ExchangeOrderFsmTypes.H
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright. All rights reserved. This material contain
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef ets_vx_om_ExchangeOrderFsmTypes_H
#define ets_vx_om_ExchangeOrderFsmTypes_H

#include <ets/vx/em/AllocationEntry.H>
#include <ets/vx/om/Fwd.H>
#include <ets/vx/common/ReturnCode.H>
#include <ets/vx/common/FixMsg.H>
#include <ets/vx/msg/ExchangeReport.H>
#include "ExchangeOrderFSM.H"
#include "ExchangeOrder.H"

namespace ets { namespace vx { namespace om {

static ExchangeOrderEvent::Enum eventType(const ets::vx::msg::ExchangeReport& msg_)
{
  const common::MsgType::Enum msgType = msg_.MsgType;
  switch(msgType)
  {    
    case common::MsgType::ConditionalReport:
    {
      const common::ExecType::Enum execType=msg_.ExecType;
      switch(execType)
      {
        case common::ExecType::FirmedUp:  return ExchangeOrderEvent::ConditionalOrderFirmedUp;
        case common::ExecType::New:       
        case common::ExecType::Replaced:  return ExchangeOrderEvent::ConditionalOrderAcked; 
        case common::ExecType::Expired:
        case common::ExecType::Cancelled: return ExchangeOrderEvent::ConditionalOrderCancelled;

        case common::ExecType::Rejected:
        {
          common::LightStringRef cxlRejResponseTo;
          if (!msg_.getCxlRejResponseTo(cxlRejResponseTo))
          {
            return ExchangeOrderEvent::ConditionalOrderRejected;
          }
          else if (cxlRejResponseTo.data()[0] == '1')
          {
            return ExchangeOrderEvent::ConditionalOrderCxlRejected;
          }
          else if (cxlRejResponseTo.data()[0] == '2')
          {
            return ExchangeOrderEvent::ConditionalOrderReplaceRejected;
          }
          else
          {
            ORlogError << "Unsupported reject response. CxlRejResponseTo[" << cxlRejResponseTo << "]" << ORLog::send;
          }          
          break;
        }        
        default:
          ORlogError << "Unsupported eventType. MsgType["<< msgType << "] ExecType["<< execType << "]" << ORLog::send;
      }

     break; 
    }

    case common::MsgType::ExecutionReport:
    {
      const common::ExecTransType::Enum  execTransType=msg_.ExecTransType;
      switch(execTransType)
      {
        case common::ExecTransType::New:
        {
          //FIXME: If this doesn't translate to a jump table in assembly,
          // we should switch to using an array index lookup.
          const common::ExecType::Enum execType=msg_.ExecType;
          switch(execType)
          {
          case common::ExecType::New: return ExchangeOrderEvent::ExchangeOrderAccepted;
          case common::ExecType::PartiallyFill: return ExchangeOrderEvent::ExchangeOrderPartiallyFilled;
          case common::ExecType::Fill: return ExchangeOrderEvent::ExchangeOrderFilled;
          case common::ExecType::DoneForDay: return ExchangeOrderEvent::ExchangeOrderDoneForDay;
          case common::ExecType::Cancelled: return ExchangeOrderEvent::ExchangeOrderCanceled;
          case common::ExecType::Replaced: return ExchangeOrderEvent::ExchangeOrderReplaced;
          case common::ExecType::Rejected: return ExchangeOrderEvent::ExchangeOrderRejected;
          case common::ExecType::Expired: return ExchangeOrderEvent::ExchangeOrderExpired;
          case common::ExecType::TradeCancel: return ExchangeOrderEvent::ExchangeTradeCancel;
          case common::ExecType::TradeCorrect: return ExchangeOrderEvent::ExchangeTradeCorrect;
          default:
            ORlogError << "Unsupported eventType. MsgType["<< msgType << "] ExecTransType["<< execTransType << "]" << "] ExecType["<< execType << "]" << ORLog::send;
            assert(false || execType==common::ExecType::PendingCancel || execType==common::ExecType::PendingNew || execType==common::ExecType::PendingReplace );
//??What if pending states?
          }
          break;
        }
        case common::ExecTransType::Cancel: return ExchangeOrderEvent::ExchangeTradeCancel;
        case common::ExecTransType::Correct: return ExchangeOrderEvent::ExchangeTradeCorrect;
        default:
          ORlogError << "Unsupported eventType. MsgType["<< msgType << "] ExecTransType["<< execTransType << "]" << ORLog::send;
          assert(false);
      }
      break;
    }
    case common::MsgType::OrderCancelReject:
    {
      common::LightStringRef clOrdIDStr = msg_.ClOrdID();
        if (clOrdIDStr._sz > ExchangeOrder::UUID_SIZE+2 && clOrdIDStr[ExchangeOrder::UUID_SIZE] == '-') // This is a reject on a cancel or a replace.
        {
          /*
           We cannot rely on tag 434 being present.
           Many ORs do not send tag 434. We determine whether the cxl reject was in response
           to a replace or cancel based on our id generation convention.
           ID convention:
              For new orders: clOrdID = orderUUID as string.
              For replaces : clOrdID = orderUUID-Rnn where nn is a monotonically increasing number.
              For cancels : clOrdID = orderUUID-Cnn where nn is a monotonically increasing number.
          */
          size_t pos = ExchangeOrder::UUID_SIZE+1;
          if (clOrdIDStr[pos] == 'R') return ExchangeOrderEvent::ExchangeOrderReplaceRejected;
          if (clOrdIDStr[pos] == 'C') return ExchangeOrderEvent::ExchangeOrderCxlRejected;
        }
        ORlogError << "Unexpected cancel reject. ClOrdId cannot match any solicited replace/cancel request." << ORLog::send;
      break;
    }
    default:
      ORlogError << "Unsupported eventType. MsgType["<< msgType << "]" << ORLog::send;
      assert(false);
  };

  return ExchangeOrderEvent::Last;
};

class ExchangeEventContext
{
public:
  ExchangeEventContext(ExchangeOrderState::Enum prevState_)
  : _dispatchErrorCode(common::ReturnCode::SUCCESS),
    _prevState(prevState_),
    _newState(prevState_)
  {}

  bool hasStateChanged() const { return _newState != _prevState; }
  ExchangeOrderState::Enum prevState() const { return _prevState; }
  ExchangeOrderState::Enum newState() const { return _newState; }
  common::ReturnCode dispatchError() { return _dispatchErrorCode; }
  void apply(ExchangeOrderState::Enum state_) { _newState = state_; }
  void setDispatchError(common::ReturnCode rc_) { _dispatchErrorCode = rc_; }

private:
  common::ReturnCode  _dispatchErrorCode;
  ExchangeOrderState::Enum _newState;
  ExchangeOrderState::Enum _prevState;
};

}}}

#endif
Attention:  ExchangeOrderManager.H
#ifndef ets_vx_om_ExchangeOrderManager_H
#define ets_vx_om_ExchangeOrderManager_H

///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#include <ets/vxperf/xprobes/xprobes.H>
#include "ExchangeOrderFSM.H"
#include "RemoteQueryProxy.H"
#include "../em/AllocationEntry.H"
#include "../common/ThreadContext.H"
#include "../common/MemoryAllocator.H"
#include "../common/LightList.H"
#include <ets/vx/common/StringSet.H>
#include <ets/vx/om/Fwd.H>
#include <ets/oom/RecoveryClient.H>
#include <ets/vx/om/EventHooks.H>

namespace ets { namespace vx { namespace om {
class ClientOrder;
}}}

template<>
struct MSHash<const ets::vx::om::ClientOrder*>: public std::unary_function<const ets::vx::om::ClientOrder*, unsigned long>
{
  unsigned long operator()(const ets::vx::om::ClientOrder* value_) const { return hash(value_); }
  static unsigned long hash(const ets::vx::om::ClientOrder* value_)  { return (unsigned long)value_; }
};//MSHash

namespace ets { namespace vx { namespace om {

struct ProcessBustAction
{
  enum Enum
  {
    Handle = 0,
    Drop,
    Forward,
  };
};

struct ExchangeOrderFactory
{
  typedef ExchangeOrder* (*ExchangeOrderAllocFuncPtr)(ClientOrder* co_, exch::AllocationEntry* ae_, void* objectPool_);
  typedef void (*ExchangeOrderDeallocFuncPtr)(ExchangeOrder*, void*);

  ExchangeOrderFactory(ExchangeOrderAllocFuncPtr create_, ExchangeOrderDeallocFuncPtr release_, void* userData_)
    : _create(create_),
      _release(release_),
      _userData(userData_)
  {}

  ExchangeOrder* create(ClientOrder* co_, exch::AllocationEntry* ae_)
  {
    return _create(co_, ae_, _userData);
  }

  void release(ExchangeOrder* eo_)
  {
    _release(eo_, _userData);
  }

private:
  void* _userData;
  ExchangeOrderAllocFuncPtr _create;
  ExchangeOrderDeallocFuncPtr _release;
};

typedef bool (*EnrichRecoverFuncPtr)(om::StripeContext&, fix::bin::TagValueGroup&);

class ExchangeOrderManager : public EventHooksMgr<bool (*) (ExchangeOrder &, void *), ExchangeOrderEvent>
{
public:
    typedef MSHashMap<common::LightStringRef, ExchangeOrder*> OrderMap;

    ExchangeOrderManager(
      ExchangeOrderFactory orderFactory_,
      ForwardExecutionFunctionPtr processFillOnEvictedOrder_,
      EnrichRecoverFuncPtr enricher_ = 0);

    ExchangeOrder* findOrder(const common::LightStringRef orderUUIdStr_);
    ExchangeOrder* findConditionalOrder(const common::LightStringRef orderUUIdStr_);
    ExchangeOrder* findClosedOrder(const common::LightStringRef orderUUIdStr_);

    ExchangeOrder* createExchangeOrder(ClientOrder& co_, exch::AllocationEntry* ae_);
    bool replaceExchangeOrder(ExchangeOrder* eo_, exch::AllocationEntry* ae_);
    bool sendCancel(ExchangeOrder* eo_, const exch::AllocationEntry& aeToCancel_, const bool force_);
    bool cancelExchangeOrder(ExchangeOrder* eo_, bool force_);
    ExchangeOrder* createConditionalOrder(ClientOrder& eo_, exch::AllocationEntry* ae_);
    bool replaceConditionalOrder(ExchangeOrder* eo_, exch::AllocationEntry* ae_);
    bool cancelConditionalOrder(ExchangeOrder* eo_);

    void evictExchangeOrder(ExchangeOrder* eo_, common::ThreadContext& tc_);
    void evictConditionalOrder(ExchangeOrder* eo_);
    void closeExchangeOrder(ExchangeOrder* eo_);

    void cancelExchangeOrders(common::LightDoubleLinkedListRoot<ExchangeOrder>& root, bool force);

    void processConditionalOrder(const ets::vx::msg::ExchangeReportPtr& msgPtr_,
                                 ExchangeOrderEvent::Enum event_);

    void processFixMessage(
      const ets::vx::msg::ExchangeReportPtr& msgPtr_,
      common::ThreadContext& tc_,
      ProcessBustAction::Enum processBusts,
      void* pForwardExecutionUserData_);

    common::ReturnCode processRecoveredMsg(const oom::OrderData& orderData,
                                           const oom::ExecutionMap& execMap_,
                                           StripeContext& sc_,
                                           common::ThreadContext& tc_,
                                           const MSHashSet<std::string>& processedExecIdSet_,
                                           bool recovery_ = true);

    const OrderMap& orders() const { return _exchangeOrders; }
    const OrderMap& conditionalOrders() const { return _openConditionalOrders; }
    const MSHashSet<common::LightStringRef>& unProcessedExecIds(const ClientOrder* co_) const;
    void processEvictedExecIds(ets::oom::ExecIDSet evictedExecIds_);

    void setQueryHandlerInterface(vx::om::QueryHandlerInterface* handler_);

private:
    typedef common::ReturnCode (ExchangeOrderManager::*EventPreprocessor)(const ExchangeEventArgs&, const ets::vx::msg::ExchangeReportPtr& msgPtr_);

    void initEventPreprocessors();

    common::ReturnCode processEvictedOrderExecution(ExchangeOrderEvent::Enum event_, const ets::vx::msg::ExchangeReportPtr& msgPtr_,
                                                    void* pForwardExecutionUserData_);

    common::ReturnCode queryAsync(const oom::recovery::QueryType::Enum             queryEnum_,
                                  const ets::vx::msg::ExchangeReportPtr&   message_,
                                  const common::LightStringRef&                    orderUUId_,
                                  const vx::om::RemoteQueryProxy::TaskContinuation task_,
                                  ExchangeOrder*                                   eo_,
                                  void*                                            pForwardExecutionUserData_);

    common::ReturnCode preprocessExchangeOrderReplaced       (const ExchangeEventArgs& event_, const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode preprocessExchangeOrderReplaceRejected(const ExchangeEventArgs& event_, const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode preprocessExchangeOrderCxlRejected    (const ExchangeEventArgs& event_, const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode preprocessExchangeOrderPartiallyFilled(const ExchangeEventArgs& event_, const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode preprocessExchangeOrderFilled         (const ExchangeEventArgs& event_, const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode preprocessExchangeOrderTradeCancel    (const ExchangeEventArgs& event_, const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode preprocessExchangeOrderTradeCorrect   (const ExchangeEventArgs& event_, const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    
    common::ReturnCode preprocessConditionalOrderFirmedUp    (const ExchangeEventArgs& event_, const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode preprocessConditionalOrderDfd         (const ExchangeEventArgs& event_, const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode validateConditionalFirmUpMsg          (const ExchangeOrder& eo_,       const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode validateConditionalDfdMsg             (const ExchangeOrder& eo_,       const ets::vx::msg::ExchangeReportPtr& msgPtr_);

    common::ReturnCode validateFillMsg                       (ExchangeOrder& eo_,       const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode validateCanceledMsg                   (const ExchangeOrder& eo_, const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode validateCancelRejectMsg               (const ExchangeOrder& eo_, const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode validateReplaceResponseMsg            (const ExchangeOrder& eo_, const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode preprocessTradeCorrect(ExchangeOrder& eo_, const ets::vx::msg::ExchangeReportPtr& msgPtr_);
    common::ReturnCode preprocessTradeCancel(ExchangeOrder& eo_,  const ets::vx::msg::ExchangeReportPtr& msgPtr_);

    common::ReturnCode processClosedOrderEvent(ExchangeOrderEvent::Enum event_, ClientOrder& co_, ExchangeOrder& eo_,
                                               const vx::msg::ExchangeRequestPtr& updateMsg_, common::ThreadContext& tc_);

    /// \brief check if a remote query is required or not
    ///
    /// \returns true if the query is required, queryType_ assigned to a
    //           specifiec query type for this query
    bool queryRequired(const ExchangeOrderEvent::Enum                 event_,
                       const ets::vx::msg::ExchangeReportPtr& response_,
                       const common::LightStringRef&                  orderUUId_,
                       const ExchangeOrder* const                     eo_,
                       oom::recovery::QueryType::Enum&                queryType_);

    EventPreprocessor _eventPreprocessors[ExchangeOrderEvent::Last];

    OrderMap _exchangeOrders;
    OrderMap _closedExchOrders;
    OrderMap _openConditionalOrders;
    ExchangeOrderFSM _fsm;
    ForwardExecutionFunctionPtr _forwardExecution;
    common::StringSet _execIdSet;
    MSHashMap<const ClientOrder*, MSHashSet<common::LightStringRef> > _unProcessedExecIds;
    ExchangeOrderFactory _orderFactory;

    vx::om::RemoteQueryProxy _queryProxy;
    EnrichRecoverFuncPtr _enrichRecovered;
};

}}}

#endif // ets_vx_om_ExchangeOrderManager_H
Attention:  ExchangeSliceOperation.H
#pragma once

#include "ExchangeSliceOperationStatus.H"

#include <ets/vx/common/MemoryAllocator.H>
#include <ets/vx/common/LightList.H>
#include <ets/vx/common/Enums.H>
#include <ets/vx/em/AllocationEntry.H>
#include <ets/vx/om/ExchangeOrder.H>
#include <boost/utility.hpp>

namespace ets { namespace vx { namespace om {

DECLARE_FIXEDSIZE_MEMORY_ALLOCATOR(ExchangeSliceOperation)

class ExchangeSliceOperation : public common::LightSingleLinkedListNode<ExchangeSliceOperation>, public boost::noncopyable
{
public:
  typedef ExchangeSliceOperationStatus::Enum Status;

  ExchangeSliceOperation() : _goodToGo(false)
  {}
  ~ExchangeSliceOperation();

  static ExchangeSliceOperation* createNewOrder(ClientOrder& co_, exch::AllocationEntry& ae_);
  static ExchangeSliceOperation* replaceOrder(ExchangeOrder& eo_, exch::AllocationEntry& ae_);
  static ExchangeSliceOperation* updateOrder(ExchangeOrder& eo_, exch::AllocationEntry& ae_);
  static ExchangeSliceOperation* cancelOrder(ExchangeOrder& eo_);

  static void release(ExchangeSliceOperation& );

  Status apply() { return (this->*_applyOp)(); }

  Quantity qtyRequiredFromPocket() const { return _qtyRequiredFromPocket; } // OM to check against pocketQty

  bool isValid() const;

  ExchangeOrder* exchOrder() const { return _eo; }
  exch::AllocationEntry* allocationEntry() const { return _ae; }

  common::SliceOperationType type() const { return _type; }

  void goodToGo(bool isGood_) { _goodToGo = isGood_; }
  bool isGoodToGo() const { return _goodToGo; }

private:
  Status applyNew();
  Status applyReplace();
  Status applyUpdate();
  Status applyCancel();
  Status applyConditionalNew();
  Status applyConditionalReplace();
  Status applyConditionalCancel();

  Status (ExchangeSliceOperation::*_applyOp)();

  common::SliceOperationType _type;
  bool _goodToGo;
  ExchangeOrder* _eo;
  exch::AllocationEntry* _ae;
  ClientOrder* _co;
  Quantity _qtyRequiredFromPocket; 
};

}}}

Attention:  ExchangeSliceOperationStatus.H
#ifndef ets_vx_om_ExchangeSliceOperationStatus_H
#define ets_vx_om_ExchangeSliceOperationStatus_H
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

namespace ets { namespace vx { namespace om {

struct ExchangeSliceOperationStatus
{
  enum Enum {
    SUCCESS = 0,
    DEFER,
    ERROR,
    CONDITIONAL_ORDER_CXL_SUCCESS,
    SIZE
  };
};

}}}

namespace ets { namespace vx { namespace om {

// TOOD: clean this up
// for backward compatibility
typedef ets::vx::om::ExchangeSliceOperationStatus ExchangeSliceOperationStatus;

}}}

#endif
Attention:  Fwd.H
#pragma once

#include <limits>
#include <ets/vx/common/ReturnCode.H>

namespace ets { namespace fix { namespace bin {
  class Message;
}}}

namespace ets { namespace vx { namespace exch {
  class AllocationEntry;
  class AllocationEntries;
}}}

namespace ets { namespace vx { namespace msg {
  class ExchangeReport;
  typedef MSManagedPointer<ExchangeReport> ExchangeReportPtr;
  
  class ExchangeRequest;
  typedef MSManagedPointer<ExchangeRequest> ExchangeRequestPtr;
  
  class ClientRequest;
  typedef MSManagedPointer<ClientRequest> ClientRequestPtr;

  class ClientReport;
  typedef MSManagedPointer<ClientReport> ClientReportPtr;
}}}

namespace ets { namespace vx { namespace common {
  class ReturnCode;
  class ThreadContext;
}}}

namespace ets { namespace vx { namespace timer {

  class TimerBase;
  class MetronomeTimerManager;
  class HRTimerManager;
}}}

namespace ets { namespace vx { namespace om {
  class ClientOrder;
  class ExchangeOrder;
  class StripeContext;

  class ClientOrderManager;
  class ExchangeOrderManager;
  class ExchangeSliceOperation;
  class EvalConditionRepository;
  class PrePostEvalRepository;
  class DeltaEngine;

  typedef bool (*ExchangeOrderHook)(const ExchangeOrder& eo_, void* userData_);
  typedef void (*DropMessageFunctionPtr)(common::ReturnCode ec, const fix::bin::Message* msg, void* userData_);
  typedef common::ReturnCode (*ForwardExecutionFunctionPtr)(const ets::vx::msg::ExchangeReportPtr&, void*);

  extern const char* backupDestExch;

  // multileg related types
  using LegId = uint8_t;
  using ClipId = uint16_t;
  using NodeId = uint32_t;

  constexpr LegId InvalidLegId() { return std::numeric_limits<LegId>::max(); }
  constexpr ClipId InvalidClipId() { return std::numeric_limits<ClipId>::max(); }
  constexpr size_t MaxNumOfLegs() { return 16; }
}}}

Attention:  NotionalClientOrder.H
#pragma once

#include "ClientOrder.H"
#include "BaseOrder.H"
#include <vector>
#include <list>
#include <unordered_map>

namespace ets { namespace vx { namespace om {

class NotionalClientOrder : public ClientOrder
{
  friend class ClientOrder;
public:
  explicit NotionalClientOrder(common::ThreadContext& tc_, char* allocatorStateBuf_ = nullptr);
  virtual ~NotionalClientOrder();

  void log();
  void addFill(Quantity fillQty_, Amount fillValue_);

  uint8_t legSize() const {return _legSize;}
  LegOrder& getLeg(LegId index) { return *_legs[index]; }
  const LegOrder& getLeg(LegId index) const { return *_legs[index]; }
  Quantity qtyInNotional(LegId legId, Quantity qty_) const;
  Quantity qtyInLeg(LegId legId, Quantity qty_);
  Amount   valueInNotional(LegId legId, Amount value_);

protected:
  // these methods will be accessed by ClientOrder to avoid virtual function calls
  common::ReturnCode notionalEnterPendingNew();
  common::ReturnCode notionalEnterPendingReplace();
  void notionalAcceptReplaceRequest();
  void notionalRejectReplaceRequest();
  
  EvalTriggerEvents notionalAddFill(Quantity fillQty_, Amount fillValue_, ExchangeOrder& eo_);
  void notionalRemoveFill(Quantity fillQty_, Amount fillValue_, ExchangeOrder& eo_);

  void notionalReducePocketQty(Quantity qty_, ExchangeOrder& eo_);
  void notionalIncreasePocketQty(Quantity qty_, ExchangeOrder& eo_);
  void notionalReduceChildIOCLeavesQty(Quantity qty_, ExchangeOrder& eo_);
  void notionalIncreaseChildIOCLeavesQty(Quantity qty_, ExchangeOrder& eo_);
  void notionalReduceChildPinnedQty(Quantity qty_, ExchangeOrder& eo_);
  void notionalIncreaseChildPinnedQty(Quantity qty_, ExchangeOrder& eo_);

public:
  Quantity allocatableQty(LegId legIndex_) const;
  void addTriggerEvalOnBitMask(EvalTriggerEvents bitMask_) { _triggerEvalOnBitMask |= bitMask_; }
  EvalTriggerMask triggerSelfEvalOnBitMask() const { return _triggerSelfEvalOnBitMask; }
  EvalTriggerMask targetTriggerSelfEvalOnBitMask() const { return _targetTriggerSelfEvalOnBitMask; }
  void setTargetTriggerEvalOnBitMask(EvalTriggerMask bitMask_) { _targetTriggerSelfEvalOnBitMask = bitMask_; }

  bool shouldSelfEvalOnSliceEvent(EvalTriggerEvents evt_) const { return _triggerSelfEvalOnBitMask & evt_ || FORCE_EVAL_EVENT & evt_; }
  void expectMarketDataEvent() { _triggerSelfEvalOnBitMask |= EvalTriggerEvent::MarketDataTriggered;  addTriggerEvalOnBitMask(EvalTriggerEvent::MarketDataTriggered); }

  EvalTriggerMask hasPartiallyFilled() const { return _eventsSinceLastEval & (EvalTriggerEvent::ClipFullyFilled|EvalTriggerEvent::ClipPartiallyFilled); }

  void addPocketFill(LegId index, Quantity fillQty_, Amount fillValue_) { _legs[index]->addPocketFill(fillQty_, fillValue_); }
  int clipSize() { return _clips.size(); }

  void commitTrigerEvalOnBitMask()
  {
    setTriggerEvalOnBitMask(0);
    _triggerSelfEvalOnBitMask = _targetTriggerSelfEvalOnBitMask;
    addTriggerEvalOnBitMask(_triggerSelfEvalOnBitMask);
    for( auto* clip : _clips)
    {
      clip->commitTrigerEvalOnBitMask();
    }
  }

  Quantity allocatedNotionalQty()
  {
    Quantity qty = QuantityZero;
    for (auto* clip : _clips)
    {
      qty += clip->targetQty();
    }
    return qty;
  }
  Quantity allocatedLegQty(LegId index_)
  {
    Quantity qty = QuantityZero;
    for (auto* clip : _clips)
    {
      qty += clip->getLeg(index_)->targetQty();
    }
    return qty;
  }
  Clip* getClip(int index_) { return _clips[index_]; }
  Clip* addClip(Quantity qty_, Price price_)
  {
    if (qty_<=QuantityZero)
    {
      raiseAlert<om::alert::AllocationFailure>("Allocating clip with negative or zero qty.");
      return NULL;
    }
    // check if any left quantity in any legs, if there isn't, skil adding
    bool hasLeaveQtyInLeg = false;
    for (auto* leg : _legs)
    {
     if (leg->targetQty() > allocatedLegQty(leg->legId()))
      {
        hasLeaveQtyInLeg = true;
        break;
      }
    }
    if (!hasLeaveQtyInLeg)
      return NULL;

    Clip* clip = new Clip(this, _clips.size(), threadContext());
    clip->setTargetQty(qty_);
    clip->_targetPrice = price_;
    _clips.push_back(clip);
    return clip;
  }

  void clearClips()
  {
    for (int i=0; i<_clips.size(); ++i)
    {
      removeClip(i);
    }
  }

  void removeClip(int index_)
  {
    if (index_ >= _clips.size())
    {
      return;
    }
    Clip* clip = _clips[index_];

    // recollect the clip cumQty/cumValue for future new clips
    // always keep clip in the list. only reset the targetQty = 0
    clip->setTargetQty(QuantityZero);
  }

  orderProfile::OrderProfile* legProfile() { return _legProfile; }
  orderProfile::OrderProfile* clipProfile() { return _clipProfile; }

  void setProfile(orderProfile::ProfileStorage* storage)
  {
    if (_profile)
    {
      _profile->_profileType->destroyAllocatorStateBuffer(_allocatorStateBuf);
    }
    _profile=storage->_defaultProfile;
    _profile->_profileType->initAllocatorStateBuffer(_allocatorStateBuf);
  }

  // clip/leg allocatorstate will be created in clip/leg level.
  void setLegProfile(orderProfile::ProfileStorage* storage)
  {
    _legProfile=storage->_defaultProfile;
  }

  void setClipProfile(orderProfile::ProfileStorage* storage)
  {
    _clipProfile=storage->_defaultProfile;
  }

  void setLegProfile(orderProfile::OrderProfile* profile)
  {
    _legProfile=profile;
  }

  void setClipProfile(orderProfile::OrderProfile* profile)
  {
    _clipProfile=profile;
  }

  virtual bool isPunted() const;
  virtual common::ReturnCode puntToBackup(const common::LightStringRef& str, bool adminTriggered_);
  virtual bool isSyncTakeEnabled() const;
  virtual void applySyncTake();
  //TODO where is this function
  bool validateCumQty(const Quantity epsilon_, std::ostringstream& os_) const;
  bool distributePocketCumOnClip(Clip& clip_);
  EvalTriggerEvents distributePocketCum();
  common::ReturnCode instantiateLegOrderInRecovery();

  /*************************************
   * following are interface functions *
   *************************************/
  bool hasLegFills() const;
  bool isNotionalCurrentFullyFilled() const;
  bool willNotionalTargetFullyFilled() const;

  Quantity clipLegPocketQty(const exch::AllocationEntry& ae_) const;
  Quantity clipLegLeavesQty(const exch::AllocationEntry& ae_) const;

  bool clipHasEnoughAllocatableQty(const ExchangeSliceOperation& op_) const;

  void performClipPostEvalActions();

  common::ReturnCode recoverLegCurrent(const oom::OrderData& orderData_);

  void onChildOrderAdded(ExchangeOrder*);
  void onChildOrderClosed(ExchangeOrder*);

  ExchangeSliceOperation::Status notionalProcessExchangeSliceOperations();

  bool notionalValidateRecoveredState(std::ostringstream& os_, bool alert_);

private:
  common::ReturnCode allocateClip();
  void purgePendingOperations(ClipId clipId_=-1, LegId legId=-1);
  bool hasEnoughClipPocketQty(LegSlice& leg_);
  bool validateClipAllocation();
  void logPendingExchangeSliceOperations();
  virtual double getLegContractMultiplier(LegId index) const;
  common::ReturnCode instantiateLegOrder();

private:
  uint8_t _legSize;

  std::vector<Clip*> _clips;
  std::vector<LegOrder*> _legs;

  EvalTriggerMask _triggerSelfEvalOnBitMask = 0;
  EvalTriggerMask _targetTriggerSelfEvalOnBitMask = 0;

  double _qtyRatio[MaxNumOfLegs()];

  orderProfile::OrderProfile* _legProfile = nullptr;
  orderProfile::OrderProfile* _clipProfile = nullptr;
  std::unordered_map<int, bool> _operationSynMap;

  common::ReturnCode processNotionalEvaluation(EvalTriggerEvents evalEvent_);
};

inline
Quantity NotionalClientOrder::qtyInNotional(LegId legId_, Quantity qty_) const
{
  assert(legId_ < _legSize);
  return qty_.multiplyAndRound(_qtyRatio[legId_]);
}

inline
Amount NotionalClientOrder::valueInNotional(LegId legId_, Amount value_)
{
  assert(legId_ < _legSize);
  return value_ * _qtyRatio[legId_];
}

inline
Quantity NotionalClientOrder::qtyInLeg(LegId legId_, Quantity qty_)
{
  assert(legId_ < _legSize);
  if (0.0 == _qtyRatio[legId_])
    return QuantityZero;
  return qty_.divideAndRound(_qtyRatio[legId_]);
}

inline
Quantity
NotionalClientOrder::allocatableQty(LegId legIndex_)  const
{
  assert(legIndex_ < _legs.size());
  auto& leg= *_legs[legIndex_];
  //return leg.pocketQty() + std::min(leg.targetQty() - leg.currentQty(), QuantityZero);
  return leg.pocketQty();
}

inline 
bool NotionalClientOrder::distributePocketCumOnClip(Clip& clip_)
{
  for (int i =0 ; i<_legs.size(); ++i)
  {
    auto* legOrder = _legs[i];

    if (legOrder->_pocketCumQty <= QuantityZero)
      continue;

    // check each clip if there is room to attribute the pocket fills
    auto* legSlice = clip_.getLeg(i);

    Quantity room = legSlice->targetQty() - legSlice->cumQty();
    if (room <= QuantityZero)
      continue;

    Quantity delta = room > legOrder->_pocketCumQty ? legOrder->_pocketCumQty : room;
    Amount deltaValue = legOrder->_pocketCumValue / legOrder->_pocketCumQty._val * delta._val;

    // attribute proper fill on this clip_
    clip_.addLegFill(delta, deltaValue, i, false/*indicating the fill is from distributing*/);

    legOrder->_pocketCumQty -= delta;
    legOrder->_pocketCumValue -= deltaValue;

    return true;
  }
  return false;
}

}}}

#define NOTIONALORDER_ALLOCATOR(PROFILE_TYPE) ALLOCATOR_T(PROFILE_TYPE, ets::vx::om::NotionalClientOrder)
#define CLIP_ALLOCATOR(PROFILE_TYPE) ALLOCATOR_T(PROFILE_TYPE, ets::vx::om::Clip)
#define LEG_ALLOCATOR(PROFILE_TYPE) ALLOCATOR_T(PROFILE_TYPE, ets::vx::om::LegSlice)
Attention:  OrderQueryUtil.H
///////////////////////////////////////////////////////////////////////////////
//
// Copyright 2013 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef ets_vx_om_OrderQueryUtil_H
#define ets_vx_om_OrderQueryUtil_H

#include "ExchangeOrderFSM.H"
#include "Fwd.H"
#include <ets/vx/common/FixMsg.H>
#include <ets/vx/msg/ExchangeReport.H>

#include <ets/oom/RecoveryClient.H>

namespace ets { namespace vx { namespace om {

oom::ExecIDSet getUnbindedExecIds(const oom::ExecIDSet& coExecIds_, const oom::ExecIDSet& eoExecIds_);

// XXX HACK
// Re-apply the retrieved execution to make sure VX handle the message itself
void revertOrderState(const ets::vx::om::ExchangeOrderEvent::Enum event_,
                      const ets::vx::msg::ExchangeReportPtr& response_,
                      const oom::Execution& execution_,
                      oom::OrderState& state_);

}}}

#endif

Attention:  PrePostEvalRepository.H
#ifndef vx_om_PrePostEvalRepository_H
#define vx_om_PrePostEvalRepository_H

///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#include "EvalTriggers.H"
#include <ets/vx/orderProfile/OrderProfile.H>
#include <ets/vxperf/xprobes/xprobes.H>

namespace ets { namespace vx { namespace om {

class ClientOrder;

class PrePostEvalRepository
{
public:
  typedef void (* PrePostEvalFunction) (ClientOrder& );

  inline void insert(PrePostEvalFunction func_)
  {
    _prePostEvalFunctions.push_back(func_);
  }

  inline void invoke(ClientOrder& co_) const
  {
    std::list<PrePostEvalFunction>::const_iterator it = _prePostEvalFunctions.begin();
    for(; it != _prePostEvalFunctions.end(); ++it )
    {
      (*it)(co_);
    }
  }

private:
    std::list<PrePostEvalFunction> _prePostEvalFunctions;
};

}}}

#endif // vx_om_PrePostEvalRepository_H
Attention:  Product.H
#pragma once

#include <ets/vx/staticStruct/StaticStruct.H>
#include <ets/appKernel/ProductT.H>
#include <string>

namespace ets { namespace vx { namespace om {

// common product data used by vx
VX_PINNABLE_STRUCT(Product)
{
  bool initialize(const ets::product::Data& pdata);
  STATIC_STRUCT_REQUIRED_FIELD(bool,                    initialized) = false;   // set once initialize() is called

  STATIC_STRUCT_PINNABLE_FIELD(std::string,             mdSymbol);
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             tradeSymbol);
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             tradeSymbolRoot);
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             tradeSymbolSuffix);
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             issueID);
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             marketID);
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             mdTick);
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             mdExchange);
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             fixExchange);
  STATIC_STRUCT_PINNABLE_FIELD(int,                     lotSize);
  STATIC_STRUCT_PINNABLE_FIELD(double,                  contractSize);
  STATIC_STRUCT_PINNABLE_FIELD(ets::product::IssueType, issueType);
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             ccpMemberID);
  STATIC_STRUCT_PINNABLE_FIELD(double,                  scalePrice);            // note: this is a Scalar to scale prices, not a price itself
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             marketCurrency);

  // consolidatedMdSymbol and consolidatedMdTick & consolidatedMdExch
  // NB: MdTick + '.' + MdExch should match consolidatedMdSymbol;
  //     to enforce this, if consolidatedMdSymbol is pinned, 
  //     we won't update the MdTick or MdExch
  // NB: weird things will happen if they are not updated together
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             consolidatedMdSymbol);
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             consolidatedMdTick);    // ETSProduct-supplied breakdown
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             consolidatedMdExch);    //  from consolidatedMdSymbol

  // this is the symbol displayed in netadmin output and alert, by default it's mdSymbol
  STATIC_STRUCT_PINNABLE_FIELD(std::string,             displaySymbol);
};

}}}

Attention:  PuntToBackupEventHook.H
#ifndef vx_app_PuntToBackupEventHook_H
#define vx_app_PuntToBackupEventHook_H

///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#include <OR/fixMessage/fixMessage/ORFixMessage.H>

namespace ets { namespace vx { namespace om {

class ExchangeOrder;

bool onPuntedOrderDFDOrReject(ExchangeOrder& eo_, void* userData_);
bool onPuntedOrderCanceled(ExchangeOrder& eo_, void* userData_);

}}}

#endif // vx_app_PuntToBackupEventHook_H

Attention:  PuntToBackupReplaceRequestEvaluator.H
#ifndef ets_vx_om_PuntToBackupReplaceRequestEvaluator_H
#define ets_vx_om_PuntToBackupReplaceRequestEvaluator_H

///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////
#include "ReplaceRequestEvaluators.H"
#include "ClientOrderFsmTypes.H"

#include "../common/ReturnCode.H"

namespace ets { namespace vx { namespace om {

class ClientOrder;
class ExchangeOrder;

ReplaceActionEnum puntToBackupClientReplaceRequestEvaluator(
    ClientOrderEvent::Enum event_, ClientOrder& co_,
    ExchangeOrder* eo_, common::ReturnCode& rc_, void* userData);//ClientReplaceRequestEvaluator

}}}

#endif 
Attention:  RecoveryUtil.H
#ifndef vx_common_RecoveryUtil_H
#define vx_common_RecoveryUtil_H

#include <ets/oom/OrderData.H>
#include <ets/vx/common/FixMsgFactory.H>
#include "ExchangeOrder.H"

namespace ets { namespace vx { namespace om {

using ClientOrderCreator = std::function<common::ReturnCode (common::FixMsgFactory& fixMsgFactory_, fix::bin::MessagePtr, vx::msg::ClientRequestPtr&)>;
ClientOrderCreator registerClientOrderCreator(ClientOrderCreator creator_);

vx::msg::ClientRequestPtr convertClientOrderPtr(common::FixMsgFactory& fixMsgFactory_, const ets::oom::OrderData& orderData_, oom::OrderData::TradingDataType tdtType_);
// have to return bfix because of cumQty is stored as tag, not state, see jira vx-983
common::FixMsgPoolObjectPtr convertExchangeOrderPtr(common::FixMsgFactory& fixMsgFactory_, const ets::oom::OrderData& orderData_, oom::OrderData::TradingDataType tdtType_);

}}}

#endif
Attention:  RejectClientOrderCompletion.H
#pragma once
#ifndef ets_vx_om_RejectClientOrderCompletion_H
#define ets_vx_om_RejectClientOrderCompletion_H

///////////////////////////////////////////////////////////////////////////////
//
//      Copyright (c) 2014 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#include <ets/vx/om/ErrorCode.H>
#include <ets/vx/om/ClientOrder.H>
#include <ets/vx/common/CompletionList.H>
#include <ets/vx/common/MemoryAllocator.H>
#include <ets/vx/logging/logging.H>

namespace ets { namespace vx { namespace om {

//
// RejectClientOrderCompletion
//  Reject the client order with the provided reason,
//  at the completion of this transaction.
//

DECLARE_FIXEDSIZE_MEMORY_ALLOCATOR(RejectClientOrderCompletion);
class RejectClientOrderCompletion
  : public common::CompletionNodeBaseT<RejectClientOrderCompletion>
{
  public:

    // Create and Queue a Rejection Request

    static void queue_reject(om::ClientOrder& co_, om::ErrorCode::Enum reason_)
    {   // instantiate and queue the reject
        assert(co_.ghost());
        RejectClientOrderCompletion *cb = getRejectClientOrderCompletionFactory().create(*co_.ghost(), reason_);
        co_.stripeContext().add(cb);                        // add to completion queue in ClientOrderManager
        VXLOGD("queueing reject for order $0", (co_.ghost()->uuid().asString()));
    }

  public:

    // Implementation interface

    static void invoke(RejectClientOrderCompletion* obj_)   // reject the CO
    { 
        assert(obj_); 
        const ClientOrderGhost& ghost = obj_->_ghost;
        ClientOrder* co = ghost.co();
        if (co)                                              // if order has not yet been evicted
            co->reject(obj_->_reason);                      //  reject it

        if (co) {
          VXLOGD("Limits: rejecting order $0", (ghost.uuid().asString()));
        } else {
          VXLOGD("Limits: order $0 already evicted; no reject necessary", (ghost.uuid().asString()));
        }
    }

    // Mechanics

    RejectClientOrderCompletion(const om::ClientOrderGhost& ghost_, const om::ErrorCode::Enum reason_)
      : _ghost(ghost_), _reason(reason_)
    {
    }

    static void release(RejectClientOrderCompletion* obj_)   // destruction
    {
        getRejectClientOrderCompletionFactory().release(obj_);
    }

  private:
    const om::ClientOrderGhost& _ghost;                      // ghosts do not die; perpetual handle to basic CO details
    const om::ErrorCode::Enum   _reason;                     // reject reason
};

}}} // namespace ets::vx::om

#endif // ets_vx_om_RejectClientOrderCompletion_H
Attention:  RemoteQueryProxy.H
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2013 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef ets_vx_om_RemoteQueryProxy_H
#define ets_vx_om_RemoteQueryProxy_H

#include <ets/vx/msg/ExchangeReport.H>
#include <ets/vx/om/Fwd.H>
#include <ets/vx/common/FixMsg.H>
#include <ets/vx/common/LightString.H>
#include <ets/etsApp/core/Fwd.H>
#include <ets/etsApp/core/Event.H>
#include <ets/etsApp/core/EventDispatcher.H>
#include <ets/oom/RecoveryClient.H>

#include <boost/noncopyable.hpp>
#include <boost/variant.hpp>
#include <functional>
#include <deque>

namespace ets { namespace vx { namespace om {

typedef boost::variant<std::pair<std::string, uint32_t>, std::string> TopicInfoVariant;

/// \brief Represents the contracts for a concrete handler which handles async query
///
/// QueryHandlerInterface provides a minimum set of requirements that a
/// handler should be equipped if it should support async query from vOOM.
/// It is used in RemoteQueryProxy.
class QueryHandlerInterface : boost::noncopyable
{
public:
  /// \brief Determine the recover topic for the given response
  ///
  /// \param response_ [in] The given response which triggers query logics
  /// \returns The recover topic for retrieving the data from vOOM
  virtual TopicInfoVariant getQueryTopic(void* pForwardExecutionUserData_) = 0;

  /// \brief The callback when Proxy retrieves the result from vOOM
  ///
  /// The client can take this chance to apply necessary information on the
  /// original response message.  It is guaranteed to be called in handler
  /// thread.
  ///
  /// \param response_ [in] The response message which triggers the query
  /// \param result_ [in|out] The mutable query result
  virtual void onQueryResultRetrieved(const ets::vx::msg::ExchangeReportPtr& response_,
                                      void*                                          pForwardExecutionUserData_,
                                      oom::recovery::QueryResult&                    result_) = 0;

  /// \brief Returns the EventDispatcher to process the continued work
  ///
  /// The dispatcher should be the one that handles the async query, in
  /// order to continue executing the task after the query result returns,
  virtual ets::app::core::EventDispatcher::Ptr dispatcher() = 0;

  /// \brief Dispatch the result callback function to the handler which invokes the query
  virtual void dispatch(std::function<void ()>&& callback_);

protected:
  virtual ~QueryHandlerInterface() {}
};


/// \brief Represents a stateful task queue
template <typename Task>
struct TaskQueue : private std::deque<Task>
{
  typedef std::deque<Task> Base;
  friend class RemoteQueryProxy;

  TaskQueue() : hasPendingTask(false) {}

  using Base::push_back;

  // indicating if the task at queue head is pending for the query result
  bool hasPendingTask;
};


/// \brief An encapsulation for async query execution and message queueing
///
/// RemoteQueryProxy is responsible for
/// 1. Providing a lightweight wrapper of async query to vOOM
/// 2. Handling the dispatching caveats that vOOM query callback lacks
/// 3. Managing the queued task executions in the query task queue
class RemoteQueryProxy
{
public:
  typedef boost::function<void ()>    TaskContinuation;
  typedef TaskQueue<TaskContinuation> QueryTaskQueue;

  RemoteQueryProxy() : _handler(0) {}

  /// \brief Execute an async query
  ///
  /// RemoteQueryProxy registers a TaskContinuation into a task queue for the
  /// order, specified by orderKey, if the async query is successfully initiated.
  ///
  /// It is prefered to be called in handler thread
  ///
  /// \param criteria_ The required query criteria
  /// \param orderKey_ The unique key of the order that requires the query
  /// \param response_ The message causing the async query.  It is used in
  ///                  QueryHandlerInterface::onQueryResultRetrieved
  /// \param task_  The task to be executed when the query result is retreived
  /// \param queue_ [out] A reference to the registered task queue
  ///
  /// \returns ReturnCode
  ets::vx::common::ReturnCode queryAsync(const oom::recovery::QueryCriteria&            criteria_,
                                       const ets::vx::common::LightStringRef&           orderKey_,
                                       const ets::vx::msg::ExchangeReportPtr& response_,
                                       TaskContinuation                           task_,
                                       QueryTaskQueue*&                           queue_,
                                       void*                                      pForwardExecutionUserData_);

  /// \brief Execute an async query
  ///
  /// RemoteQueryProxy registers a TaskContinuation into the given task queue
  /// if the async query is successfully initiated.
  ///
  /// It is prefered to be called in handler thread
  ///
  /// \param criteria_ The required query criteria
  /// \param response_ The message causing the async query.  It is used in
  ///                  QueryHandlerInterface::onQueryResultRetrieved
  /// \param task_  The task to be executed when the query result is retreived
  /// \param queue_ The given task queue
  ///
  /// \returns ReturnCode
  ets::vx::common::ReturnCode queryAsync(const oom::recovery::QueryCriteria&            criteria_,
                                       const ets::vx::msg::ExchangeReportPtr& response_,
                                       TaskContinuation                               task_,
                                       QueryTaskQueue&                                queue_,
                                       void*                                          pForwardExecutionUserData_);

  // Note Handler must call this method to make the proxy work
  void setQueryHandlerInterface(QueryHandlerInterface* handler_);

  bool hasPendingQuery(const ets::vx::common::LightStringRef& orderKey_);

  void appendTask(const ets::vx::common::LightStringRef& orderKey_, TaskContinuation task_);

private:
  /// A map of OrderKey -> TaskQueue
  typedef MSHashMap<vx::common::LightStringRef, QueryTaskQueue> OrderQueryTaskMap;

  void dispatchToHandler(QueryTaskQueue&                                queue_,
                         const ets::vx::msg::ExchangeReportPtr& response_,
                         const std::string&                             topic_,
                         oom::recovery::QueryResult&                    result_,
                         void*                                          pForwardExecutionUserData_);

  void queryRetrieved(const ets::vx::msg::ExchangeReportPtr& response_,
                     void*                                          pForwardExecutionUserData_,
                      QueryTaskQueue&                                queue_,
                      MSManagedPointer<oom::recovery::QueryResult>   result_);

  QueryHandlerInterface& handler() const;

  // A per-handler-based task queue repository
  OrderQueryTaskMap      _taskMap;
  QueryHandlerInterface* _handler;
};

}}}

#endif

Attention:  ReplaceRequestEvaluators.H
#ifndef vx_om_ReplaceRequestEvaluators_H
#define vx_om_ReplaceRequestEvaluators_H
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

namespace ets { namespace vx { namespace om {

struct ReplaceAction
{
    enum Enum
    {
        AcceptImmediate=0,
        Wait,
        Reject
    };
};

typedef ReplaceAction::Enum ReplaceActionEnum;

}}}

#endif

Attention:  RestateTags.H
#ifndef ets_vx_msg_RestateTags
#define ets_vx_msg_RestateTags

///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2013 Morgan Stanley & Co. Incorporated, All Rights Reserved
//
// Unpublished copyright.  All rights reserved.  This material contains
// proprietary information that shall be used or copied only within Morgan
// Stanley, except with written permission of Morgan Stanley.
//
///////////////////////////////////////////////////////////////////////////////

#include <ets/vx/common/Primitives.H>

namespace ets { namespace vx { namespace om {

struct RestateTags 
{
  //to define in the app space
  Quantity _orderQty;

  virtual ~RestateTags() {}
};

}}}

#endif // ets_vx_msg_RestateTags
Attention:  StripeContext.H
#pragma once

#include <ets/vx/limits/LimitContext.H>
#include <ets/vx/em/ExchangeDefs.H>
#include <ets/vx/common/LightList.H>
#include "ClientOrderListNode.H"

#include <ets/vx/common/MemoryAllocator.H>
#include <ets/vx/em/ExchangeDefs.H>
#include <OR/fr/ump/UMPSender.H>
#include <OR/etsRouter/RoundRobinRS.H>
#include <OR/etsRouter/Rule.H>
#include "Product.H"
#include <vector>
#include <set>
#include <map>

namespace ets { namespace vx { namespace om {

typedef std::vector<double>             WeightMult;
typedef MSManagedPointer<WeightMult>    WeightMultPtr;

// A stripe represents a logical partition of the services provided by the
// application. For example, an application may be striped by symbol or by
// client.
//
// Members of this base class should *only* be high-level generic items that
// apply to all types of stripes. Applications should extend this type to
// provide stripe-specific members. For example, an application striped by
// symbol should extend this classs and place the relevant symbol-specific data
// in this newly derived type.
//
// TODO: Migrate symbol-specific data members from this class into each
// application's SymbolContext.
struct StripeContext
  : public boost::noncopyable
  , public limits::LimitContext  // StripeContext stores limit structures, specialized to this stripe
{
protected:
  WeightMultPtr _destWeightMultPtr;
  StripeContext();
  ~StripeContext();

  bool initialize(ets::router::tiaf::UMPSender* logSenderPtr_, uint32_t bucketNum_, const limits::LimitContextConfig& config_);
  ///<@ the mdi, mode, and currencyFunction parameters are for Limits and are detailed in LimitContext::initialize()

public:
  struct DestinationData // aka DestinationInfo
  {
    typedef ets::router::UMPDestination<fix::bin::MessagePtr> UMPDestination;

    mutable UMPDestination* _cachedDestination = DestinationData::getUnavailableDestination();
    std::shared_ptr<ets::router::RoundRobinRS<fix::bin::MessagePtr>> _cachedStrategy;
    uint32_t _dispatchIndex;

    ets::router::RoundRobinRS<fix::bin::MessagePtr>* getCachedStrategy()
    {
      return _cachedStrategy.get();
    }

    UMPDestination* getDestination() const
    {
      if (_cachedStrategy)
      {
        _cachedStrategy->rawSelectNextDestinationT<false, ets::router::UMPDestination<fix::bin::MessagePtr>>(_cachedDestination);
        if (!_cachedDestination)
        {
          _cachedDestination = DestinationData::getUnavailableDestination();
        }
      }
      return _cachedDestination;
    }

    bool hasValidDestination() const
    {
      if (!_cachedDestination->status()) return getDestination()->status();

      return true;
    }

    static UMPDestination* getUnavailableDestination()
    {
      static UMPDestination* unavailableDest( new UMPDestination(std::string("AlwaysDown"),  false, ets::router::SecMsgRouteModeEnum::DoNotAllow));
      return unavailableDest;
    }
  };

  const DestinationData& getDestinationData(uint8_t exchId_, vx::exch::RoutingStrategy::Enum strat_) const
  {
    return _destinationCache[strat_][exchId_];
  }

  /**
   * Initializes the StripeContext for a product (symbol)
   * Must be called at least once before initialize()
   * Called from
   *    VxOMHandler::findSymbolContext
   *        VxOMHandler::createSymbolContext.
   * @param productPtr_
   * @param procId  Empty string represents the default_proc_id
   * @return
   */
  virtual bool updateProduct(ets::product::DataPtr& productPtr_, const std::string& procId = "");

public:
  const std::string& stripeID() const;    // unique identifier string for this stripe, for logging
                                          // TODO: currently uses Product.mdSymbol, but should really be set by descendent

  const Product& product() const { return _product; }
  ets::router::tiaf::UMPSender* logSenderPtr() const { return _logSenderPtr; }
  void dropQuote(uint8_t exchId_) { _manuallyDropped.set(exchId_); }
  void undropQuote(uint8_t exchId_) { _manuallyDropped.set(exchId_, false); }
  bool isQuoteManuallyDropped(uint8_t exchId_) const { return _manuallyDropped[exchId_]; }

  const ScalingFactor& priceScalingFactor() const
  {
    // This will be dynamic when we move to exegy.
    assert(_scalingFactor._n);
    return _scalingFactor;
  }

  common::LightDoubleLinkedListRoot<ClientOrderListNode>& activeOrders()
  {
    return _activeOrders;
  }

  bool puntEnabled() const { return _puntEnabled; }
  void setPuntEnabled(bool enablePunt_);
  void puntAllOrders();

  WeightMultPtr& getDestWeightMultPtr();
  double getDestWeightMult(const uint8_t exchId) const
  {
    return (*_destWeightMultPtr)[exchId];
  }

  uint32_t bucketNum() const { return _bucketNum;}

  virtual void log(const ClientOrder* co_) const;   // application-defined logging

private:
  /**
   * Calculates and caches the routing destination or strategy.
   * @param layout
   * @param instance process id of the layout, empty string for default 
   * @param routingStrategyName  Only TopicRS and RoundRobinRS are supported
   * @param destinationVenueName
   * @param product
   * @param exchangeId
   * @param algoStrategyId
   * @param dispatchIndex
   * @return
   */
  bool cacheRouting(ccc::ProcessLayout& layout,
                    const std::string& instance_,
                    const std::string& routingStrategyName,
                    const std::string& destinationVenueName,
                    ets::product::DataPtr& product,
                    unsigned short exchangeId,
                    unsigned short algoStrategyId,
                    uint32_t dispatchIndex);
private:
  boost::dynamic_bitset<> _manuallyDropped;
  common::LightDoubleLinkedListRoot<ClientOrderListNode> _activeOrders;
  ets::router::tiaf::UMPSender* _logSenderPtr;
  bool _puntEnabled;

protected:
  Product _product;
  ScalingFactor _scalingFactor;
  uint32_t  _bucketNum;

public:
  const std::vector<StripeContext*>& legStripeContexts() const { return _legStripeContexts; }
  const std::set<StripeContext*>& compStripeContexts() const { return _compStripeContexts; }

  // make sure the stripeContext indexed by leg id 
  // all leg stripe contexts should be added in one batch
  void setLegStripeContexts(std::vector<StripeContext*>& legStripeContexts_);

  template <typename DerivStripeContextT = StripeContext>
  DerivStripeContextT& getLegStripeContext(LegId legId_) const 
  {
    assert(legId_ < _legStripeContexts.size());
    return static_cast<DerivStripeContextT&>(*_legStripeContexts[legId_]);
  }

protected:
  void addCompStripeContext(StripeContext* sc_);

protected:
  std::vector<StripeContext*> _legStripeContexts; // these are StripeContexts for legs if the current StripConext is for a notional product 
  std::set<StripeContext*> _compStripeContexts; // these are StripeContexts which uses THIS instance as a legStripeContext;
  
  /**
   * Cache of Destinations. Two dimensional array within a 'StripeContext' instance.
  *  index in vector is 'exchangeId'
   *  index in boost::array is 'routingStrategyId'
   */
  boost::array<std::vector<DestinationData>, vx::exch::RoutingStrategy::COUNT> _destinationCache;
};

}}} // end namespace ets::vx::om

Attention:  SymbolProfileBase.H
#ifndef _SymbolProfileBase_H
#define _SymbolProfileBase_H

#include <ets/vx/em/UtilCfg.H> //Includes staticStruct/StaticStruct.H
#include <ets/vx/em/ExchangeFactory.H>
#include <ets/vx/common/ThreadContext.H>
#include <ets/vx/om/StripeContext.H>
#include <unordered_map>

namespace ets { namespace vx { namespace om {

struct StripeContext;

static const int MAXEXCH = 256;

//Note: Pinnable attributess can be supported by adding the following static methods to stato::FieldAccessor<StructT>:
//      - pinAttribute(StructT* obj, const std::string& fieldName)
//      - unpinAttribute(StructT* obj, const std::string& fieldName)
//      - pinAttribute(StructT* obj, const std::string& fieldName, const std::string& inValue)
//The aforementioned methods will need to invoke statically "registered" macro methods is##F##Pinned, pin##F, unpin##F, pin##F(bool).
struct SymbolProfileBase {
    typedef ets::vx::exch::impl::ECSingleton<ets::vx::exch::impl::ECFactory<> > ExchCfgFactory;
    struct SymbolData {
        SymbolProfileBase* _sp;
        const StripeContext* _stc;
        SymbolData(SymbolProfileBase* sp_, const StripeContext* stc_) : _sp(sp_), _stc(stc_) {};
    };
    typedef std::unordered_map<std::string, SymbolData> SPMap;

    template<typename SymProfD>
    SymbolProfileBase(const StripeContext* stc_, SymProfD*) :
        _setValue((stato::SetValuePtr)stato::FieldAccessor<SymProfD>::setValue)
        , _getAttribute((stato::GetAttributePtr)stato::FieldAccessor<SymProfD>::getAttribute)
        , _getAttributes((stato::GetAttributesPtr)stato::FieldAccessor<SymProfD>::getAttributes)
        , _spDerivedSz(sizeof(SymProfD)) {
        using namespace ets::vx::exch;
        const std::string& name = stc_->product().mdSymbol;
        char* exchanges = reinterpret_cast<char*>(this) + sizeof(SymProfD); //Exchanges' configurations start at the end

        size_t offset = 0;
        uint8_t i = 0;
        for(auto it : exch::ExchangeFactory::instance().allExchanges()) {
            _exchangesBaseOffsets[i++] = offset;
            char *pos = exchanges + offset;
            size_t delta = ExchCfgFactory::instance().create(it->name(), pos);
#ifndef NDEBUG
            ORlogDebug << "SymbolProfile[" << name << "]: [" << it->name().asString() << "|" << (void*)pos << "|offset " << offset << " bytes|size " << delta << "]" << ORLog::send;
#endif
            offset+=delta;
        }
        _spMap->insert(std::make_pair(name, SymbolData(this,stc_)));
#ifndef NDEBUG
        ORlogDebug << "Done initializing [" << name << "] SymbolProfile" << ORLog::send;
#endif
    }

    ~SymbolProfileBase() {
    }

    void release(StripeContext* stc_) {
        _spMap->erase(stc_->product().mdSymbol);
        delete this;
    }

    SymbolProfileBase(const SymbolProfileBase&) = delete;
    SymbolProfileBase& operator=(const SymbolProfileBase&) = delete;

    template<typename SymProfD>
    static SymProfD* getSharedSP(const StripeContext* stc) {
        SymProfD* ret = new SymProfD(stc);
        return ret;
    }

    typedef void (*SymbolProfileFP)(const Product&, void*);

    static SymbolProfileFP _calvinCB;

    struct SpCbArgs {
        std::string expr;
        void *f;
    };

    template<typename SymProfD>
    static void initSPBase(std::string& exprFromXml) { //Needs to be called at app-level after ExchangeManager is initialized, but before creation of SymbolContext objects 
        using namespace ets::vx::exch;
        for (auto it : exch::ExchangeFactory::instance().allExchanges()) {
            SPsz += ExchCfgFactory::instance().getsz(it->name());
        }
        //Compile the Calvin expression from the cfg xml into a function that on construction of a SymProfD object, 
        //will initialize its memory optionally based on its associated Product's attributes
        SpCbArgs spcba = {"selectInto(" + exprFromXml + ", buffer)", 0};
        app::globalEvalCCTX().withCC(spCalvinExpressionCB<SymProfD>, &spcba);
        _calvinCB = (SymbolProfileFP)(spcba.f);
    }

    static void* operator new(size_t objsz) {
        void* ret = ::operator new(objsz + SPsz);
        memset(ret, 0, objsz + SPsz);
        return ret;
    }

    static void operator delete(void* p) {
        ::operator delete(p);
    }

    template<typename T>
    void getExchCfg(uint8_t exchid, T*& ecfg) {
        char* exchanges = reinterpret_cast<char*>(this) + _spDerivedSz; //Exchanges' configurations start at the end
        ecfg = reinterpret_cast<T*>(exchanges + _exchangesBaseOffsets[exchid]);
   }

    template<typename SymProfD>
    static calvin::MonoTypePtr getCalvinType(const calvin::TEnvPtr& tenv) {
        using namespace ets::vx::exch;
        impl::OffsetsMap offsetsMap;
        impl::populateOffsetsMap<SymProfD>(offsetsMap);
        calvin::Record::Members calvinRecordMembers;
        for(auto& i : offsetsMap) {
            calvinRecordMembers.emplace_back((i.second.name()).c_str(), calvin::primty(i.second.typeName().c_str()), i.first);
        }
        size_t spOffset = sizeof(SymProfD); //Map exchange configurations, starting at offset sizeof(SymProfD)
        for (auto it : exch::ExchangeFactory::instance().allExchanges()) {
            impl::OffsetsMap eOffsetsMap;
            ExchCfgFactory::instance().populateOffsetsMap(it->name(), eOffsetsMap);
            calvinRecordMembers.emplace_back((ets::utility::convertToString(it->name())).c_str(), embedCalvinRecord(tenv, it->name(), eOffsetsMap), spOffset);
            spOffset+=ExchCfgFactory::instance().getsz(it->name());
        }
        return calvin::MonoTypePtr(new calvin::Record(calvin::Record::withExplicitPadding(tenv, calvinRecordMembers, "pad")));
    }

    //Note: stato::FieldAccessor::setValue() returns false IFF the attribute was found BUT its value couldn't be changed
    bool setValue(const std::string& attrName, const std::string& value, const std::string& sym) {
        std::string cname("[" + sym + "]");
        stato::Attr attr;
        if (_setValue(this, attrName, value)) {
            if (_getAttribute(this, attrName, &attr)) {
                ORlogDebug << cname << ": SymbolProfile attribute " << attrName << " set to " << attr.value << ORLog::send;
                return true;
            }
            ORlogError << cname << ": SymbolProfile attribute " << attrName << " not found" << ORLog::send;
        } else {
            ORlogError << cname << ": Failed setting SymbolProfile attribute " << attrName << ORLog::send;
        }
        return false;
    }

    bool getAttribute(const std::string& attrName, stato::Attr* attr) {
        if (_getAttribute(this, attrName, attr)) {
            return true;
        }
        return false;
    }

    void getAttributes(stato::AttrMap& attributes) {
        _getAttributes(this, attributes);
    }

    static int symbolProfileMapInitCallback(void*) {
        SymbolProfileBase::_spMap = new SymbolProfileBase::SPMap;
        return 0;
    }

  private:
    static calvin::MonoTypePtr embedCalvinRecord(const calvin::TEnvPtr& tenv, const common::LightStringRef& name, ets::vx::exch::impl::OffsetsMap& omap) {
        calvin::Record::Members calvinRecordMembers;
        for(auto& i : omap) {
            calvinRecordMembers.emplace_back((i.second.name()).c_str(), calvin::primty(i.second.typeName().c_str()), i.first);
        }
        return calvin::MonoTypePtr(new calvin::Record(calvin::Record::withExplicitPadding(tenv, calvinRecordMembers, "pad")));
    }

    template<typename SymProfD>
    static void spCalvinExpressionCB(calvin::cc* cc, void* rv) {
        SpCbArgs *sprv = static_cast<SpCbArgs*>(rv);
        calvin::MonoTypePtr cmpt = getCalvinType<SymProfD>(cc->typeEnv());
        ORlogDebug << "Compiling Calvin expression: " << sprv->expr << " using SymbolProfile type: " << calvin::show(cmpt) << ORLog::send;
        try {
            sprv->f = cc->unsafeCompileFn(
                    calvin::prim<void>::type(),
                    calvin::list<std::string>("product", "buffer"),
                    calvin::list(app::globalEvalCCTX().type<Product*>(), cmpt),
                    cc->readExpr(sprv->expr)
            );
        } catch(const std::exception &e) {
            std::ostringstream ss;
            ss << "Failed to compile calvin SymbolProfile expression... " << e.what() << "[" << sprv->expr << "]\n";
            ORlogError << ss << ORLog::send;
            throw std::runtime_error(ss.str());
        }
    }

  public:
    static __thread SPMap* _spMap; //NB: gcc48 does not yet support dynamic initialization of thread_local
    static __thread size_t SPsz; //Size of memory segment holding all exchanges' configurations

    stato::SetValuePtr _setValue;
    stato::GetAttributePtr _getAttribute;
    stato::GetAttributesPtr _getAttributes;
    size_t _spDerivedSz;
    int _exchangesBaseOffsets[MAXEXCH];
};

}}}

#endif
